/*! For license information please see app.js.LICENSE.txt */ ! function() {
    var t = {
            157: function(t, e, n) {
                "use strict";
                t.exports = n.p + "assets/images/home-cylinder-02.png"
            },
            69: function(t) {
                t.exports = function() {
                    function t(t, e) {
                        for (var n = 0; n < e.length; n++) {
                            var i = e[n];
                            i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i)
                        }
                    }

                    function e(e, n, i) {
                        return n && t(e.prototype, n), i && t(e, i), e
                    }

                    function n() {
                        return (n = Object.assign || function(t) {
                            for (var e = 1; e < arguments.length; e++) {
                                var n = arguments[e];
                                for (var i in n) Object.prototype.hasOwnProperty.call(n, i) && (t[i] = n[i])
                            }
                            return t
                        }).apply(this, arguments)
                    }

                    function i(t, e) {
                        t.prototype = Object.create(e.prototype), t.prototype.constructor = t, t.__proto__ = e
                    }

                    function r(t) {
                        return (r = Object.setPrototypeOf ? Object.getPrototypeOf : function(t) {
                            return t.__proto__ || Object.getPrototypeOf(t)
                        })(t)
                    }

                    function s(t, e) {
                        return (s = Object.setPrototypeOf || function(t, e) {
                            return t.__proto__ = e, t
                        })(t, e)
                    }

                    function o(t, e, n) {
                        return (o = function() {
                            if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
                            if (Reflect.construct.sham) return !1;
                            if ("function" == typeof Proxy) return !0;
                            try {
                                return Date.prototype.toString.call(Reflect.construct(Date, [], (function() {}))), !0
                            } catch (t) {
                                return !1
                            }
                        }() ? Reflect.construct : function(t, e, n) {
                            var i = [null];
                            i.push.apply(i, e);
                            var r = new(Function.bind.apply(t, i));
                            return n && s(r, n.prototype), r
                        }).apply(null, arguments)
                    }

                    function a(t) {
                        var e = "function" == typeof Map ? new Map : void 0;
                        return (a = function(t) {
                            if (null === t || -1 === Function.toString.call(t).indexOf("[native code]")) return t;
                            if ("function" != typeof t) throw new TypeError("Super expression must either be null or a function");
                            if (void 0 !== e) {
                                if (e.has(t)) return e.get(t);
                                e.set(t, n)
                            }

                            function n() {
                                return o(t, arguments, r(this).constructor)
                            }
                            return n.prototype = Object.create(t.prototype, {
                                constructor: {
                                    value: n,
                                    enumerable: !1,
                                    writable: !0,
                                    configurable: !0
                                }
                            }), s(n, t)
                        })(t)
                    }

                    function l(t, e) {
                        try {
                            var n = t()
                        } catch (t) {
                            return e(t)
                        }
                        return n && n.then ? n.then(void 0, e) : n
                    }
                    "undefined" != typeof Symbol && (Symbol.iterator || (Symbol.iterator = Symbol("Symbol.iterator"))), "undefined" != typeof Symbol && (Symbol.asyncIterator || (Symbol.asyncIterator = Symbol("Symbol.asyncIterator")));
                    var c, u = "2.9.7",
                        h = function() {};
                    ! function(t) {
                        t[t.off = 0] = "off", t[t.error = 1] = "error", t[t.warning = 2] = "warning", t[t.info = 3] = "info", t[t.debug = 4] = "debug"
                    }(c || (c = {}));
                    var d = c.off,
                        p = function() {
                            function t(t) {
                                this.t = t
                            }
                            t.getLevel = function() {
                                return d
                            }, t.setLevel = function(t) {
                                return d = c[t]
                            };
                            var e = t.prototype;
                            return e.error = function() {
                                for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++) e[n] = arguments[n];
                                this.i(console.error, c.error, e)
                            }, e.warn = function() {
                                for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++) e[n] = arguments[n];
                                this.i(console.warn, c.warning, e)
                            }, e.info = function() {
                                for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++) e[n] = arguments[n];
                                this.i(console.info, c.info, e)
                            }, e.debug = function() {
                                for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++) e[n] = arguments[n];
                                this.i(console.log, c.debug, e)
                            }, e.i = function(e, n, i) {
                                n <= t.getLevel() && e.apply(console, ["[" + this.t + "] "].concat(i))
                            }, t
                        }(),
                        f = A,
                        m = w,
                        g = b,
                        v = M,
                        y = T,
                        x = "/",
                        _ = new RegExp(["(\\\\.)", "(?:\\:(\\w+)(?:\\(((?:\\\\.|[^\\\\()])+)\\))?|\\(((?:\\\\.|[^\\\\()])+)\\))([+*?])?"].join("|"), "g");

                    function b(t, e) {
                        for (var n, i = [], r = 0, s = 0, o = "", a = e && e.delimiter || x, l = e && e.whitelist || void 0, c = !1; null !== (n = _.exec(t));) {
                            var u = n[0],
                                h = n[1],
                                d = n.index;
                            if (o += t.slice(s, d), s = d + u.length, h) o += h[1], c = !0;
                            else {
                                var p = "",
                                    f = n[2],
                                    m = n[3],
                                    g = n[4],
                                    v = n[5];
                                if (!c && o.length) {
                                    var y = o.length - 1,
                                        b = o[y];
                                    (!l || l.indexOf(b) > -1) && (p = b, o = o.slice(0, y))
                                }
                                o && (i.push(o), o = "", c = !1);
                                var w = m || g,
                                    M = p || a;
                                i.push({
                                    name: f || r++,
                                    prefix: p,
                                    delimiter: M,
                                    optional: "?" === v || "*" === v,
                                    repeat: "+" === v || "*" === v,
                                    pattern: w ? E(w) : "[^" + S(M === a ? M : M + a) + "]+?"
                                })
                            }
                        }
                        return (o || s < t.length) && i.push(o + t.substr(s)), i
                    }

                    function w(t, e) {
                        return function(n, i) {
                            var r = t.exec(n);
                            if (!r) return !1;
                            for (var s = r[0], o = r.index, a = {}, l = i && i.decode || decodeURIComponent, c = 1; c < r.length; c++)
                                if (void 0 !== r[c]) {
                                    var u = e[c - 1];
                                    a[u.name] = u.repeat ? r[c].split(u.delimiter).map((function(t) {
                                        return l(t, u)
                                    })) : l(r[c], u)
                                }
                            return {
                                path: s,
                                index: o,
                                params: a
                            }
                        }
                    }

                    function M(t, e) {
                        for (var n = new Array(t.length), i = 0; i < t.length; i++) "object" == typeof t[i] && (n[i] = new RegExp("^(?:" + t[i].pattern + ")$", D(e)));
                        return function(e, i) {
                            for (var r = "", s = i && i.encode || encodeURIComponent, o = !i || !1 !== i.validate, a = 0; a < t.length; a++) {
                                var l = t[a];
                                if ("string" != typeof l) {
                                    var c, u = e ? e[l.name] : void 0;
                                    if (Array.isArray(u)) {
                                        if (!l.repeat) throw new TypeError('Expected "' + l.name + '" to not repeat, but got array');
                                        if (0 === u.length) {
                                            if (l.optional) continue;
                                            throw new TypeError('Expected "' + l.name + '" to not be empty')
                                        }
                                        for (var h = 0; h < u.length; h++) {
                                            if (c = s(u[h], l), o && !n[a].test(c)) throw new TypeError('Expected all "' + l.name + '" to match "' + l.pattern + '"');
                                            r += (0 === h ? l.prefix : l.delimiter) + c
                                        }
                                    } else if ("string" != typeof u && "number" != typeof u && "boolean" != typeof u) {
                                        if (!l.optional) throw new TypeError('Expected "' + l.name + '" to be ' + (l.repeat ? "an array" : "a string"))
                                    } else {
                                        if (c = s(String(u), l), o && !n[a].test(c)) throw new TypeError('Expected "' + l.name + '" to match "' + l.pattern + '", but got "' + c + '"');
                                        r += l.prefix + c
                                    }
                                } else r += l
                            }
                            return r
                        }
                    }

                    function S(t) {
                        return t.replace(/([.+*?=^!:${}()[\]|/\\])/g, "\\$1")
                    }

                    function E(t) {
                        return t.replace(/([=!:$/()])/g, "\\$1")
                    }

                    function D(t) {
                        return t && t.sensitive ? "" : "i"
                    }

                    function T(t, e, n) {
                        for (var i = (n = n || {}).strict, r = !1 !== n.start, s = !1 !== n.end, o = n.delimiter || x, a = [].concat(n.endsWith || []).map(S).concat("$").join("|"), l = r ? "^" : "", c = 0; c < t.length; c++) {
                            var u = t[c];
                            if ("string" == typeof u) l += S(u);
                            else {
                                var h = u.repeat ? "(?:" + u.pattern + ")(?:" + S(u.delimiter) + "(?:" + u.pattern + "))*" : u.pattern;
                                e && e.push(u), l += u.optional ? u.prefix ? "(?:" + S(u.prefix) + "(" + h + "))?" : "(" + h + ")?" : S(u.prefix) + "(" + h + ")"
                            }
                        }
                        if (s) i || (l += "(?:" + S(o) + ")?"), l += "$" === a ? "$" : "(?=" + a + ")";
                        else {
                            var d = t[t.length - 1],
                                p = "string" == typeof d ? d[d.length - 1] === o : void 0 === d;
                            i || (l += "(?:" + S(o) + "(?=" + a + "))?"), p || (l += "(?=" + S(o) + "|" + a + ")")
                        }
                        return new RegExp(l, D(n))
                    }

                    function A(t, e, n) {
                        return t instanceof RegExp ? function(t, e) {
                            if (!e) return t;
                            var n = t.source.match(/\((?!\?)/g);
                            if (n)
                                for (var i = 0; i < n.length; i++) e.push({
                                    name: i,
                                    prefix: null,
                                    delimiter: null,
                                    optional: !1,
                                    repeat: !1,
                                    pattern: null
                                });
                            return t
                        }(t, e) : Array.isArray(t) ? function(t, e, n) {
                            for (var i = [], r = 0; r < t.length; r++) i.push(A(t[r], e, n).source);
                            return new RegExp("(?:" + i.join("|") + ")", D(n))
                        }(t, e, n) : function(t, e, n) {
                            return T(b(t, n), e, n)
                        }(t, e, n)
                    }
                    f.match = function(t, e) {
                        var n = [];
                        return w(A(t, n, e), n)
                    }, f.regexpToFunction = m, f.parse = g, f.compile = function(t, e) {
                        return M(b(t, e), e)
                    }, f.tokensToFunction = v, f.tokensToRegExp = y;
                    var C = {
                            container: "container",
                            history: "history",
                            namespace: "namespace",
                            prefix: "data-barba",
                            prevent: "prevent",
                            wrapper: "wrapper"
                        },
                        L = new(function() {
                            function t() {
                                this.o = C, this.u = new DOMParser
                            }
                            var e = t.prototype;
                            return e.toString = function(t) {
                                return t.outerHTML
                            }, e.toDocument = function(t) {
                                return this.u.parseFromString(t, "text/html")
                            }, e.toElement = function(t) {
                                var e = document.createElement("div");
                                return e.innerHTML = t, e
                            }, e.getHtml = function(t) {
                                return void 0 === t && (t = document), this.toString(t.documentElement)
                            }, e.getWrapper = function(t) {
                                return void 0 === t && (t = document), t.querySelector("[" + this.o.prefix + '="' + this.o.wrapper + '"]')
                            }, e.getContainer = function(t) {
                                return void 0 === t && (t = document), t.querySelector("[" + this.o.prefix + '="' + this.o.container + '"]')
                            }, e.removeContainer = function(t) {
                                document.body.contains(t) && t.parentNode.removeChild(t)
                            }, e.addContainer = function(t, e) {
                                var n = this.getContainer();
                                n ? this.s(t, n) : e.appendChild(t)
                            }, e.getNamespace = function(t) {
                                void 0 === t && (t = document);
                                var e = t.querySelector("[" + this.o.prefix + "-" + this.o.namespace + "]");
                                return e ? e.getAttribute(this.o.prefix + "-" + this.o.namespace) : null
                            }, e.getHref = function(t) {
                                if (t.tagName && "a" === t.tagName.toLowerCase()) {
                                    if ("string" == typeof t.href) return t.href;
                                    var e = t.getAttribute("href") || t.getAttribute("xlink:href");
                                    if (e) return this.resolveUrl(e.baseVal || e)
                                }
                                return null
                            }, e.resolveUrl = function() {
                                for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++) e[n] = arguments[n];
                                var i = e.length;
                                if (0 === i) throw new Error("resolveUrl requires at least one argument; got none.");
                                var r = document.createElement("base");
                                if (r.href = arguments[0], 1 === i) return r.href;
                                var s = document.getElementsByTagName("head")[0];
                                s.insertBefore(r, s.firstChild);
                                for (var o, a = document.createElement("a"), l = 1; l < i; l++) a.href = arguments[l], r.href = o = a.href;
                                return s.removeChild(r), o
                            }, e.s = function(t, e) {
                                e.parentNode.insertBefore(t, e.nextSibling)
                            }, t
                        }()),
                        R = new(function() {
                            function t() {
                                this.h = [], this.v = -1
                            }
                            var i = t.prototype;
                            return i.init = function(t, e) {
                                this.l = "barba";
                                var n = {
                                    ns: e,
                                    scroll: {
                                        x: window.scrollX,
                                        y: window.scrollY
                                    },
                                    url: t
                                };
                                this.h.push(n), this.v = 0;
                                var i = {
                                    from: this.l,
                                    index: 0,
                                    states: [].concat(this.h)
                                };
                                window.history && window.history.replaceState(i, "", t)
                            }, i.change = function(t, e, n) {
                                if (n && n.state) {
                                    var i = n.state,
                                        r = i.index;
                                    e = this.m(this.v - r), this.replace(i.states), this.v = r
                                } else this.add(t, e);
                                return e
                            }, i.add = function(t, e) {
                                var n = this.size,
                                    i = this.p(e),
                                    r = {
                                        ns: "tmp",
                                        scroll: {
                                            x: window.scrollX,
                                            y: window.scrollY
                                        },
                                        url: t
                                    };
                                this.h.push(r), this.v = n;
                                var s = {
                                    from: this.l,
                                    index: n,
                                    states: [].concat(this.h)
                                };
                                switch (i) {
                                    case "push":
                                        window.history && window.history.pushState(s, "", t);
                                        break;
                                    case "replace":
                                        window.history && window.history.replaceState(s, "", t)
                                }
                            }, i.update = function(t, e) {
                                var i = e || this.v,
                                    r = n({}, this.get(i), {}, t);
                                this.set(i, r)
                            }, i.remove = function(t) {
                                t ? this.h.splice(t, 1) : this.h.pop(), this.v--
                            }, i.clear = function() {
                                this.h = [], this.v = -1
                            }, i.replace = function(t) {
                                this.h = t
                            }, i.get = function(t) {
                                return this.h[t]
                            }, i.set = function(t, e) {
                                return this.h[t] = e
                            }, i.p = function(t) {
                                var e = "push",
                                    n = t,
                                    i = C.prefix + "-" + C.history;
                                return n.hasAttribute && n.hasAttribute(i) && (e = n.getAttribute(i)), e
                            }, i.m = function(t) {
                                return Math.abs(t) > 1 ? t > 0 ? "forward" : "back" : 0 === t ? "popstate" : t > 0 ? "back" : "forward"
                            }, e(t, [{
                                key: "current",
                                get: function() {
                                    return this.h[this.v]
                                }
                            }, {
                                key: "state",
                                get: function() {
                                    return this.h[this.h.length - 1]
                                }
                            }, {
                                key: "previous",
                                get: function() {
                                    return this.v < 1 ? null : this.h[this.v - 1]
                                }
                            }, {
                                key: "size",
                                get: function() {
                                    return this.h.length
                                }
                            }]), t
                        }()),
                        P = function(t, e) {
                            try {
                                var n = function() {
                                    if (!e.next.html) return Promise.resolve(t).then((function(t) {
                                        var n = e.next;
                                        if (t) {
                                            var i = L.toElement(t);
                                            n.namespace = L.getNamespace(i), n.container = L.getContainer(i), n.html = t, R.update({
                                                ns: n.namespace
                                            });
                                            var r = L.toDocument(t);
                                            document.title = r.title
                                        }
                                    }))
                                }();
                                return Promise.resolve(n && n.then ? n.then((function() {})) : void 0)
                            } catch (t) {
                                return Promise.reject(t)
                            }
                        },
                        F = f,
                        O = {
                            __proto__: null,
                            update: P,
                            nextTick: function() {
                                return new Promise((function(t) {
                                    window.requestAnimationFrame(t)
                                }))
                            },
                            pathToRegexp: F
                        },
                        I = function() {
                            return window.location.origin
                        },
                        N = function(t) {
                            return void 0 === t && (t = window.location.href), B(t).port
                        },
                        B = function(t) {
                            var e, n = t.match(/:\d+/);
                            if (null === n) /^http/.test(t) && (e = 80), /^https/.test(t) && (e = 443);
                            else {
                                var i = n[0].substring(1);
                                e = parseInt(i, 10)
                            }
                            var r, s = t.replace(I(), ""),
                                o = {},
                                a = s.indexOf("#");
                            a >= 0 && (r = s.slice(a + 1), s = s.slice(0, a));
                            var l = s.indexOf("?");
                            return l >= 0 && (o = z(s.slice(l + 1)), s = s.slice(0, l)), {
                                hash: r,
                                path: s,
                                port: e,
                                query: o
                            }
                        },
                        z = function(t) {
                            return t.split("&").reduce((function(t, e) {
                                var n = e.split("=");
                                return t[n[0]] = n[1], t
                            }), {})
                        },
                        k = function(t) {
                            return void 0 === t && (t = window.location.href), t.replace(/(\/#.*|\/|#.*)$/, "")
                        },
                        H = {
                            __proto__: null,
                            getHref: function() {
                                return window.location.href
                            },
                            getOrigin: I,
                            getPort: N,
                            getPath: function(t) {
                                return void 0 === t && (t = window.location.href), B(t).path
                            },
                            parse: B,
                            parseQuery: z,
                            clean: k
                        };

                    function U(t, e, n) {
                        return void 0 === e && (e = 2e3), new Promise((function(i, r) {
                            var s = new XMLHttpRequest;
                            s.onreadystatechange = function() {
                                if (s.readyState === XMLHttpRequest.DONE)
                                    if (200 === s.status) i(s.responseText);
                                    else if (s.status) {
                                    var e = {
                                        status: s.status,
                                        statusText: s.statusText
                                    };
                                    n(t, e), r(e)
                                }
                            }, s.ontimeout = function() {
                                var i = new Error("Timeout error [" + e + "]");
                                n(t, i), r(i)
                            }, s.onerror = function() {
                                var e = new Error("Fetch error");
                                n(t, e), r(e)
                            }, s.open("GET", t), s.timeout = e, s.setRequestHeader("Accept", "text/html,application/xhtml+xml,application/xml"), s.setRequestHeader("x-barba", "yes"), s.send()
                        }))
                    }
                    var G = function(t) {
                        return !!t && ("object" == typeof t || "function" == typeof t) && "function" == typeof t.then
                    };

                    function W(t, e) {
                        return void 0 === e && (e = {}),
                            function() {
                                for (var n = arguments.length, i = new Array(n), r = 0; r < n; r++) i[r] = arguments[r];
                                var s = !1;
                                return new Promise((function(n, r) {
                                    e.async = function() {
                                        return s = !0,
                                            function(t, e) {
                                                t ? r(t) : n(e)
                                            }
                                    };
                                    var o = t.apply(e, i);
                                    s || (G(o) ? o.then(n, r) : n(o))
                                }))
                            }
                    }
                    var V = new(function(t) {
                            function e() {
                                var e;
                                return (e = t.call(this) || this).logger = new p("@barba/core"), e.all = ["ready", "page", "reset", "currentAdded", "currentRemoved", "nextAdded", "nextRemoved", "beforeOnce", "once", "afterOnce", "before", "beforeLeave", "leave", "afterLeave", "beforeEnter", "enter", "afterEnter", "after"], e.registered = new Map, e.init(), e
                            }
                            i(e, t);
                            var n = e.prototype;
                            return n.init = function() {
                                var t = this;
                                this.registered.clear(), this.all.forEach((function(e) {
                                    t[e] || (t[e] = function(n, i) {
                                        t.registered.has(e) || t.registered.set(e, new Set), t.registered.get(e).add({
                                            ctx: i || {},
                                            fn: n
                                        })
                                    })
                                }))
                            }, n.do = function(t) {
                                for (var e = this, n = arguments.length, i = new Array(n > 1 ? n - 1 : 0), r = 1; r < n; r++) i[r - 1] = arguments[r];
                                if (this.registered.has(t)) {
                                    var s = Promise.resolve();
                                    return this.registered.get(t).forEach((function(t) {
                                        s = s.then((function() {
                                            return W(t.fn, t.ctx).apply(void 0, i)
                                        }))
                                    })), s.catch((function(n) {
                                        e.logger.debug("Hook error [" + t + "]"), e.logger.error(n)
                                    }))
                                }
                                return Promise.resolve()
                            }, n.clear = function() {
                                var t = this;
                                this.all.forEach((function(e) {
                                    delete t[e]
                                })), this.init()
                            }, n.help = function() {
                                this.logger.info("Available hooks: " + this.all.join(","));
                                var t = [];
                                this.registered.forEach((function(e, n) {
                                    return t.push(n)
                                })), this.logger.info("Registered hooks: " + t.join(","))
                            }, e
                        }(h)),
                        j = function() {
                            function t(t) {
                                if (this.P = [], "boolean" == typeof t) this.g = t;
                                else {
                                    var e = Array.isArray(t) ? t : [t];
                                    this.P = e.map((function(t) {
                                        return F(t)
                                    }))
                                }
                            }
                            return t.prototype.checkHref = function(t) {
                                if ("boolean" == typeof this.g) return this.g;
                                var e = B(t).path;
                                return this.P.some((function(t) {
                                    return null !== t.exec(e)
                                }))
                            }, t
                        }(),
                        q = function(t) {
                            function e(e) {
                                var n;
                                return (n = t.call(this, e) || this).k = new Map, n
                            }
                            i(e, t);
                            var r = e.prototype;
                            return r.set = function(t, e, n) {
                                return this.k.set(t, {
                                    action: n,
                                    request: e
                                }), {
                                    action: n,
                                    request: e
                                }
                            }, r.get = function(t) {
                                return this.k.get(t)
                            }, r.getRequest = function(t) {
                                return this.k.get(t).request
                            }, r.getAction = function(t) {
                                return this.k.get(t).action
                            }, r.has = function(t) {
                                return !this.checkHref(t) && this.k.has(t)
                            }, r.delete = function(t) {
                                return this.k.delete(t)
                            }, r.update = function(t, e) {
                                var i = n({}, this.k.get(t), {}, e);
                                return this.k.set(t, i), i
                            }, e
                        }(j),
                        X = function() {
                            return !window.history.pushState
                        },
                        Y = function(t) {
                            return !t.el || !t.href
                        },
                        Z = function(t) {
                            var e = t.event;
                            return e.which > 1 || e.metaKey || e.ctrlKey || e.shiftKey || e.altKey
                        },
                        J = function(t) {
                            var e = t.el;
                            return e.hasAttribute("target") && "_blank" === e.target
                        },
                        Q = function(t) {
                            var e = t.el;
                            return void 0 !== e.protocol && window.location.protocol !== e.protocol || void 0 !== e.hostname && window.location.hostname !== e.hostname
                        },
                        K = function(t) {
                            var e = t.el;
                            return void 0 !== e.port && N() !== N(e.href)
                        },
                        $ = function(t) {
                            var e = t.el;
                            return e.getAttribute && "string" == typeof e.getAttribute("download")
                        },
                        tt = function(t) {
                            return t.el.hasAttribute(C.prefix + "-" + C.prevent)
                        },
                        et = function(t) {
                            return Boolean(t.el.closest("[" + C.prefix + "-" + C.prevent + '="all"]'))
                        },
                        nt = function(t) {
                            var e = t.href;
                            return k(e) === k() && N(e) === N()
                        },
                        it = function(t) {
                            function e(e) {
                                var n;
                                return (n = t.call(this, e) || this).suite = [], n.tests = new Map, n.init(), n
                            }
                            i(e, t);
                            var n = e.prototype;
                            return n.init = function() {
                                this.add("pushState", X), this.add("exists", Y), this.add("newTab", Z), this.add("blank", J), this.add("corsDomain", Q), this.add("corsPort", K), this.add("download", $), this.add("preventSelf", tt), this.add("preventAll", et), this.add("sameUrl", nt, !1)
                            }, n.add = function(t, e, n) {
                                void 0 === n && (n = !0), this.tests.set(t, e), n && this.suite.push(t)
                            }, n.run = function(t, e, n, i) {
                                return this.tests.get(t)({
                                    el: e,
                                    event: n,
                                    href: i
                                })
                            }, n.checkLink = function(t, e, n) {
                                var i = this;
                                return this.suite.some((function(r) {
                                    return i.run(r, t, e, n)
                                }))
                            }, e
                        }(j),
                        rt = function(t) {
                            function e(n, i) {
                                var r;
                                void 0 === i && (i = "Barba error");
                                for (var s = arguments.length, o = new Array(s > 2 ? s - 2 : 0), a = 2; a < s; a++) o[a - 2] = arguments[a];
                                return (r = t.call.apply(t, [this].concat(o)) || this).error = n, r.label = i, Error.captureStackTrace && Error.captureStackTrace(function(t) {
                                    if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                                    return t
                                }(r), e), r.name = "BarbaError", r
                            }
                            return i(e, t), e
                        }(a(Error)),
                        st = function() {
                            function t(t) {
                                void 0 === t && (t = []), this.logger = new p("@barba/core"), this.all = [], this.page = [], this.once = [], this.A = [{
                                    name: "namespace",
                                    type: "strings"
                                }, {
                                    name: "custom",
                                    type: "function"
                                }], t && (this.all = this.all.concat(t)), this.update()
                            }
                            var e = t.prototype;
                            return e.add = function(t, e) {
                                switch (t) {
                                    case "rule":
                                        this.A.splice(e.position || 0, 0, e.value);
                                        break;
                                    case "transition":
                                    default:
                                        this.all.push(e)
                                }
                                this.update()
                            }, e.resolve = function(t, e) {
                                var n = this;
                                void 0 === e && (e = {});
                                var i = e.once ? this.once : this.page;
                                i = i.filter(e.self ? function(t) {
                                    return t.name && "self" === t.name
                                } : function(t) {
                                    return !t.name || "self" !== t.name
                                });
                                var r = new Map,
                                    s = i.find((function(i) {
                                        var s = !0,
                                            o = {};
                                        return !(!e.self || "self" !== i.name) || (n.A.reverse().forEach((function(e) {
                                            s && (s = n.R(i, e, t, o), i.from && i.to && (s = n.R(i, e, t, o, "from") && n.R(i, e, t, o, "to")), i.from && !i.to && (s = n.R(i, e, t, o, "from")), !i.from && i.to && (s = n.R(i, e, t, o, "to")))
                                        })), r.set(i, o), s)
                                    })),
                                    o = r.get(s),
                                    a = [];
                                if (a.push(e.once ? "once" : "page"), e.self && a.push("self"), o) {
                                    var l, c = [s];
                                    Object.keys(o).length > 0 && c.push(o), (l = this.logger).info.apply(l, ["Transition found [" + a.join(",") + "]"].concat(c))
                                } else this.logger.info("No transition found [" + a.join(",") + "]");
                                return s
                            }, e.update = function() {
                                var t = this;
                                this.all = this.all.map((function(e) {
                                    return t.T(e)
                                })).sort((function(t, e) {
                                    return t.priority - e.priority
                                })).reverse().map((function(t) {
                                    return delete t.priority, t
                                })), this.page = this.all.filter((function(t) {
                                    return void 0 !== t.leave || void 0 !== t.enter
                                })), this.once = this.all.filter((function(t) {
                                    return void 0 !== t.once
                                }))
                            }, e.R = function(t, e, n, i, r) {
                                var s = !0,
                                    o = !1,
                                    a = t,
                                    l = e.name,
                                    c = l,
                                    u = l,
                                    h = l,
                                    d = r ? a[r] : a,
                                    p = "to" === r ? n.next : n.current;
                                if (r ? d && d[l] : d[l]) {
                                    switch (e.type) {
                                        case "strings":
                                        default:
                                            var f = Array.isArray(d[c]) ? d[c] : [d[c]];
                                            p[c] && -1 !== f.indexOf(p[c]) && (o = !0), -1 === f.indexOf(p[c]) && (s = !1);
                                            break;
                                        case "object":
                                            var m = Array.isArray(d[u]) ? d[u] : [d[u]];
                                            p[u] ? (p[u].name && -1 !== m.indexOf(p[u].name) && (o = !0), -1 === m.indexOf(p[u].name) && (s = !1)) : s = !1;
                                            break;
                                        case "function":
                                            d[h](n) ? o = !0 : s = !1
                                    }
                                    o && (r ? (i[r] = i[r] || {}, i[r][l] = a[r][l]) : i[l] = a[l])
                                }
                                return s
                            }, e.O = function(t, e, n) {
                                var i = 0;
                                return (t[e] || t.from && t.from[e] || t.to && t.to[e]) && (i += Math.pow(10, n), t.from && t.from[e] && (i += 1), t.to && t.to[e] && (i += 2)), i
                            }, e.T = function(t) {
                                var e = this;
                                t.priority = 0;
                                var n = 0;
                                return this.A.forEach((function(i, r) {
                                    n += e.O(t, i.name, r + 1)
                                })), t.priority = n, t
                            }, t
                        }(),
                        ot = function() {
                            function t(t) {
                                void 0 === t && (t = []), this.logger = new p("@barba/core"), this.S = !1, this.store = new st(t)
                            }
                            var n = t.prototype;
                            return n.get = function(t, e) {
                                return this.store.resolve(t, e)
                            }, n.doOnce = function(t) {
                                var e = t.data,
                                    n = t.transition;
                                try {
                                    var i = function() {
                                            r.S = !1
                                        },
                                        r = this,
                                        s = n || {};
                                    r.S = !0;
                                    var o = l((function() {
                                        return Promise.resolve(r.j("beforeOnce", e, s)).then((function() {
                                            return Promise.resolve(r.once(e, s)).then((function() {
                                                return Promise.resolve(r.j("afterOnce", e, s)).then((function() {}))
                                            }))
                                        }))
                                    }), (function(t) {
                                        r.S = !1, r.logger.debug("Transition error [before/after/once]"), r.logger.error(t)
                                    }));
                                    return Promise.resolve(o && o.then ? o.then(i) : i())
                                } catch (t) {
                                    return Promise.reject(t)
                                }
                            }, n.doPage = function(t) {
                                var e = t.data,
                                    n = t.transition,
                                    i = t.page,
                                    r = t.wrapper;
                                try {
                                    var s = function(t) {
                                            if (o) return t;
                                            a.S = !1
                                        },
                                        o = !1,
                                        a = this,
                                        c = n || {},
                                        u = !0 === c.sync || !1;
                                    a.S = !0;
                                    var h = l((function() {
                                        function t() {
                                            return Promise.resolve(a.j("before", e, c)).then((function() {
                                                var t = !1;

                                                function n(n) {
                                                    return t ? n : Promise.resolve(a.remove(e)).then((function() {
                                                        return Promise.resolve(a.j("after", e, c)).then((function() {}))
                                                    }))
                                                }
                                                var s = function() {
                                                    if (u) return l((function() {
                                                        return Promise.resolve(a.add(e, r)).then((function() {
                                                            return Promise.resolve(a.j("beforeLeave", e, c)).then((function() {
                                                                return Promise.resolve(a.j("beforeEnter", e, c)).then((function() {
                                                                    return Promise.resolve(Promise.all([a.leave(e, c), a.enter(e, c)])).then((function() {
                                                                        return Promise.resolve(a.j("afterLeave", e, c)).then((function() {
                                                                            return Promise.resolve(a.j("afterEnter", e, c)).then((function() {}))
                                                                        }))
                                                                    }))
                                                                }))
                                                            }))
                                                        }))
                                                    }), (function(t) {
                                                        if (a.M(t)) throw new rt(t, "Transition error [sync]")
                                                    }));
                                                    var n = function(n) {
                                                            return t ? n : l((function() {
                                                                var t = function() {
                                                                    if (!1 !== s) return Promise.resolve(a.add(e, r)).then((function() {
                                                                        return Promise.resolve(a.j("beforeEnter", e, c)).then((function() {
                                                                            return Promise.resolve(a.enter(e, c, s)).then((function() {
                                                                                return Promise.resolve(a.j("afterEnter", e, c)).then((function() {}))
                                                                            }))
                                                                        }))
                                                                    }))
                                                                }();
                                                                if (t && t.then) return t.then((function() {}))
                                                            }), (function(t) {
                                                                if (a.M(t)) throw new rt(t, "Transition error [before/after/enter]")
                                                            }))
                                                        },
                                                        s = !1,
                                                        o = l((function() {
                                                            return Promise.resolve(a.j("beforeLeave", e, c)).then((function() {
                                                                return Promise.resolve(Promise.all([a.leave(e, c), P(i, e)]).then((function(t) {
                                                                    return t[0]
                                                                }))).then((function(t) {
                                                                    return s = t, Promise.resolve(a.j("afterLeave", e, c)).then((function() {}))
                                                                }))
                                                            }))
                                                        }), (function(t) {
                                                            if (a.M(t)) throw new rt(t, "Transition error [before/after/leave]")
                                                        }));
                                                    return o && o.then ? o.then(n) : n(o)
                                                }();
                                                return s && s.then ? s.then(n) : n(s)
                                            }))
                                        }
                                        var n = function() {
                                            if (u) return Promise.resolve(P(i, e)).then((function() {}))
                                        }();
                                        return n && n.then ? n.then(t) : t()
                                    }), (function(t) {
                                        if (a.S = !1, t.name && "BarbaError" === t.name) throw a.logger.debug(t.label), a.logger.error(t.error), t;
                                        throw a.logger.debug("Transition error [page]"), a.logger.error(t), t
                                    }));
                                    return Promise.resolve(h && h.then ? h.then(s) : s(h))
                                } catch (t) {
                                    return Promise.reject(t)
                                }
                            }, n.once = function(t, e) {
                                try {
                                    return Promise.resolve(V.do("once", t, e)).then((function() {
                                        return e.once ? W(e.once, e)(t) : Promise.resolve()
                                    }))
                                } catch (t) {
                                    return Promise.reject(t)
                                }
                            }, n.leave = function(t, e) {
                                try {
                                    return Promise.resolve(V.do("leave", t, e)).then((function() {
                                        return e.leave ? W(e.leave, e)(t) : Promise.resolve()
                                    }))
                                } catch (t) {
                                    return Promise.reject(t)
                                }
                            }, n.enter = function(t, e, n) {
                                try {
                                    return Promise.resolve(V.do("enter", t, e)).then((function() {
                                        return e.enter ? W(e.enter, e)(t, n) : Promise.resolve()
                                    }))
                                } catch (t) {
                                    return Promise.reject(t)
                                }
                            }, n.add = function(t, e) {
                                try {
                                    return L.addContainer(t.next.container, e), V.do("nextAdded", t), Promise.resolve()
                                } catch (t) {
                                    return Promise.reject(t)
                                }
                            }, n.remove = function(t) {
                                try {
                                    return L.removeContainer(t.current.container), V.do("currentRemoved", t), Promise.resolve()
                                } catch (t) {
                                    return Promise.reject(t)
                                }
                            }, n.M = function(t) {
                                return t.message ? !/Timeout error|Fetch error/.test(t.message) : !t.status
                            }, n.j = function(t, e, n) {
                                try {
                                    return Promise.resolve(V.do(t, e, n)).then((function() {
                                        return n[t] ? W(n[t], n)(e) : Promise.resolve()
                                    }))
                                } catch (t) {
                                    return Promise.reject(t)
                                }
                            }, e(t, [{
                                key: "isRunning",
                                get: function() {
                                    return this.S
                                },
                                set: function(t) {
                                    this.S = t
                                }
                            }, {
                                key: "hasOnce",
                                get: function() {
                                    return this.store.once.length > 0
                                }
                            }, {
                                key: "hasSelf",
                                get: function() {
                                    return this.store.all.some((function(t) {
                                        return "self" === t.name
                                    }))
                                }
                            }, {
                                key: "shouldWait",
                                get: function() {
                                    return this.store.all.some((function(t) {
                                        return t.to && !t.to.route || t.sync
                                    }))
                                }
                            }]), t
                        }(),
                        at = function() {
                            function t(t) {
                                var e = this;
                                this.names = ["beforeLeave", "afterLeave", "beforeEnter", "afterEnter"], this.byNamespace = new Map, 0 !== t.length && (t.forEach((function(t) {
                                    e.byNamespace.set(t.namespace, t)
                                })), this.names.forEach((function(t) {
                                    V[t](e.L(t))
                                })))
                            }
                            return t.prototype.L = function(t) {
                                var e = this;
                                return function(n) {
                                    var i = t.match(/enter/i) ? n.next : n.current,
                                        r = e.byNamespace.get(i.namespace);
                                    return r && r[t] ? W(r[t], r)(n) : Promise.resolve()
                                }
                            }, t
                        }();
                    Element.prototype.matches || (Element.prototype.matches = Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector), Element.prototype.closest || (Element.prototype.closest = function(t) {
                        var e = this;
                        do {
                            if (e.matches(t)) return e;
                            e = e.parentElement || e.parentNode
                        } while (null !== e && 1 === e.nodeType);
                        return null
                    });
                    var lt = {
                        container: null,
                        html: "",
                        namespace: "",
                        url: {
                            hash: "",
                            href: "",
                            path: "",
                            port: null,
                            query: {}
                        }
                    };
                    return new(function() {
                        function t() {
                            this.version = u, this.schemaPage = lt, this.Logger = p, this.logger = new p("@barba/core"), this.plugins = [], this.hooks = V, this.dom = L, this.helpers = O, this.history = R, this.request = U, this.url = H
                        }
                        var i = t.prototype;
                        return i.use = function(t, e) {
                            var n = this.plugins;
                            n.indexOf(t) > -1 ? this.logger.warn("Plugin [" + t.name + "] already installed.") : "function" == typeof t.install ? (t.install(this, e), n.push(t)) : this.logger.warn("Plugin [" + t.name + '] has no "install" method.')
                        }, i.init = function(t) {
                            var e = void 0 === t ? {} : t,
                                i = e.transitions,
                                r = void 0 === i ? [] : i,
                                s = e.views,
                                o = void 0 === s ? [] : s,
                                a = e.schema,
                                l = void 0 === a ? C : a,
                                c = e.requestError,
                                u = e.timeout,
                                h = void 0 === u ? 2e3 : u,
                                d = e.cacheIgnore,
                                f = void 0 !== d && d,
                                m = e.prefetchIgnore,
                                g = void 0 !== m && m,
                                v = e.preventRunning,
                                y = void 0 !== v && v,
                                x = e.prevent,
                                _ = void 0 === x ? null : x,
                                b = e.debug,
                                w = e.logLevel;
                            if (p.setLevel(!0 === (void 0 !== b && b) ? "debug" : void 0 === w ? "off" : w), this.logger.info(this.version), Object.keys(l).forEach((function(t) {
                                    C[t] && (C[t] = l[t])
                                })), this.$ = c, this.timeout = h, this.cacheIgnore = f, this.prefetchIgnore = g, this.preventRunning = y, this._ = this.dom.getWrapper(), !this._) throw new Error("[@barba/core] No Barba wrapper found");
                            this._.setAttribute("aria-live", "polite"), this.q();
                            var M = this.data.current;
                            if (!M.container) throw new Error("[@barba/core] No Barba container found");
                            if (this.cache = new q(f), this.prevent = new it(g), this.transitions = new ot(r), this.views = new at(o), null !== _) {
                                if ("function" != typeof _) throw new Error("[@barba/core] Prevent should be a function");
                                this.prevent.add("preventCustom", _)
                            }
                            this.history.init(M.url.href, M.namespace), this.B = this.B.bind(this), this.U = this.U.bind(this), this.D = this.D.bind(this), this.F(), this.plugins.forEach((function(t) {
                                return t.init()
                            }));
                            var S = this.data;
                            S.trigger = "barba", S.next = S.current, S.current = n({}, this.schemaPage), this.hooks.do("ready", S), this.once(S), this.q()
                        }, i.destroy = function() {
                            this.q(), this.H(), this.history.clear(), this.hooks.clear(), this.plugins = []
                        }, i.force = function(t) {
                            window.location.assign(t)
                        }, i.go = function(t, e, n) {
                            var i;
                            if (void 0 === e && (e = "barba"), this.transitions.isRunning) this.force(t);
                            else if (!(i = "popstate" === e ? this.history.current && this.url.getPath(this.history.current.url) === this.url.getPath(t) : this.prevent.run("sameUrl", null, null, t)) || this.transitions.hasSelf) return e = this.history.change(t, e, n), n && (n.stopPropagation(), n.preventDefault()), this.page(t, e, i)
                        }, i.once = function(t) {
                            try {
                                var e = this;
                                return Promise.resolve(e.hooks.do("beforeEnter", t)).then((function() {
                                    function n() {
                                        return Promise.resolve(e.hooks.do("afterEnter", t)).then((function() {}))
                                    }
                                    var i = function() {
                                        if (e.transitions.hasOnce) {
                                            var n = e.transitions.get(t, {
                                                once: !0
                                            });
                                            return Promise.resolve(e.transitions.doOnce({
                                                transition: n,
                                                data: t
                                            })).then((function() {}))
                                        }
                                    }();
                                    return i && i.then ? i.then(n) : n()
                                }))
                            } catch (t) {
                                return Promise.reject(t)
                            }
                        }, i.page = function(t, e, i) {
                            try {
                                var r = function() {
                                        var t = s.data;
                                        return Promise.resolve(s.hooks.do("page", t)).then((function() {
                                            var e = l((function() {
                                                var e = s.transitions.get(t, {
                                                    once: !1,
                                                    self: i
                                                });
                                                return Promise.resolve(s.transitions.doPage({
                                                    data: t,
                                                    page: o,
                                                    transition: e,
                                                    wrapper: s._
                                                })).then((function() {
                                                    s.q()
                                                }))
                                            }), (function() {
                                                0 === p.getLevel() && s.force(t.current.url.href)
                                            }));
                                            if (e && e.then) return e.then((function() {}))
                                        }))
                                    },
                                    s = this;
                                s.data.next.url = n({
                                    href: t
                                }, s.url.parse(t)), s.data.trigger = e;
                                var o = s.cache.has(t) ? s.cache.update(t, {
                                        action: "click"
                                    }).request : s.cache.set(t, s.request(t, s.timeout, s.onRequestError.bind(s, e)), "click").request,
                                    a = function() {
                                        if (s.transitions.shouldWait) return Promise.resolve(P(o, s.data)).then((function() {}))
                                    }();
                                return Promise.resolve(a && a.then ? a.then(r) : r())
                            } catch (t) {
                                return Promise.reject(t)
                            }
                        }, i.onRequestError = function(t) {
                            this.transitions.isRunning = !1;
                            for (var e = arguments.length, n = new Array(e > 1 ? e - 1 : 0), i = 1; i < e; i++) n[i - 1] = arguments[i];
                            var r = n[0],
                                s = n[1],
                                o = this.cache.getAction(r);
                            return this.cache.delete(r), !(this.$ && !1 === this.$(t, o, r, s) || ("click" === o && this.force(r), 1))
                        }, i.prefetch = function(t) {
                            var e = this;
                            this.cache.has(t) || this.cache.set(t, this.request(t, this.timeout, this.onRequestError.bind(this, "barba")).catch((function(t) {
                                e.logger.error(t)
                            })), "prefetch")
                        }, i.F = function() {
                            !0 !== this.prefetchIgnore && (document.addEventListener("mouseover", this.B), document.addEventListener("touchstart", this.B)), document.addEventListener("click", this.U), window.addEventListener("popstate", this.D)
                        }, i.H = function() {
                            !0 !== this.prefetchIgnore && (document.removeEventListener("mouseover", this.B), document.removeEventListener("touchstart", this.B)), document.removeEventListener("click", this.U), window.removeEventListener("popstate", this.D)
                        }, i.B = function(t) {
                            var e = this,
                                n = this.I(t);
                            if (n) {
                                var i = this.dom.getHref(n);
                                this.prevent.checkHref(i) || this.cache.has(i) || this.cache.set(i, this.request(i, this.timeout, this.onRequestError.bind(this, n)).catch((function(t) {
                                    e.logger.error(t)
                                })), "enter")
                            }
                        }, i.U = function(t) {
                            var e = this.I(t);
                            if (e) return this.transitions.isRunning && this.preventRunning ? (t.preventDefault(), void t.stopPropagation()) : void this.go(this.dom.getHref(e), e, t)
                        }, i.D = function(t) {
                            this.go(this.url.getHref(), "popstate", t)
                        }, i.I = function(t) {
                            for (var e = t.target; e && !this.dom.getHref(e);) e = e.parentNode;
                            if (e && !this.prevent.checkLink(e, t, this.dom.getHref(e))) return e
                        }, i.q = function() {
                            var t = this.url.getHref(),
                                e = {
                                    container: this.dom.getContainer(),
                                    html: this.dom.getHtml(),
                                    namespace: this.dom.getNamespace(),
                                    url: n({
                                        href: t
                                    }, this.url.parse(t))
                                };
                            this.C = {
                                current: e,
                                next: n({}, this.schemaPage),
                                trigger: void 0
                            }, this.hooks.do("reset", this.data)
                        }, e(t, [{
                            key: "data",
                            get: function() {
                                return this.C
                            }
                        }, {
                            key: "wrapper",
                            get: function() {
                                return this._
                            }
                        }]), t
                    }())
                }()
            },
            15: function() {
                "serviceWorker" in navigator && window.addEventListener("load", (() => {
                    navigator.serviceWorker.register("/service-worker.js").then((t => {
                        console.log("SW registered: ", t)
                    })).catch((t => {
                        console.log("SW registration failed: ", t)
                    }))
                }))
            },
            921: function() {
                window.addEventListener("keypress", (function(t) {
                    1 === parseInt(t.key) && document.body.classList.toggle("grid-enable")
                }))
            }
        },
        e = {};

    function n(i) {
        if (e[i]) return e[i].exports;
        var r = e[i] = {
            exports: {}
        };
        return t[i].call(r.exports, r, r.exports, n), r.exports
    }
    n.n = function(t) {
            var e = t && t.__esModule ? function() {
                return t.default
            } : function() {
                return t
            };
            return n.d(e, {
                a: e
            }), e
        }, n.d = function(t, e) {
            for (var i in e) n.o(e, i) && !n.o(t, i) && Object.defineProperty(t, i, {
                enumerable: !0,
                get: e[i]
            })
        }, n.g = function() {
            if ("object" == typeof globalThis) return globalThis;
            try {
                return this || new Function("return this")()
            } catch (t) {
                if ("object" == typeof window) return window
            }
        }(), n.o = function(t, e) {
            return Object.prototype.hasOwnProperty.call(t, e)
        }, n.p = "/",
        function() {
            "use strict";

            function t(t) {
                if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                return t
            }

            function e(t, e) {
                t.prototype = Object.create(e.prototype), t.prototype.constructor = t, t.__proto__ = e
            }
            var i, r, s, o, a, l, c, u, h, d, p, f, m, g = {
                    autoSleep: 120,
                    force3D: "auto",
                    nullTargetWarn: 1,
                    units: {
                        lineHeight: ""
                    }
                },
                v = {
                    duration: .5,
                    overwrite: !1,
                    delay: 0
                },
                y = 1e8,
                x = 1e-8,
                _ = 2 * Math.PI,
                b = _ / 4,
                w = 0,
                M = Math.sqrt,
                S = Math.cos,
                E = Math.sin,
                D = function(t) {
                    return "string" == typeof t
                },
                T = function(t) {
                    return "function" == typeof t
                },
                A = function(t) {
                    return "number" == typeof t
                },
                C = function(t) {
                    return void 0 === t
                },
                L = function(t) {
                    return "object" == typeof t
                },
                R = function(t) {
                    return !1 !== t
                },
                P = function() {
                    return "undefined" != typeof window
                },
                F = function(t) {
                    return T(t) || D(t)
                },
                O = "function" == typeof ArrayBuffer && ArrayBuffer.isView || function() {},
                I = Array.isArray,
                N = /(?:-?\.?\d|\.)+/gi,
                B = /[-+=.]*\d+[.e\-+]*\d*[e\-+]*\d*/g,
                z = /[-+=.]*\d+[.e-]*\d*[a-z%]*/g,
                k = /[-+=.]*\d+\.?\d*(?:e-|e\+)?\d*/gi,
                H = /[+-]=-?[.\d]+/,
                U = /[#\-+.]*\b[a-z\d-=+%.]+/gi,
                G = /[\d.+\-=]+(?:e[-+]\d*)*/i,
                W = {},
                V = {},
                j = function(t) {
                    return (V = vt(t, W)) && nn
                },
                q = function(t, e) {
                    return console.warn("Invalid property", t, "set to", e, "Missing plugin? gsap.registerPlugin()")
                },
                X = function(t, e) {
                    return !e && console.warn(t)
                },
                Y = function(t, e) {
                    return t && (W[t] = e) && V && (V[t] = e) || W
                },
                Z = function() {
                    return 0
                },
                J = {},
                Q = [],
                K = {},
                $ = {},
                tt = {},
                et = 30,
                nt = [],
                it = "",
                rt = function(t) {
                    var e, n, i = t[0];
                    if (L(i) || T(i) || (t = [t]), !(e = (i._gsap || {}).harness)) {
                        for (n = nt.length; n-- && !nt[n].targetTest(i););
                        e = nt[n]
                    }
                    for (n = t.length; n--;) t[n] && (t[n]._gsap || (t[n]._gsap = new Te(t[n], e))) || t.splice(n, 1);
                    return t
                },
                st = function(t) {
                    return t._gsap || rt(qt(t))[0]._gsap
                },
                ot = function(t, e, n) {
                    return (n = t[e]) && T(n) ? t[e]() : C(n) && t.getAttribute && t.getAttribute(e) || n
                },
                at = function(t, e) {
                    return (t = t.split(",")).forEach(e) || t
                },
                lt = function(t) {
                    return Math.round(1e5 * t) / 1e5 || 0
                },
                ct = function(t, e) {
                    for (var n = e.length, i = 0; t.indexOf(e[i]) < 0 && ++i < n;);
                    return i < n
                },
                ut = function(t, e, n) {
                    var i, r = A(t[1]),
                        s = (r ? 2 : 1) + (e < 2 ? 0 : 1),
                        o = t[s];
                    if (r && (o.duration = t[1]), o.parent = n, e) {
                        for (i = o; n && !("immediateRender" in i);) i = n.vars.defaults || {}, n = R(n.vars.inherit) && n.parent;
                        o.immediateRender = R(i.immediateRender), e < 2 ? o.runBackwards = 1 : o.startAt = t[s - 1]
                    }
                    return o
                },
                ht = function() {
                    var t, e, n = Q.length,
                        i = Q.slice(0);
                    for (K = {}, Q.length = 0, t = 0; t < n; t++)(e = i[t]) && e._lazy && (e.render(e._lazy[0], e._lazy[1], !0)._lazy = 0)
                },
                dt = function(t, e, n, i) {
                    Q.length && ht(), t.render(e, n, i), Q.length && ht()
                },
                pt = function(t) {
                    var e = parseFloat(t);
                    return (e || 0 === e) && (t + "").match(U).length < 2 ? e : D(t) ? t.trim() : t
                },
                ft = function(t) {
                    return t
                },
                mt = function(t, e) {
                    for (var n in e) n in t || (t[n] = e[n]);
                    return t
                },
                gt = function(t, e) {
                    for (var n in e) n in t || "duration" === n || "ease" === n || (t[n] = e[n])
                },
                vt = function(t, e) {
                    for (var n in e) t[n] = e[n];
                    return t
                },
                yt = function t(e, n) {
                    for (var i in n) "__proto__" !== i && "constructor" !== i && "prototype" !== i && (e[i] = L(n[i]) ? t(e[i] || (e[i] = {}), n[i]) : n[i]);
                    return e
                },
                xt = function(t, e) {
                    var n, i = {};
                    for (n in t) n in e || (i[n] = t[n]);
                    return i
                },
                _t = function(t) {
                    var e = t.parent || r,
                        n = t.keyframes ? gt : mt;
                    if (R(t.inherit))
                        for (; e;) n(t, e.vars.defaults), e = e.parent || e._dp;
                    return t
                },
                bt = function(t, e, n, i) {
                    void 0 === n && (n = "_first"), void 0 === i && (i = "_last");
                    var r = e._prev,
                        s = e._next;
                    r ? r._next = s : t[n] === e && (t[n] = s), s ? s._prev = r : t[i] === e && (t[i] = r), e._next = e._prev = e.parent = null
                },
                wt = function(t, e) {
                    t.parent && (!e || t.parent.autoRemoveChildren) && t.parent.remove(t), t._act = 0
                },
                Mt = function(t, e) {
                    if (t && (!e || e._end > t._dur || e._start < 0))
                        for (var n = t; n;) n._dirty = 1, n = n.parent;
                    return t
                },
                St = function(t) {
                    for (var e = t.parent; e && e.parent;) e._dirty = 1, e.totalDuration(), e = e.parent;
                    return t
                },
                Et = function t(e) {
                    return !e || e._ts && t(e.parent)
                },
                Dt = function(t) {
                    return t._repeat ? Tt(t._tTime, t = t.duration() + t._rDelay) * t : 0
                },
                Tt = function(t, e) {
                    var n = Math.floor(t /= e);
                    return t && n === t ? n - 1 : n
                },
                At = function(t, e) {
                    return (t - e._start) * e._ts + (e._ts >= 0 ? 0 : e._dirty ? e.totalDuration() : e._tDur)
                },
                Ct = function(t) {
                    return t._end = lt(t._start + (t._tDur / Math.abs(t._ts || t._rts || x) || 0))
                },
                Lt = function(t, e) {
                    var n = t._dp;
                    return n && n.smoothChildTiming && t._ts && (t._start = lt(n._time - (t._ts > 0 ? e / t._ts : ((t._dirty ? t.totalDuration() : t._tDur) - e) / -t._ts)), Ct(t), n._dirty || Mt(n, t)), t
                },
                Rt = function(t, e) {
                    var n;
                    if ((e._time || e._initted && !e._dur) && (n = At(t.rawTime(), e), (!e._dur || Ut(0, e.totalDuration(), n) - e._tTime > x) && e.render(n, !0)), Mt(t, e)._dp && t._initted && t._time >= t._dur && t._ts) {
                        if (t._dur < t.duration())
                            for (n = t; n._dp;) n.rawTime() >= 0 && n.totalTime(n._tTime), n = n._dp;
                        t._zTime = -1e-8
                    }
                },
                Pt = function(t, e, n, i) {
                    return e.parent && wt(e), e._start = lt(n + e._delay), e._end = lt(e._start + (e.totalDuration() / Math.abs(e.timeScale()) || 0)),
                        function(t, e, n, i, r) {
                            void 0 === n && (n = "_first"), void 0 === i && (i = "_last");
                            var s, o = t[i];
                            if (r)
                                for (s = e[r]; o && o[r] > s;) o = o._prev;
                            o ? (e._next = o._next, o._next = e) : (e._next = t[n], t[n] = e), e._next ? e._next._prev = e : t[i] = e, e._prev = o, e.parent = e._dp = t
                        }(t, e, "_first", "_last", t._sort ? "_start" : 0), t._recent = e, i || Rt(t, e), t
                },
                Ft = function(t, e) {
                    return (W.ScrollTrigger || q("scrollTrigger", e)) && W.ScrollTrigger.create(e, t)
                },
                Ot = function(t, e, n, i) {
                    return Oe(t, e), t._initted ? !n && t._pt && (t._dur && !1 !== t.vars.lazy || !t._dur && t.vars.lazy) && c !== fe.frame ? (Q.push(t), t._lazy = [e, i], 1) : void 0 : 1
                },
                It = function t(e) {
                    var n = e.parent;
                    return n && n._ts && n._initted && !n._lock && (n.rawTime() < 0 || t(n))
                },
                Nt = function(t, e, n, i) {
                    var r = t._repeat,
                        s = lt(e) || 0,
                        o = t._tTime / t._tDur;
                    return o && !i && (t._time *= s / t._dur), t._dur = s, t._tDur = r ? r < 0 ? 1e10 : lt(s * (r + 1) + t._rDelay * r) : s, o && !i ? Lt(t, t._tTime = t._tDur * o) : t.parent && Ct(t), n || Mt(t.parent, t), t
                },
                Bt = function(t) {
                    return t instanceof Ce ? Mt(t) : Nt(t, t._dur)
                },
                zt = {
                    _start: 0,
                    endTime: Z
                },
                kt = function t(e, n) {
                    var i, r, s = e.labels,
                        o = e._recent || zt,
                        a = e.duration() >= y ? o.endTime(!1) : e._dur;
                    return D(n) && (isNaN(n) || n in s) ? "<" === (i = n.charAt(0)) || ">" === i ? ("<" === i ? o._start : o.endTime(o._repeat >= 0)) + (parseFloat(n.substr(1)) || 0) : (i = n.indexOf("=")) < 0 ? (n in s || (s[n] = a), s[n]) : (r = +(n.charAt(i - 1) + n.substr(i + 1)), i > 1 ? t(e, n.substr(0, i - 1)) + r : a + r) : null == n ? a : +n
                },
                Ht = function(t, e) {
                    return t || 0 === t ? e(t) : e
                },
                Ut = function(t, e, n) {
                    return n < t ? t : n > e ? e : n
                },
                Gt = function(t) {
                    if ("string" != typeof t) return "";
                    var e = G.exec(t);
                    return e ? t.substr(e.index + e[0].length) : ""
                },
                Wt = [].slice,
                Vt = function(t, e) {
                    return t && L(t) && "length" in t && (!e && !t.length || t.length - 1 in t && L(t[0])) && !t.nodeType && t !== s
                },
                jt = function(t, e, n) {
                    return void 0 === n && (n = []), t.forEach((function(t) {
                        var i;
                        return D(t) && !e || Vt(t, 1) ? (i = n).push.apply(i, qt(t)) : n.push(t)
                    })) || n
                },
                qt = function(t, e) {
                    return !D(t) || e || !o && me() ? I(t) ? jt(t, e) : Vt(t) ? Wt.call(t, 0) : t ? [t] : [] : Wt.call(a.querySelectorAll(t), 0)
                },
                Xt = function(t) {
                    return t.sort((function() {
                        return .5 - Math.random()
                    }))
                },
                Yt = function(t) {
                    if (T(t)) return t;
                    var e = L(t) ? t : {
                            each: t
                        },
                        n = we(e.ease),
                        i = e.from || 0,
                        r = parseFloat(e.base) || 0,
                        s = {},
                        o = i > 0 && i < 1,
                        a = isNaN(i) || o,
                        l = e.axis,
                        c = i,
                        u = i;
                    return D(i) ? c = u = {
                            center: .5,
                            edges: .5,
                            end: 1
                        }[i] || 0 : !o && a && (c = i[0], u = i[1]),
                        function(t, o, h) {
                            var d, p, f, m, g, v, x, _, b, w = (h || e).length,
                                S = s[w];
                            if (!S) {
                                if (!(b = "auto" === e.grid ? 0 : (e.grid || [1, y])[1])) {
                                    for (x = -y; x < (x = h[b++].getBoundingClientRect().left) && b < w;);
                                    b--
                                }
                                for (S = s[w] = [], d = a ? Math.min(b, w) * c - .5 : i % b, p = a ? w * u / b - .5 : i / b | 0, x = 0, _ = y, v = 0; v < w; v++) f = v % b - d, m = p - (v / b | 0), S[v] = g = l ? Math.abs("y" === l ? m : f) : M(f * f + m * m), g > x && (x = g), g < _ && (_ = g);
                                "random" === i && Xt(S), S.max = x - _, S.min = _, S.v = w = (parseFloat(e.amount) || parseFloat(e.each) * (b > w ? w - 1 : l ? "y" === l ? w / b : b : Math.max(b, w / b)) || 0) * ("edges" === i ? -1 : 1), S.b = w < 0 ? r - w : r, S.u = Gt(e.amount || e.each) || 0, n = n && w < 0 ? _e(n) : n
                            }
                            return w = (S[t] - S.min) / S.max || 0, lt(S.b + (n ? n(w) : w) * S.v) + S.u
                        }
                },
                Zt = function(t) {
                    var e = t < 1 ? Math.pow(10, (t + "").length - 2) : 1;
                    return function(n) {
                        var i = Math.round(parseFloat(n) / t) * t * e;
                        return (i - i % 1) / e + (A(n) ? 0 : Gt(n))
                    }
                },
                Jt = function(t, e) {
                    var n, i, r = I(t);
                    return !r && L(t) && (n = r = t.radius || y, t.values ? (t = qt(t.values), (i = !A(t[0])) && (n *= n)) : t = Zt(t.increment)), Ht(e, r ? T(t) ? function(e) {
                        return i = t(e), Math.abs(i - e) <= n ? i : e
                    } : function(e) {
                        for (var r, s, o = parseFloat(i ? e.x : e), a = parseFloat(i ? e.y : 0), l = y, c = 0, u = t.length; u--;)(r = i ? (r = t[u].x - o) * r + (s = t[u].y - a) * s : Math.abs(t[u] - o)) < l && (l = r, c = u);
                        return c = !n || l <= n ? t[c] : e, i || c === e || A(e) ? c : c + Gt(e)
                    } : Zt(t))
                },
                Qt = function(t, e, n, i) {
                    return Ht(I(t) ? !e : !0 === n ? !!(n = 0) : !i, (function() {
                        return I(t) ? t[~~(Math.random() * t.length)] : (n = n || 1e-5) && (i = n < 1 ? Math.pow(10, (n + "").length - 2) : 1) && Math.floor(Math.round((t - n / 2 + Math.random() * (e - t + .99 * n)) / n) * n * i) / i
                    }))
                },
                Kt = function(t, e, n) {
                    return Ht(n, (function(n) {
                        return t[~~e(n)]
                    }))
                },
                $t = function(t) {
                    for (var e, n, i, r, s = 0, o = ""; ~(e = t.indexOf("random(", s));) i = t.indexOf(")", e), r = "[" === t.charAt(e + 7), n = t.substr(e + 7, i - e - 7).match(r ? U : N), o += t.substr(s, e - s) + Qt(r ? n : +n[0], r ? 0 : +n[1], +n[2] || 1e-5), s = i + 1;
                    return o + t.substr(s, t.length - s)
                },
                te = function(t, e, n, i, r) {
                    var s = e - t,
                        o = i - n;
                    return Ht(r, (function(e) {
                        return n + ((e - t) / s * o || 0)
                    }))
                },
                ee = function(t, e, n) {
                    var i, r, s, o = t.labels,
                        a = y;
                    for (i in o)(r = o[i] - e) < 0 == !!n && r && a > (r = Math.abs(r)) && (s = i, a = r);
                    return s
                },
                ne = function(t, e, n) {
                    var i, r, s = t.vars,
                        o = s[e];
                    if (o) return i = s[e + "Params"], r = s.callbackScope || t, n && Q.length && ht(), i ? o.apply(r, i) : o.call(r)
                },
                ie = function(t) {
                    return wt(t), t.progress() < 1 && ne(t, "onInterrupt"), t
                },
                re = function(t) {
                    var e = (t = !t.name && t.default || t).name,
                        n = T(t),
                        i = e && !n && t.init ? function() {
                            this._props = []
                        } : t,
                        r = {
                            init: Z,
                            render: Xe,
                            add: Pe,
                            kill: Ze,
                            modifier: Ye,
                            rawVars: 0
                        },
                        s = {
                            targetTest: 0,
                            get: 0,
                            getSetter: We,
                            aliases: {},
                            register: 0
                        };
                    if (me(), t !== i) {
                        if ($[e]) return;
                        mt(i, mt(xt(t, r), s)), vt(i.prototype, vt(r, xt(t, s))), $[i.prop = e] = i, t.targetTest && (nt.push(i), J[e] = 1), e = ("css" === e ? "CSS" : e.charAt(0).toUpperCase() + e.substr(1)) + "Plugin"
                    }
                    Y(e, i), t.register && t.register(nn, i, Ke)
                },
                se = 255,
                oe = {
                    aqua: [0, se, se],
                    lime: [0, se, 0],
                    silver: [192, 192, 192],
                    black: [0, 0, 0],
                    maroon: [128, 0, 0],
                    teal: [0, 128, 128],
                    blue: [0, 0, se],
                    navy: [0, 0, 128],
                    white: [se, se, se],
                    olive: [128, 128, 0],
                    yellow: [se, se, 0],
                    orange: [se, 165, 0],
                    gray: [128, 128, 128],
                    purple: [128, 0, 128],
                    green: [0, 128, 0],
                    red: [se, 0, 0],
                    pink: [se, 192, 203],
                    cyan: [0, se, se],
                    transparent: [se, se, se, 0]
                },
                ae = function(t, e, n) {
                    return (6 * (t = t < 0 ? t + 1 : t > 1 ? t - 1 : t) < 1 ? e + (n - e) * t * 6 : t < .5 ? n : 3 * t < 2 ? e + (n - e) * (2 / 3 - t) * 6 : e) * se + .5 | 0
                },
                le = function(t, e, n) {
                    var i, r, s, o, a, l, c, u, h, d, p = t ? A(t) ? [t >> 16, t >> 8 & se, t & se] : 0 : oe.black;
                    if (!p) {
                        if ("," === t.substr(-1) && (t = t.substr(0, t.length - 1)), oe[t]) p = oe[t];
                        else if ("#" === t.charAt(0)) {
                            if (t.length < 6 && (i = t.charAt(1), r = t.charAt(2), s = t.charAt(3), t = "#" + i + i + r + r + s + s + (5 === t.length ? t.charAt(4) + t.charAt(4) : "")), 9 === t.length) return [(p = parseInt(t.substr(1, 6), 16)) >> 16, p >> 8 & se, p & se, parseInt(t.substr(7), 16) / 255];
                            p = [(t = parseInt(t.substr(1), 16)) >> 16, t >> 8 & se, t & se]
                        } else if ("hsl" === t.substr(0, 3))
                            if (p = d = t.match(N), e) {
                                if (~t.indexOf("=")) return p = t.match(B), n && p.length < 4 && (p[3] = 1), p
                            } else o = +p[0] % 360 / 360, a = +p[1] / 100, i = 2 * (l = +p[2] / 100) - (r = l <= .5 ? l * (a + 1) : l + a - l * a), p.length > 3 && (p[3] *= 1), p[0] = ae(o + 1 / 3, i, r), p[1] = ae(o, i, r), p[2] = ae(o - 1 / 3, i, r);
                        else p = t.match(N) || oe.transparent;
                        p = p.map(Number)
                    }
                    return e && !d && (i = p[0] / se, r = p[1] / se, s = p[2] / se, l = ((c = Math.max(i, r, s)) + (u = Math.min(i, r, s))) / 2, c === u ? o = a = 0 : (h = c - u, a = l > .5 ? h / (2 - c - u) : h / (c + u), o = c === i ? (r - s) / h + (r < s ? 6 : 0) : c === r ? (s - i) / h + 2 : (i - r) / h + 4, o *= 60), p[0] = ~~(o + .5), p[1] = ~~(100 * a + .5), p[2] = ~~(100 * l + .5)), n && p.length < 4 && (p[3] = 1), p
                },
                ce = function(t) {
                    var e = [],
                        n = [],
                        i = -1;
                    return t.split(he).forEach((function(t) {
                        var r = t.match(z) || [];
                        e.push.apply(e, r), n.push(i += r.length + 1)
                    })), e.c = n, e
                },
                ue = function(t, e, n) {
                    var i, r, s, o, a = "",
                        l = (t + a).match(he),
                        c = e ? "hsla(" : "rgba(",
                        u = 0;
                    if (!l) return t;
                    if (l = l.map((function(t) {
                            return (t = le(t, e, 1)) && c + (e ? t[0] + "," + t[1] + "%," + t[2] + "%," + t[3] : t.join(",")) + ")"
                        })), n && (s = ce(t), (i = n.c).join(a) !== s.c.join(a)))
                        for (o = (r = t.replace(he, "1").split(z)).length - 1; u < o; u++) a += r[u] + (~i.indexOf(u) ? l.shift() || c + "0,0,0,0)" : (s.length ? s : l.length ? l : n).shift());
                    if (!r)
                        for (o = (r = t.split(he)).length - 1; u < o; u++) a += r[u] + l[u];
                    return a + r[o]
                },
                he = function() {
                    var t, e = "(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#(?:[0-9a-f]{3,4}){1,2}\\b";
                    for (t in oe) e += "|" + t + "\\b";
                    return new RegExp(e + ")", "gi")
                }(),
                de = /hsl[a]?\(/,
                pe = function(t) {
                    var e, n = t.join(" ");
                    if (he.lastIndex = 0, he.test(n)) return e = de.test(n), t[1] = ue(t[1], e), t[0] = ue(t[0], e, ce(t[1])), !0
                },
                fe = function() {
                    var t, e, n, i, r, c, u = Date.now,
                        d = 500,
                        p = 33,
                        f = u(),
                        m = f,
                        g = 1e3 / 240,
                        v = g,
                        y = [],
                        x = function n(s) {
                            var o, a, l, h, x = u() - m,
                                _ = !0 === s;
                            if (x > d && (f += x - p), ((o = (l = (m += x) - f) - v) > 0 || _) && (h = ++i.frame, r = l - 1e3 * i.time, i.time = l /= 1e3, v += o + (o >= g ? 4 : g - o), a = 1), _ || (t = e(n)), a)
                                for (c = 0; c < y.length; c++) y[c](l, r, h, s)
                        };
                    return i = {
                        time: 0,
                        frame: 0,
                        tick: function() {
                            x(!0)
                        },
                        deltaRatio: function(t) {
                            return r / (1e3 / (t || 60))
                        },
                        wake: function() {
                            l && (!o && P() && (s = o = window, a = s.document || {}, W.gsap = nn, (s.gsapVersions || (s.gsapVersions = [])).push(nn.version), j(V || s.GreenSockGlobals || !s.gsap && s || {}), n = s.requestAnimationFrame), t && i.sleep(), e = n || function(t) {
                                return setTimeout(t, v - 1e3 * i.time + 1 | 0)
                            }, h = 1, x(2))
                        },
                        sleep: function() {
                            (n ? s.cancelAnimationFrame : clearTimeout)(t), h = 0, e = Z
                        },
                        lagSmoothing: function(t, e) {
                            d = t || 1e8, p = Math.min(e, d, 0)
                        },
                        fps: function(t) {
                            g = 1e3 / (t || 240), v = 1e3 * i.time + g
                        },
                        add: function(t) {
                            y.indexOf(t) < 0 && y.push(t), me()
                        },
                        remove: function(t) {
                            var e;
                            ~(e = y.indexOf(t)) && y.splice(e, 1) && c >= e && c--
                        },
                        _listeners: y
                    }
                }(),
                me = function() {
                    return !h && fe.wake()
                },
                ge = {},
                ve = /^[\d.\-M][\d.\-,\s]/,
                ye = /["']/g,
                xe = function(t) {
                    for (var e, n, i, r = {}, s = t.substr(1, t.length - 3).split(":"), o = s[0], a = 1, l = s.length; a < l; a++) n = s[a], e = a !== l - 1 ? n.lastIndexOf(",") : n.length, i = n.substr(0, e), r[o] = isNaN(i) ? i.replace(ye, "").trim() : +i, o = n.substr(e + 1).trim();
                    return r
                },
                _e = function(t) {
                    return function(e) {
                        return 1 - t(1 - e)
                    }
                },
                be = function t(e, n) {
                    for (var i, r = e._first; r;) r instanceof Ce ? t(r, n) : !r.vars.yoyoEase || r._yoyo && r._repeat || r._yoyo === n || (r.timeline ? t(r.timeline, n) : (i = r._ease, r._ease = r._yEase, r._yEase = i, r._yoyo = n)), r = r._next
                },
                we = function(t, e) {
                    return t && (T(t) ? t : ge[t] || function(t) {
                        var e, n, i, r, s = (t + "").split("("),
                            o = ge[s[0]];
                        return o && s.length > 1 && o.config ? o.config.apply(null, ~t.indexOf("{") ? [xe(s[1])] : (e = t, n = e.indexOf("(") + 1, i = e.indexOf(")"), r = e.indexOf("(", n), e.substring(n, ~r && r < i ? e.indexOf(")", i + 1) : i)).split(",").map(pt)) : ge._CE && ve.test(t) ? ge._CE("", t) : o
                    }(t)) || e
                },
                Me = function(t, e, n, i) {
                    void 0 === n && (n = function(t) {
                        return 1 - e(1 - t)
                    }), void 0 === i && (i = function(t) {
                        return t < .5 ? e(2 * t) / 2 : 1 - e(2 * (1 - t)) / 2
                    });
                    var r, s = {
                        easeIn: e,
                        easeOut: n,
                        easeInOut: i
                    };
                    return at(t, (function(t) {
                        for (var e in ge[t] = W[t] = s, ge[r = t.toLowerCase()] = n, s) ge[r + ("easeIn" === e ? ".in" : "easeOut" === e ? ".out" : ".inOut")] = ge[t + "." + e] = s[e]
                    })), s
                },
                Se = function(t) {
                    return function(e) {
                        return e < .5 ? (1 - t(1 - 2 * e)) / 2 : .5 + t(2 * (e - .5)) / 2
                    }
                },
                Ee = function t(e, n, i) {
                    var r = n >= 1 ? n : 1,
                        s = (i || (e ? .3 : .45)) / (n < 1 ? n : 1),
                        o = s / _ * (Math.asin(1 / r) || 0),
                        a = function(t) {
                            return 1 === t ? 1 : r * Math.pow(2, -10 * t) * E((t - o) * s) + 1
                        },
                        l = "out" === e ? a : "in" === e ? function(t) {
                            return 1 - a(1 - t)
                        } : Se(a);
                    return s = _ / s, l.config = function(n, i) {
                        return t(e, n, i)
                    }, l
                },
                De = function t(e, n) {
                    void 0 === n && (n = 1.70158);
                    var i = function(t) {
                            return t ? --t * t * ((n + 1) * t + n) + 1 : 0
                        },
                        r = "out" === e ? i : "in" === e ? function(t) {
                            return 1 - i(1 - t)
                        } : Se(i);
                    return r.config = function(n) {
                        return t(e, n)
                    }, r
                };
            at("Linear,Quad,Cubic,Quart,Quint,Strong", (function(t, e) {
                var n = e < 5 ? e + 1 : e;
                Me(t + ",Power" + (n - 1), e ? function(t) {
                    return Math.pow(t, n)
                } : function(t) {
                    return t
                }, (function(t) {
                    return 1 - Math.pow(1 - t, n)
                }), (function(t) {
                    return t < .5 ? Math.pow(2 * t, n) / 2 : 1 - Math.pow(2 * (1 - t), n) / 2
                }))
            })), ge.Linear.easeNone = ge.none = ge.Linear.easeIn, Me("Elastic", Ee("in"), Ee("out"), Ee()), d = 7.5625, f = 1 / (p = 2.75), Me("Bounce", (function(t) {
                return 1 - m(1 - t)
            }), m = function(t) {
                return t < f ? d * t * t : t < .7272727272727273 ? d * Math.pow(t - 1.5 / p, 2) + .75 : t < .9090909090909092 ? d * (t -= 2.25 / p) * t + .9375 : d * Math.pow(t - 2.625 / p, 2) + .984375
            }), Me("Expo", (function(t) {
                return t ? Math.pow(2, 10 * (t - 1)) : 0
            })), Me("Circ", (function(t) {
                return -(M(1 - t * t) - 1)
            })), Me("Sine", (function(t) {
                return 1 === t ? 1 : 1 - S(t * b)
            })), Me("Back", De("in"), De("out"), De()), ge.SteppedEase = ge.steps = W.SteppedEase = {
                config: function(t, e) {
                    void 0 === t && (t = 1);
                    var n = 1 / t,
                        i = t + (e ? 0 : 1),
                        r = e ? 1 : 0;
                    return function(t) {
                        return ((i * Ut(0, .99999999, t) | 0) + r) * n
                    }
                }
            }, v.ease = ge["quad.out"], at("onComplete,onUpdate,onStart,onRepeat,onReverseComplete,onInterrupt", (function(t) {
                return it += t + "," + t + "Params,"
            }));
            var Te = function(t, e) {
                    this.id = w++, t._gsap = this, this.target = t, this.harness = e, this.get = e ? e.get : ot, this.set = e ? e.getSetter : We
                },
                Ae = function() {
                    function t(t, e) {
                        var n = t.parent || r;
                        this.vars = t, this._delay = +t.delay || 0, (this._repeat = t.repeat === 1 / 0 ? -2 : t.repeat || 0) && (this._rDelay = t.repeatDelay || 0, this._yoyo = !!t.yoyo || !!t.yoyoEase), this._ts = 1, Nt(this, +t.duration, 1, 1), this.data = t.data, h || fe.wake(), n && Pt(n, this, e || 0 === e ? e : n._time, 1), t.reversed && this.reverse(), t.paused && this.paused(!0)
                    }
                    var e = t.prototype;
                    return e.delay = function(t) {
                        return t || 0 === t ? (this.parent && this.parent.smoothChildTiming && this.startTime(this._start + t - this._delay), this._delay = t, this) : this._delay
                    }, e.duration = function(t) {
                        return arguments.length ? this.totalDuration(this._repeat > 0 ? t + (t + this._rDelay) * this._repeat : t) : this.totalDuration() && this._dur
                    }, e.totalDuration = function(t) {
                        return arguments.length ? (this._dirty = 0, Nt(this, this._repeat < 0 ? t : (t - this._repeat * this._rDelay) / (this._repeat + 1))) : this._tDur
                    }, e.totalTime = function(t, e) {
                        if (me(), !arguments.length) return this._tTime;
                        var n = this._dp;
                        if (n && n.smoothChildTiming && this._ts) {
                            for (Lt(this, t), !n._dp || n.parent || Rt(n, this); n.parent;) n.parent._time !== n._start + (n._ts >= 0 ? n._tTime / n._ts : (n.totalDuration() - n._tTime) / -n._ts) && n.totalTime(n._tTime, !0), n = n.parent;
                            !this.parent && this._dp.autoRemoveChildren && (this._ts > 0 && t < this._tDur || this._ts < 0 && t > 0 || !this._tDur && !t) && Pt(this._dp, this, this._start - this._delay)
                        }
                        return (this._tTime !== t || !this._dur && !e || this._initted && Math.abs(this._zTime) === x || !t && !this._initted && (this.add || this._ptLookup)) && (this._ts || (this._pTime = t), dt(this, t, e)), this
                    }, e.time = function(t, e) {
                        return arguments.length ? this.totalTime(Math.min(this.totalDuration(), t + Dt(this)) % this._dur || (t ? this._dur : 0), e) : this._time
                    }, e.totalProgress = function(t, e) {
                        return arguments.length ? this.totalTime(this.totalDuration() * t, e) : this.totalDuration() ? Math.min(1, this._tTime / this._tDur) : this.ratio
                    }, e.progress = function(t, e) {
                        return arguments.length ? this.totalTime(this.duration() * (!this._yoyo || 1 & this.iteration() ? t : 1 - t) + Dt(this), e) : this.duration() ? Math.min(1, this._time / this._dur) : this.ratio
                    }, e.iteration = function(t, e) {
                        var n = this.duration() + this._rDelay;
                        return arguments.length ? this.totalTime(this._time + (t - 1) * n, e) : this._repeat ? Tt(this._tTime, n) + 1 : 1
                    }, e.timeScale = function(t) {
                        if (!arguments.length) return -1e-8 === this._rts ? 0 : this._rts;
                        if (this._rts === t) return this;
                        var e = this.parent && this._ts ? At(this.parent._time, this) : this._tTime;
                        return this._rts = +t || 0, this._ts = this._ps || -1e-8 === t ? 0 : this._rts, St(this.totalTime(Ut(-this._delay, this._tDur, e), !0))
                    }, e.paused = function(t) {
                        return arguments.length ? (this._ps !== t && (this._ps = t, t ? (this._pTime = this._tTime || Math.max(-this._delay, this.rawTime()), this._ts = this._act = 0) : (me(), this._ts = this._rts, this.totalTime(this.parent && !this.parent.smoothChildTiming ? this.rawTime() : this._tTime || this._pTime, 1 === this.progress() && (this._tTime -= x) && Math.abs(this._zTime) !== x))), this) : this._ps
                    }, e.startTime = function(t) {
                        if (arguments.length) {
                            this._start = t;
                            var e = this.parent || this._dp;
                            return e && (e._sort || !this.parent) && Pt(e, this, t - this._delay), this
                        }
                        return this._start
                    }, e.endTime = function(t) {
                        return this._start + (R(t) ? this.totalDuration() : this.duration()) / Math.abs(this._ts)
                    }, e.rawTime = function(t) {
                        var e = this.parent || this._dp;
                        return e ? t && (!this._ts || this._repeat && this._time && this.totalProgress() < 1) ? this._tTime % (this._dur + this._rDelay) : this._ts ? At(e.rawTime(t), this) : this._tTime : this._tTime
                    }, e.globalTime = function(t) {
                        for (var e = this, n = arguments.length ? t : e.rawTime(); e;) n = e._start + n / (e._ts || 1), e = e._dp;
                        return n
                    }, e.repeat = function(t) {
                        return arguments.length ? (this._repeat = t === 1 / 0 ? -2 : t, Bt(this)) : -2 === this._repeat ? 1 / 0 : this._repeat
                    }, e.repeatDelay = function(t) {
                        return arguments.length ? (this._rDelay = t, Bt(this)) : this._rDelay
                    }, e.yoyo = function(t) {
                        return arguments.length ? (this._yoyo = t, this) : this._yoyo
                    }, e.seek = function(t, e) {
                        return this.totalTime(kt(this, t), R(e))
                    }, e.restart = function(t, e) {
                        return this.play().totalTime(t ? -this._delay : 0, R(e))
                    }, e.play = function(t, e) {
                        return null != t && this.seek(t, e), this.reversed(!1).paused(!1)
                    }, e.reverse = function(t, e) {
                        return null != t && this.seek(t || this.totalDuration(), e), this.reversed(!0).paused(!1)
                    }, e.pause = function(t, e) {
                        return null != t && this.seek(t, e), this.paused(!0)
                    }, e.resume = function() {
                        return this.paused(!1)
                    }, e.reversed = function(t) {
                        return arguments.length ? (!!t !== this.reversed() && this.timeScale(-this._rts || (t ? -1e-8 : 0)), this) : this._rts < 0
                    }, e.invalidate = function() {
                        return this._initted = this._act = 0, this._zTime = -1e-8, this
                    }, e.isActive = function() {
                        var t, e = this.parent || this._dp,
                            n = this._start;
                        return !(e && !(this._ts && this._initted && e.isActive() && (t = e.rawTime(!0)) >= n && t < this.endTime(!0) - x))
                    }, e.eventCallback = function(t, e, n) {
                        var i = this.vars;
                        return arguments.length > 1 ? (e ? (i[t] = e, n && (i[t + "Params"] = n), "onUpdate" === t && (this._onUpdate = e)) : delete i[t], this) : i[t]
                    }, e.then = function(t) {
                        var e = this;
                        return new Promise((function(n) {
                            var i = T(t) ? t : ft,
                                r = function() {
                                    var t = e.then;
                                    e.then = null, T(i) && (i = i(e)) && (i.then || i === e) && (e.then = t), n(i), e.then = t
                                };
                            e._initted && 1 === e.totalProgress() && e._ts >= 0 || !e._tTime && e._ts < 0 ? r() : e._prom = r
                        }))
                    }, e.kill = function() {
                        ie(this)
                    }, t
                }();
            mt(Ae.prototype, {
                _time: 0,
                _start: 0,
                _end: 0,
                _tTime: 0,
                _tDur: 0,
                _dirty: 0,
                _repeat: 0,
                _yoyo: !1,
                parent: null,
                _initted: !1,
                _rDelay: 0,
                _ts: 1,
                _dp: 0,
                ratio: 0,
                _zTime: -1e-8,
                _prom: 0,
                _ps: !1,
                _rts: 1
            });
            var Ce = function(n) {
                function i(e, i) {
                    var r;
                    return void 0 === e && (e = {}), (r = n.call(this, e, i) || this).labels = {}, r.smoothChildTiming = !!e.smoothChildTiming, r.autoRemoveChildren = !!e.autoRemoveChildren, r._sort = R(e.sortChildren), r.parent && Rt(r.parent, t(r)), e.scrollTrigger && Ft(t(r), e.scrollTrigger), r
                }
                e(i, n);
                var s = i.prototype;
                return s.to = function(t, e, n) {
                    return new ze(t, ut(arguments, 0, this), kt(this, A(e) ? arguments[3] : n)), this
                }, s.from = function(t, e, n) {
                    return new ze(t, ut(arguments, 1, this), kt(this, A(e) ? arguments[3] : n)), this
                }, s.fromTo = function(t, e, n, i) {
                    return new ze(t, ut(arguments, 2, this), kt(this, A(e) ? arguments[4] : i)), this
                }, s.set = function(t, e, n) {
                    return e.duration = 0, e.parent = this, _t(e).repeatDelay || (e.repeat = 0), e.immediateRender = !!e.immediateRender, new ze(t, e, kt(this, n), 1), this
                }, s.call = function(t, e, n) {
                    return Pt(this, ze.delayedCall(0, t, e), kt(this, n))
                }, s.staggerTo = function(t, e, n, i, r, s, o) {
                    return n.duration = e, n.stagger = n.stagger || i, n.onComplete = s, n.onCompleteParams = o, n.parent = this, new ze(t, n, kt(this, r)), this
                }, s.staggerFrom = function(t, e, n, i, r, s, o) {
                    return n.runBackwards = 1, _t(n).immediateRender = R(n.immediateRender), this.staggerTo(t, e, n, i, r, s, o)
                }, s.staggerFromTo = function(t, e, n, i, r, s, o, a) {
                    return i.startAt = n, _t(i).immediateRender = R(i.immediateRender), this.staggerTo(t, e, i, r, s, o, a)
                }, s.render = function(t, e, n) {
                    var i, s, o, a, l, c, u, h, d, p, f, m, g = this._time,
                        v = this._dirty ? this.totalDuration() : this._tDur,
                        y = this._dur,
                        _ = this !== r && t > v - x && t >= 0 ? v : t < x ? 0 : t,
                        b = this._zTime < 0 != t < 0 && (this._initted || !y);
                    if (_ !== this._tTime || n || b) {
                        if (g !== this._time && y && (_ += this._time - g, t += this._time - g), i = _, d = this._start, c = !(h = this._ts), b && (y || (g = this._zTime), (t || !e) && (this._zTime = t)), this._repeat) {
                            if (f = this._yoyo, l = y + this._rDelay, this._repeat < -1 && t < 0) return this.totalTime(100 * l + t, e, n);
                            if (i = lt(_ % l), _ === v ? (a = this._repeat, i = y) : ((a = ~~(_ / l)) && a === _ / l && (i = y, a--), i > y && (i = y)), p = Tt(this._tTime, l), !g && this._tTime && p !== a && (p = a), f && 1 & a && (i = y - i, m = 1), a !== p && !this._lock) {
                                var w = f && 1 & p,
                                    M = w === (f && 1 & a);
                                if (a < p && (w = !w), g = w ? 0 : y, this._lock = 1, this.render(g || (m ? 0 : lt(a * l)), e, !y)._lock = 0, !e && this.parent && ne(this, "onRepeat"), this.vars.repeatRefresh && !m && (this.invalidate()._lock = 1), g !== this._time || c !== !this._ts) return this;
                                if (y = this._dur, v = this._tDur, M && (this._lock = 2, g = w ? y : -1e-4, this.render(g, !0), this.vars.repeatRefresh && !m && this.invalidate()), this._lock = 0, !this._ts && !c) return this;
                                be(this, m)
                            }
                        }
                        if (this._hasPause && !this._forcing && this._lock < 2 && (u = function(t, e, n) {
                                var i;
                                if (n > e)
                                    for (i = t._first; i && i._start <= n;) {
                                        if (!i._dur && "isPause" === i.data && i._start > e) return i;
                                        i = i._next
                                    } else
                                        for (i = t._last; i && i._start >= n;) {
                                            if (!i._dur && "isPause" === i.data && i._start < e) return i;
                                            i = i._prev
                                        }
                            }(this, lt(g), lt(i))) && (_ -= i - (i = u._start)), this._tTime = _, this._time = i, this._act = !h, this._initted || (this._onUpdate = this.vars.onUpdate, this._initted = 1, this._zTime = t, g = 0), !g && (i || !y && t >= 0) && !e && ne(this, "onStart"), i >= g && t >= 0)
                            for (s = this._first; s;) {
                                if (o = s._next, (s._act || i >= s._start) && s._ts && u !== s) {
                                    if (s.parent !== this) return this.render(t, e, n);
                                    if (s.render(s._ts > 0 ? (i - s._start) * s._ts : (s._dirty ? s.totalDuration() : s._tDur) + (i - s._start) * s._ts, e, n), i !== this._time || !this._ts && !c) {
                                        u = 0, o && (_ += this._zTime = -1e-8);
                                        break
                                    }
                                }
                                s = o
                            } else {
                                s = this._last;
                                for (var S = t < 0 ? t : i; s;) {
                                    if (o = s._prev, (s._act || S <= s._end) && s._ts && u !== s) {
                                        if (s.parent !== this) return this.render(t, e, n);
                                        if (s.render(s._ts > 0 ? (S - s._start) * s._ts : (s._dirty ? s.totalDuration() : s._tDur) + (S - s._start) * s._ts, e, n), i !== this._time || !this._ts && !c) {
                                            u = 0, o && (_ += this._zTime = S ? -1e-8 : x);
                                            break
                                        }
                                    }
                                    s = o
                                }
                            }
                        if (u && !e && (this.pause(), u.render(i >= g ? 0 : -1e-8)._zTime = i >= g ? 1 : -1, this._ts)) return this._start = d, Ct(this), this.render(t, e, n);
                        this._onUpdate && !e && ne(this, "onUpdate", !0), (_ === v && v >= this.totalDuration() || !_ && g) && (d !== this._start && Math.abs(h) === Math.abs(this._ts) || this._lock || ((t || !y) && (_ === v && this._ts > 0 || !_ && this._ts < 0) && wt(this, 1), e || t < 0 && !g || !_ && !g || (ne(this, _ === v ? "onComplete" : "onReverseComplete", !0), this._prom && !(_ < v && this.timeScale() > 0) && this._prom())))
                    }
                    return this
                }, s.add = function(t, e) {
                    var n = this;
                    if (A(e) || (e = kt(this, e)), !(t instanceof Ae)) {
                        if (I(t)) return t.forEach((function(t) {
                            return n.add(t, e)
                        })), this;
                        if (D(t)) return this.addLabel(t, e);
                        if (!T(t)) return this;
                        t = ze.delayedCall(0, t)
                    }
                    return this !== t ? Pt(this, t, e) : this
                }, s.getChildren = function(t, e, n, i) {
                    void 0 === t && (t = !0), void 0 === e && (e = !0), void 0 === n && (n = !0), void 0 === i && (i = -y);
                    for (var r = [], s = this._first; s;) s._start >= i && (s instanceof ze ? e && r.push(s) : (n && r.push(s), t && r.push.apply(r, s.getChildren(!0, e, n)))), s = s._next;
                    return r
                }, s.getById = function(t) {
                    for (var e = this.getChildren(1, 1, 1), n = e.length; n--;)
                        if (e[n].vars.id === t) return e[n]
                }, s.remove = function(t) {
                    return D(t) ? this.removeLabel(t) : T(t) ? this.killTweensOf(t) : (bt(this, t), t === this._recent && (this._recent = this._last), Mt(this))
                }, s.totalTime = function(t, e) {
                    return arguments.length ? (this._forcing = 1, !this._dp && this._ts && (this._start = lt(fe.time - (this._ts > 0 ? t / this._ts : (this.totalDuration() - t) / -this._ts))), n.prototype.totalTime.call(this, t, e), this._forcing = 0, this) : this._tTime
                }, s.addLabel = function(t, e) {
                    return this.labels[t] = kt(this, e), this
                }, s.removeLabel = function(t) {
                    return delete this.labels[t], this
                }, s.addPause = function(t, e, n) {
                    var i = ze.delayedCall(0, e || Z, n);
                    return i.data = "isPause", this._hasPause = 1, Pt(this, i, kt(this, t))
                }, s.removePause = function(t) {
                    var e = this._first;
                    for (t = kt(this, t); e;) e._start === t && "isPause" === e.data && wt(e), e = e._next
                }, s.killTweensOf = function(t, e, n) {
                    for (var i = this.getTweensOf(t, n), r = i.length; r--;) Le !== i[r] && i[r].kill(t, e);
                    return this
                }, s.getTweensOf = function(t, e) {
                    for (var n, i = [], r = qt(t), s = this._first, o = A(e); s;) s instanceof ze ? ct(s._targets, r) && (o ? (!Le || s._initted && s._ts) && s.globalTime(0) <= e && s.globalTime(s.totalDuration()) > e : !e || s.isActive()) && i.push(s) : (n = s.getTweensOf(r, e)).length && i.push.apply(i, n), s = s._next;
                    return i
                }, s.tweenTo = function(t, e) {
                    e = e || {};
                    var n = this,
                        i = kt(n, t),
                        r = e,
                        s = r.startAt,
                        o = r.onStart,
                        a = r.onStartParams,
                        l = r.immediateRender,
                        c = ze.to(n, mt({
                            ease: "none",
                            lazy: !1,
                            immediateRender: !1,
                            time: i,
                            overwrite: "auto",
                            duration: e.duration || Math.abs((i - (s && "time" in s ? s.time : n._time)) / n.timeScale()) || x,
                            onStart: function() {
                                n.pause();
                                var t = e.duration || Math.abs((i - n._time) / n.timeScale());
                                c._dur !== t && Nt(c, t, 0, 1).render(c._time, !0, !0), o && o.apply(c, a || [])
                            }
                        }, e));
                    return l ? c.render(0) : c
                }, s.tweenFromTo = function(t, e, n) {
                    return this.tweenTo(e, mt({
                        startAt: {
                            time: kt(this, t)
                        }
                    }, n))
                }, s.recent = function() {
                    return this._recent
                }, s.nextLabel = function(t) {
                    return void 0 === t && (t = this._time), ee(this, kt(this, t))
                }, s.previousLabel = function(t) {
                    return void 0 === t && (t = this._time), ee(this, kt(this, t), 1)
                }, s.currentLabel = function(t) {
                    return arguments.length ? this.seek(t, !0) : this.previousLabel(this._time + x)
                }, s.shiftChildren = function(t, e, n) {
                    void 0 === n && (n = 0);
                    for (var i, r = this._first, s = this.labels; r;) r._start >= n && (r._start += t, r._end += t), r = r._next;
                    if (e)
                        for (i in s) s[i] >= n && (s[i] += t);
                    return Mt(this)
                }, s.invalidate = function() {
                    var t = this._first;
                    for (this._lock = 0; t;) t.invalidate(), t = t._next;
                    return n.prototype.invalidate.call(this)
                }, s.clear = function(t) {
                    void 0 === t && (t = !0);
                    for (var e, n = this._first; n;) e = n._next, this.remove(n), n = e;
                    return this._dp && (this._time = this._tTime = this._pTime = 0), t && (this.labels = {}), Mt(this)
                }, s.totalDuration = function(t) {
                    var e, n, i, s = 0,
                        o = this,
                        a = o._last,
                        l = y;
                    if (arguments.length) return o.timeScale((o._repeat < 0 ? o.duration() : o.totalDuration()) / (o.reversed() ? -t : t));
                    if (o._dirty) {
                        for (i = o.parent; a;) e = a._prev, a._dirty && a.totalDuration(), (n = a._start) > l && o._sort && a._ts && !o._lock ? (o._lock = 1, Pt(o, a, n - a._delay, 1)._lock = 0) : l = n, n < 0 && a._ts && (s -= n, (!i && !o._dp || i && i.smoothChildTiming) && (o._start += n / o._ts, o._time -= n, o._tTime -= n), o.shiftChildren(-n, !1, -Infinity), l = 0), a._end > s && a._ts && (s = a._end), a = e;
                        Nt(o, o === r && o._time > s ? o._time : s, 1, 1), o._dirty = 0
                    }
                    return o._tDur
                }, i.updateRoot = function(t) {
                    if (r._ts && (dt(r, At(t, r)), c = fe.frame), fe.frame >= et) {
                        et += g.autoSleep || 120;
                        var e = r._first;
                        if ((!e || !e._ts) && g.autoSleep && fe._listeners.length < 2) {
                            for (; e && !e._ts;) e = e._next;
                            e || fe.sleep()
                        }
                    }
                }, i
            }(Ae);
            mt(Ce.prototype, {
                _lock: 0,
                _hasPause: 0,
                _forcing: 0
            });
            var Le, Re = function(t, e, n, i, r, s, o) {
                    var a, l, c, u, h, d, p, f, m = new Ke(this._pt, t, e, 0, 1, qe, null, r),
                        g = 0,
                        v = 0;
                    for (m.b = n, m.e = i, n += "", (p = ~(i += "").indexOf("random(")) && (i = $t(i)), s && (s(f = [n, i], t, e), n = f[0], i = f[1]), l = n.match(k) || []; a = k.exec(i);) u = a[0], h = i.substring(g, a.index), c ? c = (c + 1) % 5 : "rgba(" === h.substr(-5) && (c = 1), u !== l[v++] && (d = parseFloat(l[v - 1]) || 0, m._pt = {
                        _next: m._pt,
                        p: h || 1 === v ? h : ",",
                        s: d,
                        c: "=" === u.charAt(1) ? parseFloat(u.substr(2)) * ("-" === u.charAt(0) ? -1 : 1) : parseFloat(u) - d,
                        m: c && c < 4 ? Math.round : 0
                    }, g = k.lastIndex);
                    return m.c = g < i.length ? i.substring(g, i.length) : "", m.fp = o, (H.test(i) || p) && (m.e = 0), this._pt = m, m
                },
                Pe = function(t, e, n, i, r, s, o, a, l) {
                    T(i) && (i = i(r || 0, t, s));
                    var c, u = t[e],
                        h = "get" !== n ? n : T(u) ? l ? t[e.indexOf("set") || !T(t["get" + e.substr(3)]) ? e : "get" + e.substr(3)](l) : t[e]() : u,
                        d = T(u) ? l ? Ue : He : ke;
                    if (D(i) && (~i.indexOf("random(") && (i = $t(i)), "=" === i.charAt(1) && (i = parseFloat(h) + parseFloat(i.substr(2)) * ("-" === i.charAt(0) ? -1 : 1) + (Gt(h) || 0))), h !== i) return isNaN(h * i) ? (!u && !(e in t) && q(e, i), Re.call(this, t, e, h, i, d, a || g.stringFilter, l)) : (c = new Ke(this._pt, t, e, +h || 0, i - (h || 0), "boolean" == typeof u ? je : Ve, 0, d), l && (c.fp = l), o && c.modifier(o, this, t), this._pt = c)
                },
                Fe = function(t, e, n, i, r, s) {
                    var o, a, l, c;
                    if ($[t] && !1 !== (o = new $[t]).init(r, o.rawVars ? e[t] : function(t, e, n, i, r) {
                            if (T(t) && (t = Ie(t, r, e, n, i)), !L(t) || t.style && t.nodeType || I(t) || O(t)) return D(t) ? Ie(t, r, e, n, i) : t;
                            var s, o = {};
                            for (s in t) o[s] = Ie(t[s], r, e, n, i);
                            return o
                        }(e[t], i, r, s, n), n, i, s) && (n._pt = a = new Ke(n._pt, r, t, 0, 1, o.render, o, 0, o.priority), n !== u))
                        for (l = n._ptLookup[n._targets.indexOf(r)], c = o._props.length; c--;) l[o._props[c]] = a;
                    return o
                },
                Oe = function t(e, n) {
                    var s, o, a, l, c, u, h, d, p, f, m, g, y, _ = e.vars,
                        b = _.ease,
                        w = _.startAt,
                        M = _.immediateRender,
                        S = _.lazy,
                        E = _.onUpdate,
                        D = _.onUpdateParams,
                        T = _.callbackScope,
                        A = _.runBackwards,
                        C = _.yoyoEase,
                        L = _.keyframes,
                        P = _.autoRevert,
                        F = e._dur,
                        O = e._startAt,
                        I = e._targets,
                        N = e.parent,
                        B = N && "nested" === N.data ? N.parent._targets : I,
                        z = "auto" === e._overwrite && !i,
                        k = e.timeline;
                    if (k && (!L || !b) && (b = "none"), e._ease = we(b, v.ease), e._yEase = C ? _e(we(!0 === C ? b : C, v.ease)) : 0, C && e._yoyo && !e._repeat && (C = e._yEase, e._yEase = e._ease, e._ease = C), !k) {
                        if (g = (d = I[0] ? st(I[0]).harness : 0) && _[d.prop], s = xt(_, J), O && O.render(-1, !0).kill(), w) {
                            if (wt(e._startAt = ze.set(I, mt({
                                    data: "isStart",
                                    overwrite: !1,
                                    parent: N,
                                    immediateRender: !0,
                                    lazy: R(S),
                                    startAt: null,
                                    delay: 0,
                                    onUpdate: E,
                                    onUpdateParams: D,
                                    callbackScope: T,
                                    stagger: 0
                                }, w))), M)
                                if (n > 0) P || (e._startAt = 0);
                                else if (F && !(n < 0 && O)) return void(n && (e._zTime = n))
                        } else if (A && F)
                            if (O) !P && (e._startAt = 0);
                            else if (n && (M = !1), a = mt({
                                overwrite: !1,
                                data: "isFromStart",
                                lazy: M && R(S),
                                immediateRender: M,
                                stagger: 0,
                                parent: N
                            }, s), g && (a[d.prop] = g), wt(e._startAt = ze.set(I, a)), M) {
                            if (!n) return
                        } else t(e._startAt, x);
                        for (e._pt = 0, S = F && R(S) || S && !F, o = 0; o < I.length; o++) {
                            if (h = (c = I[o])._gsap || rt(I)[o]._gsap, e._ptLookup[o] = f = {}, K[h.id] && Q.length && ht(), m = B === I ? o : B.indexOf(c), d && !1 !== (p = new d).init(c, g || s, e, m, B) && (e._pt = l = new Ke(e._pt, c, p.name, 0, 1, p.render, p, 0, p.priority), p._props.forEach((function(t) {
                                    f[t] = l
                                })), p.priority && (u = 1)), !d || g)
                                for (a in s) $[a] && (p = Fe(a, s, e, m, c, B)) ? p.priority && (u = 1) : f[a] = l = Pe.call(e, c, a, "get", s[a], m, B, 0, _.stringFilter);
                            e._op && e._op[o] && e.kill(c, e._op[o]), z && e._pt && (Le = e, r.killTweensOf(c, f, e.globalTime(0)), y = !e.parent, Le = 0), e._pt && S && (K[h.id] = 1)
                        }
                        u && Qe(e), e._onInit && e._onInit(e)
                    }
                    e._from = !k && !!_.runBackwards, e._onUpdate = E, e._initted = (!e._op || e._pt) && !y
                },
                Ie = function(t, e, n, i, r) {
                    return T(t) ? t.call(e, n, i, r) : D(t) && ~t.indexOf("random(") ? $t(t) : t
                },
                Ne = it + "repeat,repeatDelay,yoyo,repeatRefresh,yoyoEase",
                Be = (Ne + ",id,stagger,delay,duration,paused,scrollTrigger").split(","),
                ze = function(n) {
                    function s(e, s, o, a) {
                        var l;
                        "number" == typeof s && (o.duration = s, s = o, o = null);
                        var c, u, h, d, p, f, m, v, y = (l = n.call(this, a ? s : _t(s), o) || this).vars,
                            x = y.duration,
                            _ = y.delay,
                            b = y.immediateRender,
                            w = y.stagger,
                            M = y.overwrite,
                            S = y.keyframes,
                            E = y.defaults,
                            D = y.scrollTrigger,
                            T = y.yoyoEase,
                            C = l.parent,
                            P = (I(e) || O(e) ? A(e[0]) : "length" in s) ? [e] : qt(e);
                        if (l._targets = P.length ? rt(P) : X("GSAP target " + e + " not found. https://greensock.com", !g.nullTargetWarn) || [], l._ptLookup = [], l._overwrite = M, S || w || F(x) || F(_)) {
                            if (s = l.vars, (c = l.timeline = new Ce({
                                    data: "nested",
                                    defaults: E || {}
                                })).kill(), c.parent = c._dp = t(l), c._start = 0, S) mt(c.vars.defaults, {
                                ease: "none"
                            }), S.forEach((function(t) {
                                return c.to(P, t, ">")
                            }));
                            else {
                                if (d = P.length, m = w ? Yt(w) : Z, L(w))
                                    for (p in w) ~Ne.indexOf(p) && (v || (v = {}), v[p] = w[p]);
                                for (u = 0; u < d; u++) {
                                    for (p in h = {}, s) Be.indexOf(p) < 0 && (h[p] = s[p]);
                                    h.stagger = 0, T && (h.yoyoEase = T), v && vt(h, v), f = P[u], h.duration = +Ie(x, t(l), u, f, P), h.delay = (+Ie(_, t(l), u, f, P) || 0) - l._delay, !w && 1 === d && h.delay && (l._delay = _ = h.delay, l._start += _, h.delay = 0), c.to(f, h, m(u, f, P))
                                }
                                c.duration() ? x = _ = 0 : l.timeline = 0
                            }
                            x || l.duration(x = c.duration())
                        } else l.timeline = 0;
                        return !0 !== M || i || (Le = t(l), r.killTweensOf(P), Le = 0), C && Rt(C, t(l)), (b || !x && !S && l._start === lt(C._time) && R(b) && Et(t(l)) && "nested" !== C.data) && (l._tTime = -1e-8, l.render(Math.max(0, -_))), D && Ft(t(l), D), l
                    }
                    e(s, n);
                    var o = s.prototype;
                    return o.render = function(t, e, n) {
                        var i, r, s, o, a, l, c, u, h, d = this._time,
                            p = this._tDur,
                            f = this._dur,
                            m = t > p - x && t >= 0 ? p : t < x ? 0 : t;
                        if (f) {
                            if (m !== this._tTime || !t || n || !this._initted && this._tTime || this._startAt && this._zTime < 0 != t < 0) {
                                if (i = m, u = this.timeline, this._repeat) {
                                    if (o = f + this._rDelay, this._repeat < -1 && t < 0) return this.totalTime(100 * o + t, e, n);
                                    if (i = lt(m % o), m === p ? (s = this._repeat, i = f) : ((s = ~~(m / o)) && s === m / o && (i = f, s--), i > f && (i = f)), (l = this._yoyo && 1 & s) && (h = this._yEase, i = f - i), a = Tt(this._tTime, o), i === d && !n && this._initted) return this;
                                    s !== a && (u && this._yEase && be(u, l), !this.vars.repeatRefresh || l || this._lock || (this._lock = n = 1, this.render(lt(o * s), !0).invalidate()._lock = 0))
                                }
                                if (!this._initted) {
                                    if (Ot(this, t < 0 ? t : i, n, e)) return this._tTime = 0, this;
                                    if (f !== this._dur) return this.render(t, e, n)
                                }
                                for (this._tTime = m, this._time = i, !this._act && this._ts && (this._act = 1, this._lazy = 0), this.ratio = c = (h || this._ease)(i / f), this._from && (this.ratio = c = 1 - c), i && !d && !e && ne(this, "onStart"), r = this._pt; r;) r.r(c, r.d), r = r._next;
                                u && u.render(t < 0 ? t : !i && l ? -1e-8 : u._dur * c, e, n) || this._startAt && (this._zTime = t), this._onUpdate && !e && (t < 0 && this._startAt && this._startAt.render(t, !0, n), ne(this, "onUpdate")), this._repeat && s !== a && this.vars.onRepeat && !e && this.parent && ne(this, "onRepeat"), m !== this._tDur && m || this._tTime !== m || (t < 0 && this._startAt && !this._onUpdate && this._startAt.render(t, !0, !0), (t || !f) && (m === this._tDur && this._ts > 0 || !m && this._ts < 0) && wt(this, 1), e || t < 0 && !d || !m && !d || (ne(this, m === p ? "onComplete" : "onReverseComplete", !0), this._prom && !(m < p && this.timeScale() > 0) && this._prom()))
                            }
                        } else ! function(t, e, n, i) {
                            var r, s, o, a = t.ratio,
                                l = e < 0 || !e && (!t._start && It(t) || (t._ts < 0 || t._dp._ts < 0) && "isFromStart" !== t.data && "isStart" !== t.data) ? 0 : 1,
                                c = t._rDelay,
                                u = 0;
                            if (c && t._repeat && (u = Ut(0, t._tDur, e), s = Tt(u, c), o = Tt(t._tTime, c), t._yoyo && 1 & s && (l = 1 - l), s !== o && (a = 1 - l, t.vars.repeatRefresh && t._initted && t.invalidate())), l !== a || i || t._zTime === x || !e && t._zTime) {
                                if (!t._initted && Ot(t, e, i, n)) return;
                                for (o = t._zTime, t._zTime = e || (n ? x : 0), n || (n = e && !o), t.ratio = l, t._from && (l = 1 - l), t._time = 0, t._tTime = u, n || ne(t, "onStart"), r = t._pt; r;) r.r(l, r.d), r = r._next;
                                t._startAt && e < 0 && t._startAt.render(e, !0, !0), t._onUpdate && !n && ne(t, "onUpdate"), u && t._repeat && !n && t.parent && ne(t, "onRepeat"), (e >= t._tDur || e < 0) && t.ratio === l && (l && wt(t, 1), n || (ne(t, l ? "onComplete" : "onReverseComplete", !0), t._prom && t._prom()))
                            } else t._zTime || (t._zTime = e)
                        }(this, t, e, n);
                        return this
                    }, o.targets = function() {
                        return this._targets
                    }, o.invalidate = function() {
                        return this._pt = this._op = this._startAt = this._onUpdate = this._lazy = this.ratio = 0, this._ptLookup = [], this.timeline && this.timeline.invalidate(), n.prototype.invalidate.call(this)
                    }, o.kill = function(t, e) {
                        if (void 0 === e && (e = "all"), !(t || e && "all" !== e)) return this._lazy = this._pt = 0, this.parent ? ie(this) : this;
                        if (this.timeline) {
                            var n = this.timeline.totalDuration();
                            return this.timeline.killTweensOf(t, e, Le && !0 !== Le.vars.overwrite)._first || ie(this), this.parent && n !== this.timeline.totalDuration() && Nt(this, this._dur * this.timeline._tDur / n, 0, 1), this
                        }
                        var i, r, s, o, a, l, c, u = this._targets,
                            h = t ? qt(t) : u,
                            d = this._ptLookup,
                            p = this._pt;
                        if ((!e || "all" === e) && function(t, e) {
                                for (var n = t.length, i = n === e.length; i && n-- && t[n] === e[n];);
                                return n < 0
                            }(u, h)) return "all" === e && (this._pt = 0), ie(this);
                        for (i = this._op = this._op || [], "all" !== e && (D(e) && (a = {}, at(e, (function(t) {
                                return a[t] = 1
                            })), e = a), e = function(t, e) {
                                var n, i, r, s, o = t[0] ? st(t[0]).harness : 0,
                                    a = o && o.aliases;
                                if (!a) return e;
                                for (i in n = vt({}, e), a)
                                    if (i in n)
                                        for (r = (s = a[i].split(",")).length; r--;) n[s[r]] = n[i];
                                return n
                            }(u, e)), c = u.length; c--;)
                            if (~h.indexOf(u[c]))
                                for (a in r = d[c], "all" === e ? (i[c] = e, o = r, s = {}) : (s = i[c] = i[c] || {}, o = e), o)(l = r && r[a]) && ("kill" in l.d && !0 !== l.d.kill(a) || bt(this, l, "_pt"), delete r[a]), "all" !== s && (s[a] = 1);
                        return this._initted && !this._pt && p && ie(this), this
                    }, s.to = function(t, e) {
                        return new s(t, e, arguments[2])
                    }, s.from = function(t, e) {
                        return new s(t, ut(arguments, 1))
                    }, s.delayedCall = function(t, e, n, i) {
                        return new s(e, 0, {
                            immediateRender: !1,
                            lazy: !1,
                            overwrite: !1,
                            delay: t,
                            onComplete: e,
                            onReverseComplete: e,
                            onCompleteParams: n,
                            onReverseCompleteParams: n,
                            callbackScope: i
                        })
                    }, s.fromTo = function(t, e, n) {
                        return new s(t, ut(arguments, 2))
                    }, s.set = function(t, e) {
                        return e.duration = 0, e.repeatDelay || (e.repeat = 0), new s(t, e)
                    }, s.killTweensOf = function(t, e, n) {
                        return r.killTweensOf(t, e, n)
                    }, s
                }(Ae);
            mt(ze.prototype, {
                _targets: [],
                _lazy: 0,
                _startAt: 0,
                _op: 0,
                _onInit: 0
            }), at("staggerTo,staggerFrom,staggerFromTo", (function(t) {
                ze[t] = function() {
                    var e = new Ce,
                        n = Wt.call(arguments, 0);
                    return n.splice("staggerFromTo" === t ? 5 : 4, 0, 0), e[t].apply(e, n)
                }
            }));
            var ke = function(t, e, n) {
                    return t[e] = n
                },
                He = function(t, e, n) {
                    return t[e](n)
                },
                Ue = function(t, e, n, i) {
                    return t[e](i.fp, n)
                },
                Ge = function(t, e, n) {
                    return t.setAttribute(e, n)
                },
                We = function(t, e) {
                    return T(t[e]) ? He : C(t[e]) && t.setAttribute ? Ge : ke
                },
                Ve = function(t, e) {
                    return e.set(e.t, e.p, Math.round(1e4 * (e.s + e.c * t)) / 1e4, e)
                },
                je = function(t, e) {
                    return e.set(e.t, e.p, !!(e.s + e.c * t), e)
                },
                qe = function(t, e) {
                    var n = e._pt,
                        i = "";
                    if (!t && e.b) i = e.b;
                    else if (1 === t && e.e) i = e.e;
                    else {
                        for (; n;) i = n.p + (n.m ? n.m(n.s + n.c * t) : Math.round(1e4 * (n.s + n.c * t)) / 1e4) + i, n = n._next;
                        i += e.c
                    }
                    e.set(e.t, e.p, i, e)
                },
                Xe = function(t, e) {
                    for (var n = e._pt; n;) n.r(t, n.d), n = n._next
                },
                Ye = function(t, e, n, i) {
                    for (var r, s = this._pt; s;) r = s._next, s.p === i && s.modifier(t, e, n), s = r
                },
                Ze = function(t) {
                    for (var e, n, i = this._pt; i;) n = i._next, i.p === t && !i.op || i.op === t ? bt(this, i, "_pt") : i.dep || (e = 1), i = n;
                    return !e
                },
                Je = function(t, e, n, i) {
                    i.mSet(t, e, i.m.call(i.tween, n, i.mt), i)
                },
                Qe = function(t) {
                    for (var e, n, i, r, s = t._pt; s;) {
                        for (e = s._next, n = i; n && n.pr > s.pr;) n = n._next;
                        (s._prev = n ? n._prev : r) ? s._prev._next = s: i = s, (s._next = n) ? n._prev = s : r = s, s = e
                    }
                    t._pt = i
                },
                Ke = function() {
                    function t(t, e, n, i, r, s, o, a, l) {
                        this.t = e, this.s = i, this.c = r, this.p = n, this.r = s || Ve, this.d = o || this, this.set = a || ke, this.pr = l || 0, this._next = t, t && (t._prev = this)
                    }
                    return t.prototype.modifier = function(t, e, n) {
                        this.mSet = this.mSet || this.set, this.set = Je, this.m = t, this.mt = n, this.tween = e
                    }, t
                }();
            at(it + "parent,duration,ease,delay,overwrite,runBackwards,startAt,yoyo,immediateRender,repeat,repeatDelay,data,paused,reversed,lazy,callbackScope,stringFilter,id,yoyoEase,stagger,inherit,repeatRefresh,keyframes,autoRevert,scrollTrigger", (function(t) {
                return J[t] = 1
            })), W.TweenMax = W.TweenLite = ze, W.TimelineLite = W.TimelineMax = Ce, r = new Ce({
                sortChildren: !1,
                defaults: v,
                autoRemoveChildren: !0,
                id: "root",
                smoothChildTiming: !0
            }), g.stringFilter = pe;
            var $e = {
                registerPlugin: function() {
                    for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++) e[n] = arguments[n];
                    e.forEach((function(t) {
                        return re(t)
                    }))
                },
                timeline: function(t) {
                    return new Ce(t)
                },
                getTweensOf: function(t, e) {
                    return r.getTweensOf(t, e)
                },
                getProperty: function(t, e, n, i) {
                    D(t) && (t = qt(t)[0]);
                    var r = st(t || {}).get,
                        s = n ? ft : pt;
                    return "native" === n && (n = ""), t ? e ? s(($[e] && $[e].get || r)(t, e, n, i)) : function(e, n, i) {
                        return s(($[e] && $[e].get || r)(t, e, n, i))
                    } : t
                },
                quickSetter: function(t, e, n) {
                    if ((t = qt(t)).length > 1) {
                        var i = t.map((function(t) {
                                return nn.quickSetter(t, e, n)
                            })),
                            r = i.length;
                        return function(t) {
                            for (var e = r; e--;) i[e](t)
                        }
                    }
                    t = t[0] || {};
                    var s = $[e],
                        o = st(t),
                        a = o.harness && (o.harness.aliases || {})[e] || e,
                        l = s ? function(e) {
                            var i = new s;
                            u._pt = 0, i.init(t, n ? e + n : e, u, 0, [t]), i.render(1, i), u._pt && Xe(1, u)
                        } : o.set(t, a);
                    return s ? l : function(e) {
                        return l(t, a, n ? e + n : e, o, 1)
                    }
                },
                isTweening: function(t) {
                    return r.getTweensOf(t, !0).length > 0
                },
                defaults: function(t) {
                    return t && t.ease && (t.ease = we(t.ease, v.ease)), yt(v, t || {})
                },
                config: function(t) {
                    return yt(g, t || {})
                },
                registerEffect: function(t) {
                    var e = t.name,
                        n = t.effect,
                        i = t.plugins,
                        r = t.defaults,
                        s = t.extendTimeline;
                    (i || "").split(",").forEach((function(t) {
                        return t && !$[t] && !W[t] && X(e + " effect requires " + t + " plugin.")
                    })), tt[e] = function(t, e, i) {
                        return n(qt(t), mt(e || {}, r), i)
                    }, s && (Ce.prototype[e] = function(t, n, i) {
                        return this.add(tt[e](t, L(n) ? n : (i = n) && {}, this), i)
                    })
                },
                registerEase: function(t, e) {
                    ge[t] = we(e)
                },
                parseEase: function(t, e) {
                    return arguments.length ? we(t, e) : ge
                },
                getById: function(t) {
                    return r.getById(t)
                },
                exportRoot: function(t, e) {
                    void 0 === t && (t = {});
                    var n, i, s = new Ce(t);
                    for (s.smoothChildTiming = R(t.smoothChildTiming), r.remove(s), s._dp = 0, s._time = s._tTime = r._time, n = r._first; n;) i = n._next, !e && !n._dur && n instanceof ze && n.vars.onComplete === n._targets[0] || Pt(s, n, n._start - n._delay), n = i;
                    return Pt(r, s, 0), s
                },
                utils: {
                    wrap: function t(e, n, i) {
                        var r = n - e;
                        return I(e) ? Kt(e, t(0, e.length), n) : Ht(i, (function(t) {
                            return (r + (t - e) % r) % r + e
                        }))
                    },
                    wrapYoyo: function t(e, n, i) {
                        var r = n - e,
                            s = 2 * r;
                        return I(e) ? Kt(e, t(0, e.length - 1), n) : Ht(i, (function(t) {
                            return e + ((t = (s + (t - e) % s) % s || 0) > r ? s - t : t)
                        }))
                    },
                    distribute: Yt,
                    random: Qt,
                    snap: Jt,
                    normalize: function(t, e, n) {
                        return te(t, e, 0, 1, n)
                    },
                    getUnit: Gt,
                    clamp: function(t, e, n) {
                        return Ht(n, (function(n) {
                            return Ut(t, e, n)
                        }))
                    },
                    splitColor: le,
                    toArray: qt,
                    mapRange: te,
                    pipe: function() {
                        for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++) e[n] = arguments[n];
                        return function(t) {
                            return e.reduce((function(t, e) {
                                return e(t)
                            }), t)
                        }
                    },
                    unitize: function(t, e) {
                        return function(n) {
                            return t(parseFloat(n)) + (e || Gt(n))
                        }
                    },
                    interpolate: function t(e, n, i, r) {
                        var s = isNaN(e + n) ? 0 : function(t) {
                            return (1 - t) * e + t * n
                        };
                        if (!s) {
                            var o, a, l, c, u, h = D(e),
                                d = {};
                            if (!0 === i && (r = 1) && (i = null), h) e = {
                                p: e
                            }, n = {
                                p: n
                            };
                            else if (I(e) && !I(n)) {
                                for (l = [], c = e.length, u = c - 2, a = 1; a < c; a++) l.push(t(e[a - 1], e[a]));
                                c--, s = function(t) {
                                    t *= c;
                                    var e = Math.min(u, ~~t);
                                    return l[e](t - e)
                                }, i = n
                            } else r || (e = vt(I(e) ? [] : {}, e));
                            if (!l) {
                                for (o in n) Pe.call(d, e, o, "get", n[o]);
                                s = function(t) {
                                    return Xe(t, d) || (h ? e.p : e)
                                }
                            }
                        }
                        return Ht(i, s)
                    },
                    shuffle: Xt
                },
                install: j,
                effects: tt,
                ticker: fe,
                updateRoot: Ce.updateRoot,
                plugins: $,
                globalTimeline: r,
                core: {
                    PropTween: Ke,
                    globals: Y,
                    Tween: ze,
                    Timeline: Ce,
                    Animation: Ae,
                    getCache: st,
                    _removeLinkedListItem: bt,
                    suppressOverwrites: function(t) {
                        return i = t
                    }
                }
            };
            at("to,from,fromTo,delayedCall,set,killTweensOf", (function(t) {
                return $e[t] = ze[t]
            })), fe.add(Ce.updateRoot), u = $e.to({}, {
                duration: 0
            });
            var tn = function(t, e) {
                    for (var n = t._pt; n && n.p !== e && n.op !== e && n.fp !== e;) n = n._next;
                    return n
                },
                en = function(t, e) {
                    return {
                        name: t,
                        rawVars: 1,
                        init: function(t, n, i) {
                            i._onInit = function(t) {
                                var i, r;
                                if (D(n) && (i = {}, at(n, (function(t) {
                                        return i[t] = 1
                                    })), n = i), e) {
                                    for (r in i = {}, n) i[r] = e(n[r]);
                                    n = i
                                }! function(t, e) {
                                    var n, i, r, s = t._targets;
                                    for (n in e)
                                        for (i = s.length; i--;)(r = t._ptLookup[i][n]) && (r = r.d) && (r._pt && (r = tn(r, n)), r && r.modifier && r.modifier(e[n], t, s[i], n))
                                }(t, n)
                            }
                        }
                    }
                },
                nn = $e.registerPlugin({
                    name: "attr",
                    init: function(t, e, n, i, r) {
                        var s, o;
                        for (s in e)(o = this.add(t, "setAttribute", (t.getAttribute(s) || 0) + "", e[s], i, r, 0, 0, s)) && (o.op = s), this._props.push(s)
                    }
                }, {
                    name: "endArray",
                    init: function(t, e) {
                        for (var n = e.length; n--;) this.add(t, n, t[n] || 0, e[n])
                    }
                }, en("roundProps", Zt), en("modifiers"), en("snap", Jt)) || $e;
            ze.version = Ce.version = nn.version = "3.6.0", l = 1, P() && me();
            ge.Power0, ge.Power1, ge.Power2, ge.Power3, ge.Power4, ge.Linear, ge.Quad, ge.Cubic, ge.Quart, ge.Quint, ge.Strong, ge.Elastic, ge.Back, ge.SteppedEase, ge.Bounce, ge.Sine, ge.Expo, ge.Circ;
            var rn, sn, on, an, ln, cn, un, hn, dn = {},
                pn = 180 / Math.PI,
                fn = Math.PI / 180,
                mn = Math.atan2,
                gn = /([A-Z])/g,
                vn = /(?:left|right|width|margin|padding|x)/i,
                yn = /[\s,\(]\S/,
                xn = {
                    autoAlpha: "opacity,visibility",
                    scale: "scaleX,scaleY",
                    alpha: "opacity"
                },
                _n = function(t, e) {
                    return e.set(e.t, e.p, Math.round(1e4 * (e.s + e.c * t)) / 1e4 + e.u, e)
                },
                bn = function(t, e) {
                    return e.set(e.t, e.p, 1 === t ? e.e : Math.round(1e4 * (e.s + e.c * t)) / 1e4 + e.u, e)
                },
                wn = function(t, e) {
                    return e.set(e.t, e.p, t ? Math.round(1e4 * (e.s + e.c * t)) / 1e4 + e.u : e.b, e)
                },
                Mn = function(t, e) {
                    var n = e.s + e.c * t;
                    e.set(e.t, e.p, ~~(n + (n < 0 ? -.5 : .5)) + e.u, e)
                },
                Sn = function(t, e) {
                    return e.set(e.t, e.p, t ? e.e : e.b, e)
                },
                En = function(t, e) {
                    return e.set(e.t, e.p, 1 !== t ? e.b : e.e, e)
                },
                Dn = function(t, e, n) {
                    return t.style[e] = n
                },
                Tn = function(t, e, n) {
                    return t.style.setProperty(e, n)
                },
                An = function(t, e, n) {
                    return t._gsap[e] = n
                },
                Cn = function(t, e, n) {
                    return t._gsap.scaleX = t._gsap.scaleY = n
                },
                Ln = function(t, e, n, i, r) {
                    var s = t._gsap;
                    s.scaleX = s.scaleY = n, s.renderTransform(r, s)
                },
                Rn = function(t, e, n, i, r) {
                    var s = t._gsap;
                    s[e] = n, s.renderTransform(r, s)
                },
                Pn = "transform",
                Fn = Pn + "Origin",
                On = function(t, e) {
                    var n = sn.createElementNS ? sn.createElementNS((e || "http://www.w3.org/1999/xhtml").replace(/^https/, "http"), t) : sn.createElement(t);
                    return n.style ? n : sn.createElement(t)
                },
                In = function t(e, n, i) {
                    var r = getComputedStyle(e);
                    return r[n] || r.getPropertyValue(n.replace(gn, "-$1").toLowerCase()) || r.getPropertyValue(n) || !i && t(e, Bn(n) || n, 1) || ""
                },
                Nn = "O,Moz,ms,Ms,Webkit".split(","),
                Bn = function(t, e, n) {
                    var i = (e || ln).style,
                        r = 5;
                    if (t in i && !n) return t;
                    for (t = t.charAt(0).toUpperCase() + t.substr(1); r-- && !(Nn[r] + t in i););
                    return r < 0 ? null : (3 === r ? "ms" : r >= 0 ? Nn[r] : "") + t
                },
                zn = function() {
                    "undefined" != typeof window && window.document && (rn = window, sn = rn.document, on = sn.documentElement, ln = On("div") || {
                        style: {}
                    }, cn = On("div"), Pn = Bn(Pn), Fn = Pn + "Origin", ln.style.cssText = "border-width:0;line-height:0;position:absolute;padding:0", hn = !!Bn("perspective"), an = 1)
                },
                kn = function t(e) {
                    var n, i = On("svg", this.ownerSVGElement && this.ownerSVGElement.getAttribute("xmlns") || "http://www.w3.org/2000/svg"),
                        r = this.parentNode,
                        s = this.nextSibling,
                        o = this.style.cssText;
                    if (on.appendChild(i), i.appendChild(this), this.style.display = "block", e) try {
                        n = this.getBBox(), this._gsapBBox = this.getBBox, this.getBBox = t
                    } catch (t) {} else this._gsapBBox && (n = this._gsapBBox());
                    return r && (s ? r.insertBefore(this, s) : r.appendChild(this)), on.removeChild(i), this.style.cssText = o, n
                },
                Hn = function(t, e) {
                    for (var n = e.length; n--;)
                        if (t.hasAttribute(e[n])) return t.getAttribute(e[n])
                },
                Un = function(t) {
                    var e;
                    try {
                        e = t.getBBox()
                    } catch (n) {
                        e = kn.call(t, !0)
                    }
                    return e && (e.width || e.height) || t.getBBox === kn || (e = kn.call(t, !0)), !e || e.width || e.x || e.y ? e : {
                        x: +Hn(t, ["x", "cx", "x1"]) || 0,
                        y: +Hn(t, ["y", "cy", "y1"]) || 0,
                        width: 0,
                        height: 0
                    }
                },
                Gn = function(t) {
                    return !(!t.getCTM || t.parentNode && !t.ownerSVGElement || !Un(t))
                },
                Wn = function(t, e) {
                    if (e) {
                        var n = t.style;
                        e in dn && e !== Fn && (e = Pn), n.removeProperty ? ("ms" !== e.substr(0, 2) && "webkit" !== e.substr(0, 6) || (e = "-" + e), n.removeProperty(e.replace(gn, "-$1").toLowerCase())) : n.removeAttribute(e)
                    }
                },
                Vn = function(t, e, n, i, r, s) {
                    var o = new Ke(t._pt, e, n, 0, 1, s ? En : Sn);
                    return t._pt = o, o.b = i, o.e = r, t._props.push(n), o
                },
                jn = {
                    deg: 1,
                    rad: 1,
                    turn: 1
                },
                qn = function t(e, n, i, r) {
                    var s, o, a, l, c = parseFloat(i) || 0,
                        u = (i + "").trim().substr((c + "").length) || "px",
                        h = ln.style,
                        d = vn.test(n),
                        p = "svg" === e.tagName.toLowerCase(),
                        f = (p ? "client" : "offset") + (d ? "Width" : "Height"),
                        m = 100,
                        g = "px" === r,
                        v = "%" === r;
                    return r === u || !c || jn[r] || jn[u] ? c : ("px" !== u && !g && (c = t(e, n, i, "px")), l = e.getCTM && Gn(e), !v && "%" !== u || !dn[n] && !~n.indexOf("adius") ? (h[d ? "width" : "height"] = m + (g ? u : r), o = ~n.indexOf("adius") || "em" === r && e.appendChild && !p ? e : e.parentNode, l && (o = (e.ownerSVGElement || {}).parentNode), o && o !== sn && o.appendChild || (o = sn.body), (a = o._gsap) && v && a.width && d && a.time === fe.time ? lt(c / a.width * m) : ((v || "%" === u) && (h.position = In(e, "position")), o === e && (h.position = "static"), o.appendChild(ln), s = ln[f], o.removeChild(ln), h.position = "absolute", d && v && ((a = st(o)).time = fe.time, a.width = o[f]), lt(g ? s * c / m : s && c ? m / s * c : 0))) : (s = l ? e.getBBox()[d ? "width" : "height"] : e[f], lt(v ? c / s * m : c / 100 * s)))
                },
                Xn = function(t, e, n, i) {
                    var r;
                    return an || zn(), e in xn && "transform" !== e && ~(e = xn[e]).indexOf(",") && (e = e.split(",")[0]), dn[e] && "transform" !== e ? (r = ri(t, i), r = "transformOrigin" !== e ? r[e] : si(In(t, Fn)) + " " + r.zOrigin + "px") : (!(r = t.style[e]) || "auto" === r || i || ~(r + "").indexOf("calc(")) && (r = Qn[e] && Qn[e](t, e, n) || In(t, e) || ot(t, e) || ("opacity" === e ? 1 : 0)), n && !~(r + "").trim().indexOf(" ") ? qn(t, e, r, n) + n : r
                },
                Yn = function(t, e, n, i) {
                    if (!n || "none" === n) {
                        var r = Bn(e, t, 1),
                            s = r && In(t, r, 1);
                        s && s !== n ? (e = r, n = s) : "borderColor" === e && (n = In(t, "borderTopColor"))
                    }
                    var o, a, l, c, u, h, d, p, f, m, v, y, x = new Ke(this._pt, t.style, e, 0, 1, qe),
                        _ = 0,
                        b = 0;
                    if (x.b = n, x.e = i, n += "", "auto" === (i += "") && (t.style[e] = i, i = In(t, e) || i, t.style[e] = n), pe(o = [n, i]), i = o[1], l = (n = o[0]).match(z) || [], (i.match(z) || []).length) {
                        for (; a = z.exec(i);) d = a[0], f = i.substring(_, a.index), u ? u = (u + 1) % 5 : "rgba(" !== f.substr(-5) && "hsla(" !== f.substr(-5) || (u = 1), d !== (h = l[b++] || "") && (c = parseFloat(h) || 0, v = h.substr((c + "").length), (y = "=" === d.charAt(1) ? +(d.charAt(0) + "1") : 0) && (d = d.substr(2)), p = parseFloat(d), m = d.substr((p + "").length), _ = z.lastIndex - m.length, m || (m = m || g.units[e] || v, _ === i.length && (i += m, x.e += m)), v !== m && (c = qn(t, e, h, m) || 0), x._pt = {
                            _next: x._pt,
                            p: f || 1 === b ? f : ",",
                            s: c,
                            c: y ? y * p : p - c,
                            m: u && u < 4 || "zIndex" === e ? Math.round : 0
                        });
                        x.c = _ < i.length ? i.substring(_, i.length) : ""
                    } else x.r = "display" === e && "none" === i ? En : Sn;
                    return H.test(i) && (x.e = 0), this._pt = x, x
                },
                Zn = {
                    top: "0%",
                    bottom: "100%",
                    left: "0%",
                    right: "100%",
                    center: "50%"
                },
                Jn = function(t, e) {
                    if (e.tween && e.tween._time === e.tween._dur) {
                        var n, i, r, s = e.t,
                            o = s.style,
                            a = e.u,
                            l = s._gsap;
                        if ("all" === a || !0 === a) o.cssText = "", i = 1;
                        else
                            for (r = (a = a.split(",")).length; --r > -1;) n = a[r], dn[n] && (i = 1, n = "transformOrigin" === n ? Fn : Pn), Wn(s, n);
                        i && (Wn(s, Pn), l && (l.svg && s.removeAttribute("transform"), ri(s, 1), l.uncache = 1))
                    }
                },
                Qn = {
                    clearProps: function(t, e, n, i, r) {
                        if ("isFromStart" !== r.data) {
                            var s = t._pt = new Ke(t._pt, e, n, 0, 0, Jn);
                            return s.u = i, s.pr = -10, s.tween = r, t._props.push(n), 1
                        }
                    }
                },
                Kn = [1, 0, 0, 1, 0, 0],
                $n = {},
                ti = function(t) {
                    return "matrix(1, 0, 0, 1, 0, 0)" === t || "none" === t || !t
                },
                ei = function(t) {
                    var e = In(t, Pn);
                    return ti(e) ? Kn : e.substr(7).match(B).map(lt)
                },
                ni = function(t, e) {
                    var n, i, r, s, o = t._gsap || st(t),
                        a = t.style,
                        l = ei(t);
                    return o.svg && t.getAttribute("transform") ? "1,0,0,1,0,0" === (l = [(r = t.transform.baseVal.consolidate().matrix).a, r.b, r.c, r.d, r.e, r.f]).join(",") ? Kn : l : (l !== Kn || t.offsetParent || t === on || o.svg || (r = a.display, a.display = "block", (n = t.parentNode) && t.offsetParent || (s = 1, i = t.nextSibling, on.appendChild(t)), l = ei(t), r ? a.display = r : Wn(t, "display"), s && (i ? n.insertBefore(t, i) : n ? n.appendChild(t) : on.removeChild(t))), e && l.length > 6 ? [l[0], l[1], l[4], l[5], l[12], l[13]] : l)
                },
                ii = function(t, e, n, i, r, s) {
                    var o, a, l, c = t._gsap,
                        u = r || ni(t, !0),
                        h = c.xOrigin || 0,
                        d = c.yOrigin || 0,
                        p = c.xOffset || 0,
                        f = c.yOffset || 0,
                        m = u[0],
                        g = u[1],
                        v = u[2],
                        y = u[3],
                        x = u[4],
                        _ = u[5],
                        b = e.split(" "),
                        w = parseFloat(b[0]) || 0,
                        M = parseFloat(b[1]) || 0;
                    n ? u !== Kn && (a = m * y - g * v) && (l = w * (-g / a) + M * (m / a) - (m * _ - g * x) / a, w = w * (y / a) + M * (-v / a) + (v * _ - y * x) / a, M = l) : (w = (o = Un(t)).x + (~b[0].indexOf("%") ? w / 100 * o.width : w), M = o.y + (~(b[1] || b[0]).indexOf("%") ? M / 100 * o.height : M)), i || !1 !== i && c.smooth ? (x = w - h, _ = M - d, c.xOffset = p + (x * m + _ * v) - x, c.yOffset = f + (x * g + _ * y) - _) : c.xOffset = c.yOffset = 0, c.xOrigin = w, c.yOrigin = M, c.smooth = !!i, c.origin = e, c.originIsAbsolute = !!n, t.style[Fn] = "0px 0px", s && (Vn(s, c, "xOrigin", h, w), Vn(s, c, "yOrigin", d, M), Vn(s, c, "xOffset", p, c.xOffset), Vn(s, c, "yOffset", f, c.yOffset)), t.setAttribute("data-svg-origin", w + " " + M)
                },
                ri = function(t, e) {
                    var n = t._gsap || new Te(t);
                    if ("x" in n && !e && !n.uncache) return n;
                    var i, r, s, o, a, l, c, u, h, d, p, f, m, v, y, x, _, b, w, M, S, E, D, T, A, C, L, R, P, F, O, I, N = t.style,
                        B = n.scaleX < 0,
                        z = "px",
                        k = "deg",
                        H = In(t, Fn) || "0";
                    return i = r = s = l = c = u = h = d = p = 0, o = a = 1, n.svg = !(!t.getCTM || !Gn(t)), v = ni(t, n.svg), n.svg && (T = !n.uncache && t.getAttribute("data-svg-origin"), ii(t, T || H, !!T || n.originIsAbsolute, !1 !== n.smooth, v)), f = n.xOrigin || 0, m = n.yOrigin || 0, v !== Kn && (b = v[0], w = v[1], M = v[2], S = v[3], i = E = v[4], r = D = v[5], 6 === v.length ? (o = Math.sqrt(b * b + w * w), a = Math.sqrt(S * S + M * M), l = b || w ? mn(w, b) * pn : 0, (h = M || S ? mn(M, S) * pn + l : 0) && (a *= Math.cos(h * fn)), n.svg && (i -= f - (f * b + m * M), r -= m - (f * w + m * S))) : (I = v[6], F = v[7], L = v[8], R = v[9], P = v[10], O = v[11], i = v[12], r = v[13], s = v[14], c = (y = mn(I, P)) * pn, y && (T = E * (x = Math.cos(-y)) + L * (_ = Math.sin(-y)), A = D * x + R * _, C = I * x + P * _, L = E * -_ + L * x, R = D * -_ + R * x, P = I * -_ + P * x, O = F * -_ + O * x, E = T, D = A, I = C), u = (y = mn(-M, P)) * pn, y && (x = Math.cos(-y), O = S * (_ = Math.sin(-y)) + O * x, b = T = b * x - L * _, w = A = w * x - R * _, M = C = M * x - P * _), l = (y = mn(w, b)) * pn, y && (T = b * (x = Math.cos(y)) + w * (_ = Math.sin(y)), A = E * x + D * _, w = w * x - b * _, D = D * x - E * _, b = T, E = A), c && Math.abs(c) + Math.abs(l) > 359.9 && (c = l = 0, u = 180 - u), o = lt(Math.sqrt(b * b + w * w + M * M)), a = lt(Math.sqrt(D * D + I * I)), y = mn(E, D), h = Math.abs(y) > 2e-4 ? y * pn : 0, p = O ? 1 / (O < 0 ? -O : O) : 0), n.svg && (T = t.getAttribute("transform"), n.forceCSS = t.setAttribute("transform", "") || !ti(In(t, Pn)), T && t.setAttribute("transform", T))), Math.abs(h) > 90 && Math.abs(h) < 270 && (B ? (o *= -1, h += l <= 0 ? 180 : -180, l += l <= 0 ? 180 : -180) : (a *= -1, h += h <= 0 ? 180 : -180)), n.x = i - ((n.xPercent = i && (n.xPercent || (Math.round(t.offsetWidth / 2) === Math.round(-i) ? -50 : 0))) ? t.offsetWidth * n.xPercent / 100 : 0) + z, n.y = r - ((n.yPercent = r && (n.yPercent || (Math.round(t.offsetHeight / 2) === Math.round(-r) ? -50 : 0))) ? t.offsetHeight * n.yPercent / 100 : 0) + z, n.z = s + z, n.scaleX = lt(o), n.scaleY = lt(a), n.rotation = lt(l) + k, n.rotationX = lt(c) + k, n.rotationY = lt(u) + k, n.skewX = h + k, n.skewY = d + k, n.transformPerspective = p + z, (n.zOrigin = parseFloat(H.split(" ")[2]) || 0) && (N[Fn] = si(H)), n.xOffset = n.yOffset = 0, n.force3D = g.force3D, n.renderTransform = n.svg ? di : hn ? hi : ai, n.uncache = 0, n
                },
                si = function(t) {
                    return (t = t.split(" "))[0] + " " + t[1]
                },
                oi = function(t, e, n) {
                    var i = Gt(e);
                    return lt(parseFloat(e) + parseFloat(qn(t, "x", n + "px", i))) + i
                },
                ai = function(t, e) {
                    e.z = "0px", e.rotationY = e.rotationX = "0deg", e.force3D = 0, hi(t, e)
                },
                li = "0deg",
                ci = "0px",
                ui = ") ",
                hi = function(t, e) {
                    var n = e || this,
                        i = n.xPercent,
                        r = n.yPercent,
                        s = n.x,
                        o = n.y,
                        a = n.z,
                        l = n.rotation,
                        c = n.rotationY,
                        u = n.rotationX,
                        h = n.skewX,
                        d = n.skewY,
                        p = n.scaleX,
                        f = n.scaleY,
                        m = n.transformPerspective,
                        g = n.force3D,
                        v = n.target,
                        y = n.zOrigin,
                        x = "",
                        _ = "auto" === g && t && 1 !== t || !0 === g;
                    if (y && (u !== li || c !== li)) {
                        var b, w = parseFloat(c) * fn,
                            M = Math.sin(w),
                            S = Math.cos(w);
                        w = parseFloat(u) * fn, b = Math.cos(w), s = oi(v, s, M * b * -y), o = oi(v, o, -Math.sin(w) * -y), a = oi(v, a, S * b * -y + y)
                    }
                    m !== ci && (x += "perspective(" + m + ui), (i || r) && (x += "translate(" + i + "%, " + r + "%) "), (_ || s !== ci || o !== ci || a !== ci) && (x += a !== ci || _ ? "translate3d(" + s + ", " + o + ", " + a + ") " : "translate(" + s + ", " + o + ui), l !== li && (x += "rotate(" + l + ui), c !== li && (x += "rotateY(" + c + ui), u !== li && (x += "rotateX(" + u + ui), h === li && d === li || (x += "skew(" + h + ", " + d + ui), 1 === p && 1 === f || (x += "scale(" + p + ", " + f + ui), v.style[Pn] = x || "translate(0, 0)"
                },
                di = function(t, e) {
                    var n, i, r, s, o, a = e || this,
                        l = a.xPercent,
                        c = a.yPercent,
                        u = a.x,
                        h = a.y,
                        d = a.rotation,
                        p = a.skewX,
                        f = a.skewY,
                        m = a.scaleX,
                        g = a.scaleY,
                        v = a.target,
                        y = a.xOrigin,
                        x = a.yOrigin,
                        _ = a.xOffset,
                        b = a.yOffset,
                        w = a.forceCSS,
                        M = parseFloat(u),
                        S = parseFloat(h);
                    d = parseFloat(d), p = parseFloat(p), (f = parseFloat(f)) && (p += f = parseFloat(f), d += f), d || p ? (d *= fn, p *= fn, n = Math.cos(d) * m, i = Math.sin(d) * m, r = Math.sin(d - p) * -g, s = Math.cos(d - p) * g, p && (f *= fn, o = Math.tan(p - f), r *= o = Math.sqrt(1 + o * o), s *= o, f && (o = Math.tan(f), n *= o = Math.sqrt(1 + o * o), i *= o)), n = lt(n), i = lt(i), r = lt(r), s = lt(s)) : (n = m, s = g, i = r = 0), (M && !~(u + "").indexOf("px") || S && !~(h + "").indexOf("px")) && (M = qn(v, "x", u, "px"), S = qn(v, "y", h, "px")), (y || x || _ || b) && (M = lt(M + y - (y * n + x * r) + _), S = lt(S + x - (y * i + x * s) + b)), (l || c) && (o = v.getBBox(), M = lt(M + l / 100 * o.width), S = lt(S + c / 100 * o.height)), o = "matrix(" + n + "," + i + "," + r + "," + s + "," + M + "," + S + ")", v.setAttribute("transform", o), w && (v.style[Pn] = o)
                },
                pi = function(t, e, n, i, r, s) {
                    var o, a, l = 360,
                        c = D(r),
                        u = parseFloat(r) * (c && ~r.indexOf("rad") ? pn : 1),
                        h = s ? u * s : u - i,
                        d = i + h + "deg";
                    return c && ("short" === (o = r.split("_")[1]) && (h %= l) !== h % 180 && (h += h < 0 ? l : -360), "cw" === o && h < 0 ? h = (h + 36e9) % l - ~~(h / l) * l : "ccw" === o && h > 0 && (h = (h - 36e9) % l - ~~(h / l) * l)), t._pt = a = new Ke(t._pt, e, n, i, h, bn), a.e = d, a.u = "deg", t._props.push(n), a
                },
                fi = function(t, e, n) {
                    var i, r, s, o, a, l, c, u = cn.style,
                        h = n._gsap;
                    for (r in u.cssText = getComputedStyle(n).cssText + ";position:absolute;display:block;", u[Pn] = e, sn.body.appendChild(cn), i = ri(cn, 1), dn)(s = h[r]) !== (o = i[r]) && "perspective,force3D,transformOrigin,svgOrigin".indexOf(r) < 0 && (a = Gt(s) !== (c = Gt(o)) ? qn(n, r, s, c) : parseFloat(s), l = parseFloat(o), t._pt = new Ke(t._pt, h, r, a, l - a, _n), t._pt.u = c || 0, t._props.push(r));
                    sn.body.removeChild(cn)
                };
            at("padding,margin,Width,Radius", (function(t, e) {
                var n = "Top",
                    i = "Right",
                    r = "Bottom",
                    s = "Left",
                    o = (e < 3 ? [n, i, r, s] : [n + s, n + i, r + i, r + s]).map((function(n) {
                        return e < 2 ? t + n : "border" + n + t
                    }));
                Qn[e > 1 ? "border" + t : t] = function(t, e, n, i, r) {
                    var s, a;
                    if (arguments.length < 4) return s = o.map((function(e) {
                        return Xn(t, e, n)
                    })), 5 === (a = s.join(" ")).split(s[0]).length ? s[0] : a;
                    s = (i + "").split(" "), a = {}, o.forEach((function(t, e) {
                        return a[t] = s[e] = s[e] || s[(e - 1) / 2 | 0]
                    })), t.init(e, a, r)
                }
            }));
            var mi, gi, vi, yi = {
                name: "css",
                register: zn,
                targetTest: function(t) {
                    return t.style && t.nodeType
                },
                init: function(t, e, n, i, r) {
                    var s, o, a, l, c, u, h, d, p, f, m, v, y, x, _, b, w, M, S, E = this._props,
                        D = t.style,
                        T = n.vars.startAt;
                    for (h in an || zn(), e)
                        if ("autoRound" !== h && (o = e[h], !$[h] || !Fe(h, e, n, i, t, r)))
                            if (c = typeof o, u = Qn[h], "function" === c && (c = typeof(o = o.call(n, i, t, r))), "string" === c && ~o.indexOf("random(") && (o = $t(o)), u) u(this, t, h, o, n) && (_ = 1);
                            else if ("--" === h.substr(0, 2)) s = (getComputedStyle(t).getPropertyValue(h) + "").trim(), o += "", d = Gt(s), (p = Gt(o)) ? d !== p && (s = qn(t, h, s, p) + p) : d && (o += d), this.add(D, "setProperty", s, o, i, r, 0, 0, h);
                    else if ("undefined" !== c) {
                        if (T && h in T ? (s = "function" == typeof T[h] ? T[h].call(n, i, t, r) : T[h], h in g.units && !Gt(s) && (s += g.units[h]), "=" === (s + "").charAt(1) && (s = Xn(t, h))) : s = Xn(t, h), l = parseFloat(s), (f = "string" === c && "=" === o.charAt(1) ? +(o.charAt(0) + "1") : 0) && (o = o.substr(2)), a = parseFloat(o), h in xn && ("autoAlpha" === h && (1 === l && "hidden" === Xn(t, "visibility") && a && (l = 0), Vn(this, D, "visibility", l ? "inherit" : "hidden", a ? "inherit" : "hidden", !a)), "scale" !== h && "transform" !== h && ~(h = xn[h]).indexOf(",") && (h = h.split(",")[0])), m = h in dn)
                            if (v || ((y = t._gsap).renderTransform && !e.parseTransform || ri(t, e.parseTransform), x = !1 !== e.smoothOrigin && y.smooth, (v = this._pt = new Ke(this._pt, D, Pn, 0, 1, y.renderTransform, y, 0, -1)).dep = 1), "scale" === h) this._pt = new Ke(this._pt, y, "scaleY", y.scaleY, f ? f * a : a - y.scaleY), E.push("scaleY", h), h += "X";
                            else {
                                if ("transformOrigin" === h) {
                                    w = void 0, M = void 0, S = void 0, w = (b = o).split(" "), M = w[0], S = w[1] || "50%", "top" !== M && "bottom" !== M && "left" !== S && "right" !== S || (b = M, M = S, S = b), w[0] = Zn[M] || M, w[1] = Zn[S] || S, o = w.join(" "), y.svg ? ii(t, o, 0, x, 0, this) : ((p = parseFloat(o.split(" ")[2]) || 0) !== y.zOrigin && Vn(this, y, "zOrigin", y.zOrigin, p), Vn(this, D, h, si(s), si(o)));
                                    continue
                                }
                                if ("svgOrigin" === h) {
                                    ii(t, o, 1, x, 0, this);
                                    continue
                                }
                                if (h in $n) {
                                    pi(this, y, h, l, o, f);
                                    continue
                                }
                                if ("smoothOrigin" === h) {
                                    Vn(this, y, "smooth", y.smooth, o);
                                    continue
                                }
                                if ("force3D" === h) {
                                    y[h] = o;
                                    continue
                                }
                                if ("transform" === h) {
                                    fi(this, o, t);
                                    continue
                                }
                            }
                        else h in D || (h = Bn(h) || h);
                        if (m || (a || 0 === a) && (l || 0 === l) && !yn.test(o) && h in D) a || (a = 0), (d = (s + "").substr((l + "").length)) !== (p = Gt(o) || (h in g.units ? g.units[h] : d)) && (l = qn(t, h, s, p)), this._pt = new Ke(this._pt, m ? y : D, h, l, f ? f * a : a - l, m || "px" !== p && "zIndex" !== h || !1 === e.autoRound ? _n : Mn), this._pt.u = p || 0, d !== p && (this._pt.b = s, this._pt.r = wn);
                        else if (h in D) Yn.call(this, t, h, s, o);
                        else {
                            if (!(h in t)) {
                                q(h, o);
                                continue
                            }
                            this.add(t, h, t[h], o, i, r)
                        }
                        E.push(h)
                    }
                    _ && Qe(this)
                },
                get: Xn,
                aliases: xn,
                getSetter: function(t, e, n) {
                    var i = xn[e];
                    return i && i.indexOf(",") < 0 && (e = i), e in dn && e !== Fn && (t._gsap.x || Xn(t, "x")) ? n && un === n ? "scale" === e ? Cn : An : (un = n || {}) && ("scale" === e ? Ln : Rn) : t.style && !C(t.style[e]) ? Dn : ~e.indexOf("-") ? Tn : We(t, e)
                },
                core: {
                    _removeProperty: Wn,
                    _getMatrix: ni
                }
            };
            nn.utils.checkPrefix = Bn, vi = at((mi = "x,y,z,scale,scaleX,scaleY,xPercent,yPercent") + "," + (gi = "rotation,rotationX,rotationY,skewX,skewY") + ",transform,transformOrigin,svgOrigin,force3D,smoothOrigin,transformPerspective", (function(t) {
                dn[t] = 1
            })), at(gi, (function(t) {
                g.units[t] = "deg", $n[t] = 1
            })), xn[vi[13]] = mi + "," + gi, at("0:translateX,1:translateY,2:translateZ,8:rotate,8:rotationZ,8:rotateZ,9:rotateX,10:rotateY", (function(t) {
                var e = t.split(":");
                xn[e[1]] = vi[e[0]]
            })), at("x,y,z,top,right,bottom,left,width,height,fontSize,padding,margin,perspective", (function(t) {
                g.units[t] = "px"
            })), nn.registerPlugin(yi);
            var xi = nn.registerPlugin(yi) || nn,
                _i = (xi.core.Tween, /[achlmqstvz]|(-?\d*\.?\d*(?:e[\-+]?\d+)?)[0-9]/gi),
                bi = /[\+\-]?\d*\.?\d+e[\+\-]?\d+/gi,
                wi = Math.PI / 180,
                Mi = (Math.PI, Math.sin),
                Si = Math.cos,
                Ei = Math.abs,
                Di = Math.sqrt,
                Ti = (Math.atan2, function(t) {
                    return "number" == typeof t
                }),
                Ai = 1e5,
                Ci = function(t) {
                    return Math.round(t * Ai) / Ai || 0
                };

            function Li(t, e, n, i, r, s, o, a, l) {
                if (t !== a || e !== l) {
                    n = Ei(n), i = Ei(i);
                    var c = r % 360 * wi,
                        u = Si(c),
                        h = Mi(c),
                        d = Math.PI,
                        p = 2 * d,
                        f = (t - a) / 2,
                        m = (e - l) / 2,
                        g = u * f + h * m,
                        v = -h * f + u * m,
                        y = g * g,
                        x = v * v,
                        _ = y / (n * n) + x / (i * i);
                    _ > 1 && (n = Di(_) * n, i = Di(_) * i);
                    var b = n * n,
                        w = i * i,
                        M = (b * w - b * x - w * y) / (b * x + w * y);
                    M < 0 && (M = 0);
                    var S = (s === o ? -1 : 1) * Di(M),
                        E = S * (n * v / i),
                        D = S * (-i * g / n),
                        T = (t + a) / 2 + (u * E - h * D),
                        A = (e + l) / 2 + (h * E + u * D),
                        C = (g - E) / n,
                        L = (v - D) / i,
                        R = (-g - E) / n,
                        P = (-v - D) / i,
                        F = C * C + L * L,
                        O = (L < 0 ? -1 : 1) * Math.acos(C / Di(F)),
                        I = (C * P - L * R < 0 ? -1 : 1) * Math.acos((C * R + L * P) / Di(F * (R * R + P * P)));
                    isNaN(I) && (I = d), !o && I > 0 ? I -= p : o && I < 0 && (I += p), O %= p, I %= p;
                    var N, B = Math.ceil(Ei(I) / (p / 4)),
                        z = [],
                        k = I / B,
                        H = 4 / 3 * Mi(k / 2) / (1 + Si(k / 2)),
                        U = u * n,
                        G = h * n,
                        W = h * -i,
                        V = u * i;
                    for (N = 0; N < B; N++) g = Si(r = O + N * k), v = Mi(r), C = Si(r += k), L = Mi(r), z.push(g - H * v, v + H * g, C + H * L, L - H * C, C, L);
                    for (N = 0; N < z.length; N += 2) g = z[N], v = z[N + 1], z[N] = g * U + v * W + T, z[N + 1] = g * G + v * V + A;
                    return z[N - 2] = a, z[N - 1] = l, z
                }
            }

            function Ri(t) {
                var e, n, i, r, s, o, a, l, c, u, h, d, p, f, m, g = (t + "").replace(bi, (function(t) {
                        var e = +t;
                        return e < 1e-4 && e > -1e-4 ? 0 : e
                    })).match(_i) || [],
                    v = [],
                    y = 0,
                    x = 0,
                    _ = 2 / 3,
                    b = g.length,
                    w = 0,
                    M = "ERROR: malformed path: " + t,
                    S = function(t, e, n, i) {
                        u = (n - t) / 3, h = (i - e) / 3, a.push(t + u, e + h, n - u, i - h, n, i)
                    };
                if (!t || !isNaN(g[0]) || isNaN(g[1])) return console.log(M), v;
                for (e = 0; e < b; e++)
                    if (p = s, isNaN(g[e]) ? o = (s = g[e].toUpperCase()) !== g[e] : e--, i = +g[e + 1], r = +g[e + 2], o && (i += y, r += x), e || (l = i, c = r), "M" === s) a && (a.length < 8 ? v.length -= 1 : w += a.length), y = l = i, x = c = r, a = [i, r], v.push(a), e += 2, s = "L";
                    else if ("C" === s) a || (a = [0, 0]), o || (y = x = 0), a.push(i, r, y + 1 * g[e + 3], x + 1 * g[e + 4], y += 1 * g[e + 5], x += 1 * g[e + 6]), e += 6;
                else if ("S" === s) u = y, h = x, "C" !== p && "S" !== p || (u += y - a[a.length - 4], h += x - a[a.length - 3]), o || (y = x = 0), a.push(u, h, i, r, y += 1 * g[e + 3], x += 1 * g[e + 4]), e += 4;
                else if ("Q" === s) u = y + (i - y) * _, h = x + (r - x) * _, o || (y = x = 0), y += 1 * g[e + 3], x += 1 * g[e + 4], a.push(u, h, y + (i - y) * _, x + (r - x) * _, y, x), e += 4;
                else if ("T" === s) u = y - a[a.length - 4], h = x - a[a.length - 3], a.push(y + u, x + h, i + (y + 1.5 * u - i) * _, r + (x + 1.5 * h - r) * _, y = i, x = r), e += 2;
                else if ("H" === s) S(y, x, y = i, x), e += 1;
                else if ("V" === s) S(y, x, y, x = i + (o ? x - y : 0)), e += 1;
                else if ("L" === s || "Z" === s) "Z" === s && (i = l, r = c, a.closed = !0), ("L" === s || Ei(y - i) > .5 || Ei(x - r) > .5) && (S(y, x, i, r), "L" === s && (e += 2)), y = i, x = r;
                else if ("A" === s) {
                    if (f = g[e + 4], m = g[e + 5], u = g[e + 6], h = g[e + 7], n = 7, f.length > 1 && (f.length < 3 ? (h = u, u = m, n--) : (h = m, u = f.substr(2), n -= 2), m = f.charAt(1), f = f.charAt(0)), d = Li(y, x, +g[e + 1], +g[e + 2], +g[e + 3], +f, +m, (o ? y : 0) + 1 * u, (o ? x : 0) + 1 * h), e += n, d)
                        for (n = 0; n < d.length; n++) a.push(d[n]);
                    y = a[a.length - 2], x = a[a.length - 1]
                } else console.log(M);
                return (e = a.length) < 6 ? (v.pop(), e = 0) : a[0] === a[e - 2] && a[1] === a[e - 1] && (a.closed = !0), v.totalPoints = w + e, v
            }

            function Pi(t) {
                Ti(t[0]) && (t = [t]);
                var e, n, i, r, s = "",
                    o = t.length;
                for (n = 0; n < o; n++) {
                    for (r = t[n], s += "M" + Ci(r[0]) + "," + Ci(r[1]) + " C", e = r.length, i = 2; i < e; i++) s += Ci(r[i++]) + "," + Ci(r[i++]) + " " + Ci(r[i++]) + "," + Ci(r[i++]) + " " + Ci(r[i++]) + "," + Ci(r[i]) + " ";
                    r.closed && (s += "z")
                }
                return s
            }
            var Fi, Oi, Ii = function() {
                    return Fi || "undefined" != typeof window && (Fi = window.gsap) && Fi.registerPlugin && Fi
                },
                Ni = function() {
                    (Fi = Ii()) ? (Fi.registerEase("_CE", Ui.create), Oi = 1) : console.warn("Please gsap.registerPlugin(CustomEase)")
                },
                Bi = function(t) {
                    return ~~(1e3 * t + (t < 0 ? -.5 : .5)) / 1e3
                },
                zi = /[-+=\.]*\d+[\.e\-\+]*\d*[e\-\+]*\d*/gi,
                ki = /[cLlsSaAhHvVtTqQ]/g,
                Hi = function t(e, n, i, r, s, o, a, l, c, u, h) {
                    var d, p = (e + i) / 2,
                        f = (n + r) / 2,
                        m = (i + s) / 2,
                        g = (r + o) / 2,
                        v = (s + a) / 2,
                        y = (o + l) / 2,
                        x = (p + m) / 2,
                        _ = (f + g) / 2,
                        b = (m + v) / 2,
                        w = (g + y) / 2,
                        M = (x + b) / 2,
                        S = (_ + w) / 2,
                        E = a - e,
                        D = l - n,
                        T = Math.abs((i - a) * D - (r - l) * E),
                        A = Math.abs((s - a) * D - (o - l) * E);
                    return u || (u = [{
                        x: e,
                        y: n
                    }, {
                        x: a,
                        y: l
                    }], h = 1), u.splice(h || u.length - 1, 0, {
                        x: M,
                        y: S
                    }), (T + A) * (T + A) > c * (E * E + D * D) && (d = u.length, t(e, n, p, f, x, _, M, S, c, u, h), t(M, S, b, w, v, y, a, l, c, u, h + 1 + (u.length - d))), u
                },
                Ui = function() {
                    function t(t, e, n) {
                        Oi || Ni(), this.id = t, this.setData(e, n)
                    }
                    var e = t.prototype;
                    return e.setData = function(t, e) {
                        e = e || {};
                        var n, i, r, s, o, a, l, c, u, h = (t = t || "0,0,1,1").match(zi),
                            d = 1,
                            p = [],
                            f = [],
                            m = e.precision || 1,
                            g = m <= 1;
                        if (this.data = t, (ki.test(t) || ~t.indexOf("M") && t.indexOf("C") < 0) && (h = Ri(t)[0]), 4 === (n = h.length)) h.unshift(0, 0), h.push(1, 1), n = 8;
                        else if ((n - 2) % 6) throw "Invalid CustomEase";
                        for (0 == +h[0] && 1 == +h[n - 2] || function(t, e, n) {
                                n || 0 === n || (n = Math.max(+t[t.length - 1], +t[1]));
                                var i, r = -1 * +t[0],
                                    s = -n,
                                    o = t.length,
                                    a = 1 / (+t[o - 2] + r),
                                    l = -e || (Math.abs(+t[o - 1] - +t[1]) < .01 * (+t[o - 2] - +t[0]) ? function(t) {
                                        var e, n = t.length,
                                            i = 1e20;
                                        for (e = 1; e < n; e += 6) + t[e] < i && (i = +t[e]);
                                        return i
                                    }(t) + s : +t[o - 1] + s);
                                for (l = l ? 1 / l : -a, i = 0; i < o; i += 2) t[i] = (+t[i] + r) * a, t[i + 1] = (+t[i + 1] + s) * l
                            }(h, e.height, e.originY), this.segment = h, s = 2; s < n; s += 6) i = {
                            x: +h[s - 2],
                            y: +h[s - 1]
                        }, r = {
                            x: +h[s + 4],
                            y: +h[s + 5]
                        }, p.push(i, r), Hi(i.x, i.y, +h[s], +h[s + 1], +h[s + 2], +h[s + 3], r.x, r.y, 1 / (2e5 * m), p, p.length - 1);
                        for (n = p.length, s = 0; s < n; s++) l = p[s], c = p[s - 1] || l, (l.x > c.x || c.y !== l.y && c.x === l.x || l === c) && l.x <= 1 ? (c.cx = l.x - c.x, c.cy = l.y - c.y, c.n = l, c.nx = l.x, g && s > 1 && Math.abs(c.cy / c.cx - p[s - 2].cy / p[s - 2].cx) > 2 && (g = 0), c.cx < d && (c.cx ? d = c.cx : (c.cx = .001, s === n - 1 && (c.x -= .001, d = Math.min(d, .001), g = 0)))) : (p.splice(s--, 1), n--);
                        if (o = 1 / (n = 1 / d + 1 | 0), a = 0, l = p[0], g) {
                            for (s = 0; s < n; s++) u = s * o, l.nx < u && (l = p[++a]), i = l.y + (u - l.x) / l.cx * l.cy, f[s] = {
                                x: u,
                                cx: o,
                                y: i,
                                cy: 0,
                                nx: 9
                            }, s && (f[s - 1].cy = i - f[s - 1].y);
                            f[n - 1].cy = p[p.length - 1].y - i
                        } else {
                            for (s = 0; s < n; s++) l.nx < s * o && (l = p[++a]), f[s] = l;
                            a < p.length - 1 && (f[s - 1] = p[p.length - 2])
                        }
                        return this.ease = function(t) {
                            var e = f[t * n | 0] || f[n - 1];
                            return e.nx < t && (e = e.n), e.y + (t - e.x) / e.cx * e.cy
                        }, this.ease.custom = this, this.id && Fi.registerEase(this.id, this.ease), this
                    }, e.getSVGData = function(e) {
                        return t.getSVGData(this, e)
                    }, t.create = function(e, n, i) {
                        return new t(e, n, i).ease
                    }, t.register = function(t) {
                        Fi = t, Ni()
                    }, t.get = function(t) {
                        return Fi.parseEase(t)
                    }, t.getSVGData = function(e, n) {
                        var i, r, s, o, a, l, c, u, h, d, p = (n = n || {}).width || 100,
                            f = n.height || 100,
                            m = n.x || 0,
                            g = (n.y || 0) + f,
                            v = Fi.utils.toArray(n.path)[0];
                        if (n.invert && (f = -f, g = 0), "string" == typeof e && (e = Fi.parseEase(e)), e.custom && (e = e.custom), e instanceof t) i = Pi(function(t, e, n, i, r, s, o) {
                            for (var a, l, c, u, h, d = t.length; --d > -1;)
                                for (l = (a = t[d]).length, c = 0; c < l; c += 2) u = a[c], h = a[c + 1], a[c] = u * e + h * i + s, a[c + 1] = u * n + h * r + o;
                            return t._dirty = 1, t
                        }([e.segment], p, 0, 0, -f, m, g));
                        else {
                            for (i = [m, g], o = 1 / (c = Math.max(5, 200 * (n.precision || 1))), u = 5 / (c += 2), h = Bi(m + o * p), r = ((d = Bi(g + e(o) * -f)) - g) / (h - m), s = 2; s < c; s++) a = Bi(m + s * o * p), l = Bi(g + e(s * o) * -f), (Math.abs((l - d) / (a - h) - r) > u || s === c - 1) && (i.push(h, d), r = (l - d) / (a - h)), h = a, d = l;
                            i = "M" + i.join(",")
                        }
                        return v && v.setAttribute("d", i), i
                    }, t
                }();
            Ii() && Fi.registerPlugin(Ui), Ui.version = "3.6.0";
            var Gi = /([\uD800-\uDBFF][\uDC00-\uDFFF](?:[\u200D\uFE0F][\uD800-\uDBFF][\uDC00-\uDFFF]){2,}|\uD83D\uDC69(?:\u200D(?:(?:\uD83D\uDC69\u200D)?\uD83D\uDC67|(?:\uD83D\uDC69\u200D)?\uD83D\uDC66)|\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC69\u200D(?:\uD83D\uDC69\u200D)?\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC69\u200D(?:\uD83D\uDC69\u200D)?\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|\uD83C\uDFF3\uFE0F\u200D\uD83C\uDF08|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]\uFE0F|\uD83D\uDC69(?:\uD83C[\uDFFB-\uDFFF])\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92])|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC6F\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3C-\uDD3E\uDDD6-\uDDDF])\u200D[\u2640\u2642]\uFE0F|\uD83C\uDDFD\uD83C\uDDF0|\uD83C\uDDF6\uD83C\uDDE6|\uD83C\uDDF4\uD83C\uDDF2|\uD83C\uDDE9(?:\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF])|\uD83C\uDDF7(?:\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC])|\uD83C\uDDE8(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF])|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uFE0F\u200D[\u2640\u2642]|(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642])\uFE0F|(?:\uD83D\uDC41\uFE0F\u200D\uD83D\uDDE8|\uD83D\uDC69(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2695\u2696\u2708]|\uD83D\uDC69\u200D[\u2695\u2696\u2708]|\uD83D\uDC68(?:(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708]))\uFE0F|\uD83C\uDDF2(?:\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF])|\uD83D\uDC69\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69]))|\uD83C\uDDF1(?:\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE])|\uD83C\uDDEF(?:\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5])|\uD83C\uDDED(?:\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA])|\uD83C\uDDEB(?:\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7])|[#\*0-9]\uFE0F\u20E3|\uD83C\uDDE7(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF])|\uD83C\uDDE6(?:\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF])|\uD83C\uDDFF(?:\uD83C[\uDDE6\uDDF2\uDDFC])|\uD83C\uDDF5(?:\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE])|\uD83C\uDDFB(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA])|\uD83C\uDDF3(?:\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF])|\uD83C\uDFF4\uDB40\uDC67\uDB40\uDC62(?:\uDB40\uDC77\uDB40\uDC6C\uDB40\uDC73|\uDB40\uDC73\uDB40\uDC63\uDB40\uDC74|\uDB40\uDC65\uDB40\uDC6E\uDB40\uDC67)\uDB40\uDC7F|\uD83D\uDC68(?:\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83D\uDC68|(?:(?:\uD83D[\uDC68\uDC69])\u200D)?\uD83D\uDC66\u200D\uD83D\uDC66|(?:(?:\uD83D[\uDC68\uDC69])\u200D)?\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92])|(?:\uD83C[\uDFFB-\uDFFF])\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]))|\uD83C\uDDF8(?:\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF])|\uD83C\uDDF0(?:\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF])|\uD83C\uDDFE(?:\uD83C[\uDDEA\uDDF9])|\uD83C\uDDEE(?:\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9])|\uD83C\uDDF9(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF])|\uD83C\uDDEC(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE])|\uD83C\uDDFA(?:\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF])|\uD83C\uDDEA(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA])|\uD83C\uDDFC(?:\uD83C[\uDDEB\uDDF8])|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uD83C[\uDFFB-\uDFFF])|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u261D\u270A-\u270D]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC70\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDCAA\uDD74\uDD7A\uDD90\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD36\uDDD1-\uDDD5])(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC68(?:\u200D(?:(?:(?:\uD83D[\uDC68\uDC69])\u200D)?\uD83D\uDC67|(?:(?:\uD83D[\uDC68\uDC69])\u200D)?\uD83D\uDC66)|\uD83C[\uDFFB-\uDFFF])|(?:[\u261D\u26F9\u270A-\u270D]|\uD83C[\uDF85\uDFC2-\uDFC4\uDFC7\uDFCA-\uDFCC]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66-\uDC69\uDC6E\uDC70-\uDC78\uDC7C\uDC81-\uDC83\uDC85-\uDC87\uDCAA\uDD74\uDD75\uDD7A\uDD90\uDD95\uDD96\uDE45-\uDE47\uDE4B-\uDE4F\uDEA3\uDEB4-\uDEB6\uDEC0\uDECC]|\uD83E[\uDD18-\uDD1C\uDD1E\uDD1F\uDD26\uDD30-\uDD39\uDD3D\uDD3E\uDDD1-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])?|(?:[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u270A\u270B\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF93\uDFA0-\uDFCA\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF4\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC3E\uDC40\uDC42-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDD7A\uDD95\uDD96\uDDA4\uDDFB-\uDE4F\uDE80-\uDEC5\uDECC\uDED0-\uDED2\uDEEB\uDEEC\uDEF4-\uDEF8]|\uD83E[\uDD10-\uDD3A\uDD3C-\uDD3E\uDD40-\uDD45\uDD47-\uDD4C\uDD50-\uDD6B\uDD80-\uDD97\uDDC0\uDDD0-\uDDE6])|(?:[#\*0-9\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u261D\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u2660\u2663\u2665\u2666\u2668\u267B\u267F\u2692-\u2697\u2699\u269B\u269C\u26A0\u26A1\u26AA\u26AB\u26B0\u26B1\u26BD\u26BE\u26C4\u26C5\u26C8\u26CE\u26CF\u26D1\u26D3\u26D4\u26E9\u26EA\u26F0-\u26F5\u26F7-\u26FA\u26FD\u2702\u2705\u2708-\u270D\u270F\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763\u2764\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC04\uDCCF\uDD70\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE02\uDE1A\uDE2F\uDE32-\uDE3A\uDE50\uDE51\uDF00-\uDF21\uDF24-\uDF93\uDF96\uDF97\uDF99-\uDF9B\uDF9E-\uDFF0\uDFF3-\uDFF5\uDFF7-\uDFFF]|\uD83D[\uDC00-\uDCFD\uDCFF-\uDD3D\uDD49-\uDD4E\uDD50-\uDD67\uDD6F\uDD70\uDD73-\uDD7A\uDD87\uDD8A-\uDD8D\uDD90\uDD95\uDD96\uDDA4\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA-\uDE4F\uDE80-\uDEC5\uDECB-\uDED2\uDEE0-\uDEE5\uDEE9\uDEEB\uDEEC\uDEF0\uDEF3-\uDEF8]|\uD83E[\uDD10-\uDD3A\uDD3C-\uDD3E\uDD40-\uDD45\uDD47-\uDD4C\uDD50-\uDD6B\uDD80-\uDD97\uDDC0\uDDD0-\uDDE6])\uFE0F)/;

            function Wi(t) {
                var e = t.nodeType,
                    n = "";
                if (1 === e || 9 === e || 11 === e) {
                    if ("string" == typeof t.textContent) return t.textContent;
                    for (t = t.firstChild; t; t = t.nextSibling) n += Wi(t)
                } else if (3 === e || 4 === e) return t.nodeValue;
                return n
            }
            var Vi, ji, qi, Xi = /(?:\r|\n|\t\t)/g,
                Yi = /(?:\s\s+)/g,
                Zi = function(t) {
                    return ji.getComputedStyle(t)
                },
                Ji = Array.isArray,
                Qi = [].slice,
                Ki = function(t, e) {
                    var n;
                    return Ji(t) ? t : "string" == (n = typeof t) && !e && t ? Qi.call(Vi.querySelectorAll(t), 0) : t && "object" === n && "length" in t ? Qi.call(t, 0) : t ? [t] : []
                },
                $i = function(t) {
                    return "absolute" === t.position || !0 === t.absolute
                },
                tr = function(t, e) {
                    for (var n, i = e.length; --i > -1;)
                        if (n = e[i], t.substr(0, n.length) === n) return n.length
                },
                er = function(t, e) {
                    void 0 === t && (t = "");
                    var n = ~t.indexOf("++"),
                        i = 1;
                    return n && (t = t.split("++").join("")),
                        function() {
                            return "<" + e + " style='position:relative;display:inline-block;'" + (t ? " class='" + t + (n ? i++ : "") + "'>" : ">")
                        }
                },
                nr = function t(e, n, i) {
                    var r = e.nodeType;
                    if (1 === r || 9 === r || 11 === r)
                        for (e = e.firstChild; e; e = e.nextSibling) t(e, n, i);
                    else 3 !== r && 4 !== r || (e.nodeValue = e.nodeValue.split(n).join(i))
                },
                ir = function(t, e) {
                    for (var n = e.length; --n > -1;) t.push(e[n])
                },
                rr = function(t, e, n) {
                    for (var i; t && t !== e;) {
                        if (i = t._next || t.nextSibling) return i.textContent.charAt(0) === n;
                        t = t.parentNode || t._parent
                    }
                },
                sr = function t(e) {
                    var n, i, r = Ki(e.childNodes),
                        s = r.length;
                    for (n = 0; n < s; n++)(i = r[n])._isSplit ? t(i) : n && i.previousSibling && 3 === i.previousSibling.nodeType ? (i.previousSibling.nodeValue += 3 === i.nodeType ? i.nodeValue : i.firstChild.nodeValue, e.removeChild(i)) : 3 !== i.nodeType && (e.insertBefore(i.firstChild, i), e.removeChild(i))
                },
                or = function(t, e) {
                    return parseFloat(e[t]) || 0
                },
                ar = function(t, e, n, i, r, s, o) {
                    var a, l, c, u, h, d, p, f, m, g, v, y, x = Zi(t),
                        _ = or("paddingLeft", x),
                        b = -999,
                        w = or("borderBottomWidth", x) + or("borderTopWidth", x),
                        M = or("borderLeftWidth", x) + or("borderRightWidth", x),
                        S = or("paddingTop", x) + or("paddingBottom", x),
                        E = or("paddingLeft", x) + or("paddingRight", x),
                        D = or("fontSize", x) * (e.lineThreshold || .2),
                        T = x.textAlign,
                        A = [],
                        C = [],
                        L = [],
                        R = e.wordDelimiter || " ",
                        P = e.tag ? e.tag : e.span ? "span" : "div",
                        F = e.type || e.split || "chars,words,lines",
                        O = r && ~F.indexOf("lines") ? [] : null,
                        I = ~F.indexOf("words"),
                        N = ~F.indexOf("chars"),
                        B = $i(e),
                        z = e.linesClass,
                        k = ~(z || "").indexOf("++"),
                        H = [];
                    for (k && (z = z.split("++").join("")), c = (l = t.getElementsByTagName("*")).length, h = [], a = 0; a < c; a++) h[a] = l[a];
                    if (O || B)
                        for (a = 0; a < c; a++)((d = (u = h[a]).parentNode === t) || B || N && !I) && (y = u.offsetTop, O && d && Math.abs(y - b) > D && ("BR" !== u.nodeName || 0 === a) && (p = [], O.push(p), b = y), B && (u._x = u.offsetLeft, u._y = y, u._w = u.offsetWidth, u._h = u.offsetHeight), O && ((u._isSplit && d || !N && d || I && d || !I && u.parentNode.parentNode === t && !u.parentNode._isSplit) && (p.push(u), u._x -= _, rr(u, t, R) && (u._wordEnd = !0)), "BR" === u.nodeName && (u.nextSibling && "BR" === u.nextSibling.nodeName || 0 === a) && O.push([])));
                    for (a = 0; a < c; a++)
                        if (d = (u = h[a]).parentNode === t, "BR" !== u.nodeName)
                            if (B && (m = u.style, I || d || (u._x += u.parentNode._x, u._y += u.parentNode._y), m.left = u._x + "px", m.top = u._y + "px", m.position = "absolute", m.display = "block", m.width = u._w + 1 + "px", m.height = u._h + "px"), !I && N)
                                if (u._isSplit)
                                    for (u._next = l = u.nextSibling, u.parentNode.appendChild(u); l && 3 === l.nodeType && " " === l.textContent;) u._next = l.nextSibling, u.parentNode.appendChild(l), l = l.nextSibling;
                                else u.parentNode._isSplit ? (u._parent = u.parentNode, !u.previousSibling && u.firstChild && (u.firstChild._isFirst = !0), u.nextSibling && " " === u.nextSibling.textContent && !u.nextSibling.nextSibling && H.push(u.nextSibling), u._next = u.nextSibling && u.nextSibling._isFirst ? null : u.nextSibling, u.parentNode.removeChild(u), h.splice(a--, 1), c--) : d || (y = !u.nextSibling && rr(u.parentNode, t, R), u.parentNode._parent && u.parentNode._parent.appendChild(u), y && u.parentNode.appendChild(Vi.createTextNode(" ")), "span" === P && (u.style.display = "inline"), A.push(u));
                    else u.parentNode._isSplit && !u._isSplit && "" !== u.innerHTML ? C.push(u) : N && !u._isSplit && ("span" === P && (u.style.display = "inline"), A.push(u));
                    else O || B ? (u.parentNode && u.parentNode.removeChild(u), h.splice(a--, 1), c--) : I || t.appendChild(u);
                    for (a = H.length; --a > -1;) H[a].parentNode.removeChild(H[a]);
                    if (O) {
                        for (B && (g = Vi.createElement(P), t.appendChild(g), v = g.offsetWidth + "px", y = g.offsetParent === t ? 0 : t.offsetLeft, t.removeChild(g)), m = t.style.cssText, t.style.cssText = "display:none;"; t.firstChild;) t.removeChild(t.firstChild);
                        for (f = " " === R && (!B || !I && !N), a = 0; a < O.length; a++) {
                            for (p = O[a], (g = Vi.createElement(P)).style.cssText = "display:block;text-align:" + T + ";position:" + (B ? "absolute;" : "relative;"), z && (g.className = z + (k ? a + 1 : "")), L.push(g), c = p.length, l = 0; l < c; l++) "BR" !== p[l].nodeName && (u = p[l], g.appendChild(u), f && u._wordEnd && g.appendChild(Vi.createTextNode(" ")), B && (0 === l && (g.style.top = u._y + "px", g.style.left = _ + y + "px"), u.style.top = "0px", y && (u.style.left = u._x - y + "px")));
                            0 === c ? g.innerHTML = "&nbsp;" : I || N || (sr(g), nr(g, String.fromCharCode(160), " ")), B && (g.style.width = v, g.style.height = u._h + "px"), t.appendChild(g)
                        }
                        t.style.cssText = m
                    }
                    B && (o > t.clientHeight && (t.style.height = o - S + "px", t.clientHeight < o && (t.style.height = o + w + "px")), s > t.clientWidth && (t.style.width = s - E + "px", t.clientWidth < s && (t.style.width = s + M + "px"))), ir(n, A), I && ir(i, C), ir(r, L)
                },
                lr = function(t, e, n, i) {
                    var r, s, o, a, l, c, u, h, d = e.tag ? e.tag : e.span ? "span" : "div",
                        p = ~(e.type || e.split || "chars,words,lines").indexOf("chars"),
                        f = $i(e),
                        m = e.wordDelimiter || " ",
                        g = " " !== m ? "" : f ? "&#173; " : " ",
                        v = "</" + d + ">",
                        y = 1,
                        x = e.specialChars ? "function" == typeof e.specialChars ? e.specialChars : tr : null,
                        _ = Vi.createElement("div"),
                        b = t.parentNode;
                    for (b.insertBefore(_, t), _.textContent = t.nodeValue, b.removeChild(t), u = -1 !== (r = Wi(t = _)).indexOf("<"), !1 !== e.reduceWhiteSpace && (r = r.replace(Yi, " ").replace(Xi, "")), u && (r = r.split("<").join("{{LT}}")), l = r.length, s = (" " === r.charAt(0) ? g : "") + n(), o = 0; o < l; o++)
                        if (c = r.charAt(o), x && (h = x(r.substr(o), e.specialChars))) c = r.substr(o, h || 1), s += p && " " !== c ? i() + c + "</" + d + ">" : c, o += h - 1;
                        else if (c === m && r.charAt(o - 1) !== m && o) {
                        for (s += y ? v : "", y = 0; r.charAt(o + 1) === m;) s += g, o++;
                        o === l - 1 ? s += g : ")" !== r.charAt(o + 1) && (s += g + n(), y = 1)
                    } else "{" === c && "{{LT}}" === r.substr(o, 6) ? (s += p ? i() + "{{LT}}</" + d + ">" : "{{LT}}", o += 5) : c.charCodeAt(0) >= 55296 && c.charCodeAt(0) <= 56319 || r.charCodeAt(o + 1) >= 65024 && r.charCodeAt(o + 1) <= 65039 ? (a = ((r.substr(o, 12).split(Gi) || [])[1] || "").length || 2, s += p && " " !== c ? i() + r.substr(o, a) + "</" + d + ">" : r.substr(o, a), o += a - 1) : s += p && " " !== c ? i() + c + "</" + d + ">" : c;
                    t.outerHTML = s + (y ? v : ""), u && nr(b, "{{LT}}", "<")
                },
                cr = function t(e, n, i, r) {
                    var s, o, a = Ki(e.childNodes),
                        l = a.length,
                        c = $i(n);
                    if (3 !== e.nodeType || l > 1) {
                        for (n.absolute = !1, s = 0; s < l; s++)(o = a[s])._next = o._isFirst = o._parent = o._wordEnd = null, (3 !== o.nodeType || /\S+/.test(o.nodeValue)) && (c && 3 !== o.nodeType && "inline" === Zi(o).display && (o.style.display = "inline-block", o.style.position = "relative"), o._isSplit = !0, t(o, n, i, r));
                        return n.absolute = c, void(e._isSplit = !0)
                    }
                    lr(e, n, i, r)
                },
                ur = function() {
                    function t(t, e) {
                        qi || (Vi = document, ji = window, qi = 1), this.elements = Ki(t), this.chars = [], this.words = [], this.lines = [], this._originals = [], this.vars = e || {}, this.split(e)
                    }
                    var e = t.prototype;
                    return e.split = function(t) {
                        this.isSplit && this.revert(), this.vars = t = t || this.vars, this._originals.length = this.chars.length = this.words.length = this.lines.length = 0;
                        for (var e, n, i, r = this.elements.length, s = t.tag ? t.tag : t.span ? "span" : "div", o = er(t.wordsClass, s), a = er(t.charsClass, s); --r > -1;) i = this.elements[r], this._originals[r] = i.innerHTML, e = i.clientHeight, n = i.clientWidth, cr(i, t, o, a), ar(i, t, this.chars, this.words, this.lines, n, e);
                        return this.chars.reverse(), this.words.reverse(), this.lines.reverse(), this.isSplit = !0, this
                    }, e.revert = function() {
                        var t = this._originals;
                        if (!t) throw "revert() call wasn't scoped properly.";
                        return this.elements.forEach((function(e, n) {
                            return e.innerHTML = t[n]
                        })), this.chars = [], this.words = [], this.lines = [], this.isSplit = !1, this
                    }, t.create = function(e, n) {
                        return new t(e, n)
                    }, t
                }();
            ur.version = "3.6.0", xi.registerPlugin(Ui), xi.registerPlugin(ur), Ui.create("app.inOut", ".51,0,.58,1"), Ui.create("app.out", ".33,0,.18,1"), Ui.create("app.ease", ".33,0,.67,1");
            n(921);
            const hr = window.innerWidth,
                dr = window.innerHeight,
                pr = hr / 1440,
                fr = dr / 900,
                mr = window.innerWidth > 1100,
                gr = window.innerWidth < 740;
            /constructor/i.test(window.HTMLElement) || (!window.safari || "undefined" != typeof safari && window.safari.pushNotification).toString();

            function vr(t, e, n, i) {
                function r(t, e) {
                    return 1 - 3 * e + 3 * t
                }

                function s(t, e) {
                    return 3 * e - 6 * t
                }

                function o(t) {
                    return 3 * t
                }

                function a(t, e, n) {
                    return ((r(e, n) * t + s(e, n)) * t + o(e)) * t
                }

                function l(t, e, n) {
                    return 3 * r(e, n) * t * t + 2 * s(e, n) * t + o(e)
                }
                this.get = function(r) {
                    return t == e && n == i ? r : a(function(e) {
                        for (var i = e, r = 0; r < 4; ++r) {
                            var s = l(i, t, n);
                            if (0 == s) return i;
                            i -= (a(i, t, n) - e) / s
                        }
                        return i
                    }(r), e, i)
                }
            }

            function yr(t, e, n) {
                return mr && t ? t : gr && n ? n : e || 0
            }
            window.addEventListener("resize", function(t, e, n) {
                let i;
                return function() {
                    const r = this,
                        s = arguments,
                        o = function() {
                            i = null, n || t.apply(r, s)
                        },
                        a = n && !i;
                    clearTimeout(i), i = setTimeout(o, e), a && t.apply(r, s)
                }
            }((() => {
                const t = window.innerWidth > 1100;
                window.innerWidth === hr || !t && t === mr || setTimeout((() => {
                    window.location.reload()
                }), 0)
            }), 600));
            n(15);
            const xr = document.querySelectorAll(".cursor"),
                _r = document.querySelectorAll(".cursor-circle");
            let br = 1;
            const wr = (t, e) => {
                    xi.to(xr, {
                        x: t,
                        y: e,
                        duration: .8,
                        ease: "sine.out"
                    })
                },
                Mr = t => (t > 0 && (br = t), xi.to(_r, {
                    scale: t,
                    duration: 1.2,
                    ease: "app.ease"
                })),
                Sr = t => xi.from(t.chars, {
                    autoAlpha: 0,
                    duration: .8,
                    stagger: () => xi.utils.random(.1, .4),
                    ease: "app.out"
                }),
                Er = t => xi.from(t.lines, {
                    autoAlpha: 0,
                    y: 30,
                    duration: .4,
                    stagger: .1,
                    ease: "app.out"
                }),
                Dr = t => xi.from(t, {
                    scale: 0,
                    autoAlpha: 0,
                    duration: .4,
                    ease: "app.ease"
                }),
                Tr = t => xi.from(t, {
                    autoAlpha: 0,
                    y: 20,
                    duration: .4,
                    ease: "app.out"
                }),
                Ar = t => {
                    const e = t.querySelector("h2"),
                        n = t.querySelector(".content"),
                        i = new ur(e, {
                            type: "lines,chars"
                        }),
                        r = xi.timeline().from(e, {
                            x: -150,
                            duration: 1
                        }).add(Sr(i), "<").add(Tr(n), "<.6");
                    if (!mr) {
                        const e = t.querySelector(".thumbnail"),
                            n = t.querySelector("img"),
                            i = t.querySelector(".explore-btn");
                        r.add(Lr(e, n), "<-.6").add(Dr(i), "<.4")
                    }
                    return r
                },
                Cr = (t, e, n) => xi.timeline().to(t, {
                    y: "-100%",
                    duration: .62,
                    ease: "app.out"
                }).to(e, {
                    rotate: 15,
                    transformOrigin: "100% 50%",
                    duration: .62,
                    ease: "app.out"
                }, "<").from(n, {
                    rotate: 15,
                    transformOrigin: "0% 50%",
                    duration: .62,
                    ease: "app.out"
                }, "<"),
                Lr = (t, e) => {
                    let n = {
                        s: 0
                    };
                    return xi.set(t, {
                        scaleY: 0
                    }), xi.timeline().set(t, {
                        transformOrigin: "50% 100%"
                    }).set(e, {
                        transformOrigin: "50% 100%"
                    }).to(n, {
                        s: 1,
                        duration: .8,
                        ease: "app.out",
                        onUpdate: () => {
                            xi.set(t, {
                                scaleY: n.s
                            }), n.s && xi.set(e, {
                                scaleY: 1 / n.s
                            })
                        }
                    })
                },
                Rr = document.querySelector(".menu-btn");
            let Pr = null;
            const Fr = () => {
                    (() => {
                        const t = Rr.querySelector(".text"),
                            e = Rr.querySelector(".text-default"),
                            n = Rr.querySelector(".text-active"),
                            i = Rr.querySelector(".menu-btn_circle"),
                            r = Rr.querySelector(".menu-btn_close");
                        Pr = xi.timeline({
                            paused: 1
                        }).to(i, {
                            scale: 0,
                            duration: .4
                        }).from(r, {
                            scale: 0,
                            duration: .4
                        }, "<").add(Cr(t, e, n), "<")
                    })()
                },
                Or = document.querySelector(".menu-btn");
            let Ir = null;
            const Nr = () => {
                    (() => {
                        const t = Or.querySelector(".menu-btn_outer");
                        Ir = xi.timeline({
                            paused: 1
                        }).fromTo(t, {
                            scale: 1
                        }, {
                            scale: 80 / 120,
                            duration: .8,
                            ease: "app.ease"
                        }, "<")
                    })()
                },
                Br = document.querySelector(".menu-btn");
            let zr = null;
            const kr = () => {
                    (() => {
                        const t = Br.querySelector(".menu-btn_circles");
                        Br.querySelector(".menu-btn_circle"), zr = xi.timeline({
                            paused: 1,
                            repeat: -1
                        }).to(t, {
                            rotate: 360,
                            duration: 4,
                            ease: "app.out"
                        }, "<")
                    })()
                },
                Hr = document.querySelector(".menu"),
                Ur = document.querySelector(".menu-btn");
            let Gr = null,
                Wr = !1;
            const Vr = () => {
                    Fr(), Nr(), kr(), (() => {
                        const t = Hr.querySelector(".title"),
                            e = Hr.querySelectorAll("nav a, nav p"),
                            n = Hr.querySelectorAll(".footer a"),
                            i = Hr.querySelectorAll(".cookies.hi-mup a"),
                            r = new ur(t, {
                                type: "chars"
                            });
                        Pr.play(), Gr = xi.timeline({
                            paused: !Wr
                        }).add(Pr, "<").to(Hr, {
                            autoAlpha: 1,
                            duration: .4,
                            ease: "app.out"
                        }, "<").add(Sr(r), "<.2").from(e, {
                            autoAlpha: 0,
                            y: 30,
                            duration: .4,
                            stagger: .1,
                            ease: "app.out"
                        }, "<.4").from(n, {
                            autoAlpha: 0,
                            duration: .4,
                            stagger: .1,
                            ease: "app.ease"
                        }, "<.2").from(i, {
                            autoAlpha: 0,
                            duration: .4,
                            stagger: .1,
                            ease: "app.ease"
                        }, "<.2")
                    })(), Ur.addEventListener("click", (() => {
                        Wr ? (Wr = !1, Gr && Gr.reverse()) : (Wr = !0, Gr && Gr.play())
                    }));
                    const t = Ur.querySelector(".menu-btn_circles");
                    Ur.querySelector(".menu-btn_circle");
                    mr && (Ur.addEventListener("mouseenter", (() => {
                        Ir.play(), zr.play()
                    })), Ur.addEventListener("mouseleave", (() => {
                        Ir.reverse(), xi.to(t, {
                            rotate: 0,
                            duration: .8,
                            ease: "app.ease",
                            onStart: () => {
                                zr.pause()
                            },
                            onComplete: () => {
                                zr.progress(0)
                            }
                        })
                    })))
                },
                jr = document.querySelector(".menu nav"),
                qr = jr.querySelectorAll("a, p"),
                Xr = document.querySelectorAll(".menu .images"),
                Yr = document.querySelectorAll(".menu img"),
                Zr = () => {
                    mr && (qr.forEach(((t, e) => {
                        const n = (i = e, xi.timeline({
                            paused: 1
                        }).from(Yr[i], {
                            autoAlpha: 0,
                            duration: .6,
                            ease: "app.ease"
                        }, "<"));
                        var i;
                        t.addEventListener("mouseenter", (() => {
                            xi.to(qr, {
                                opacity: .2,
                                duration: .4,
                                ease: "app.ease"
                            }), xi.to(t, {
                                opacity: 1,
                                duration: .4,
                                ease: "app.ease"
                            }), n.play()
                        })), t.addEventListener("mouseleave", (() => {
                            n.reverse()
                        }))
                    })), jr.addEventListener("mouseleave", (() => {
                        xi.to(qr, {
                            opacity: 1,
                            duration: .4,
                            ease: "app.ease"
                        })
                    })), window.addEventListener("mousemove", (t => {
                        var e, n;
                        e = t.clientX, n = t.clientY, xi.to(Xr, {
                            x: e,
                            y: n,
                            duration: .8,
                            ease: "sine.out"
                        })
                    })))
                },
                Jr = t => {
                    const e = t.querySelector(".text"),
                        n = t.querySelector(".text-default"),
                        i = t.querySelector(".text-hover");
                    return xi.timeline({
                        paused: 1
                    }).add(Cr(e, n, i), "<")
                },
                Qr = document.querySelectorAll("header .swap-btn, .preloader .swap-btn, .menu .swap-btn");
            let Kr = document.querySelectorAll(".active-container .swap-btn"),
                $r = [],
                ts = [];
            const es = () => {
                Kr = document.querySelectorAll(".active-container .swap-btn"), Kr.length && Kr.forEach(((t, e) => {
                    ts[e] = Jr(t), t.addEventListener("mouseenter", (t => {
                        ts[e].play()
                    })), t.addEventListener("mouseleave", (t => {
                        ts[e].reverse()
                    }))
                }))
            };
            let ns = document.querySelectorAll(".sound-btn div"),
                is = null;
            const rs = t => {
                    const e = xi.timeline({});
                    return ns.forEach(((n, i) => {
                        const r = t || xi.utils.random(1, 10);
                        e.to(n, {
                            scaleY: r,
                            duration: .8,
                            ease: "none"
                        }, "<")
                    })), e
                },
                ss = () => {
                    is = xi.timeline({
                        onComplete: () => {
                            ss()
                        }
                    }).add(rs())
                },
                os = () => {
                    ns = document.querySelectorAll(".sound-btn div"), ns && ss()
                },
                as = () => {
                    is && (is.kill(), is = null)
                };
            var ls = n(69),
                cs = n.n(ls);
            const us = document.querySelector(".magnet-btn"),
                hs = us.querySelector(".circle-btn");
            let ds = null;
            const ps = t => {
                    (t => {
                        hs.innerHTML = t
                    })(t), ds.play()
                },
                fs = () => {
                    ds.reverse()
                },
                ms = () => {
                    mr && (ds || (ds = xi.timeline({
                        paused: 1
                    }).add(Dr(hs))), window.addEventListener("mousemove", (t => {
                        var e, n;
                        e = t.clientX, n = t.clientY, xi.to(us, {
                            x: e,
                            y: n,
                            duration: .2,
                            ease: "sine.out"
                        })
                    })))
                },
                gs = document.querySelector(".preloader-internal"),
                vs = () => {
                    const t = document.querySelector('[data-barba="container"]');
                    xi.timeline({
                        delay: .2,
                        onStart: () => {
                            ds && ds.pause().progress(0), Wr = !1, Gr && Gr.pause().progress(0), Ky(), window.scrollTo(0, 0)
                        },
                        onComplete: () => {
                            jy()
                        }
                    }).set(t, {
                        visibility: "visible"
                    }).to(gs, {
                        y: "-100%",
                        duration: .8,
                        ease: "app.inOut"
                    })
                };
            let ys = document.querySelector(".pagination"),
                xs = null;
            const _s = () => {
                ys = document.querySelector(".pagination"), ys && (() => {
                    if (!xs) {
                        const t = ys.querySelectorAll("div");
                        xs = xi.timeline({
                            paused: 1
                        }).from(t, {
                            autoAlpha: 0,
                            duration: .4,
                            stagger: .1,
                            ease: "app.out"
                        }, "<")
                    }
                })()
            };
            let bs = document.querySelector(".home-footer"),
                ws = null;
            const Ms = () => {
                bs = document.querySelector(".home-footer"), bs && (() => {
                    if (!ws) {
                        const t = bs.querySelector("p"),
                            e = bs.querySelector(".hint-circle"),
                            n = bs.querySelector(".sound-btn");
                        ws = xi.timeline({
                            paused: 1
                        }).from(t, {
                            autoAlpha: 0,
                            y: -10,
                            duration: .4,
                            ease: "app.ease"
                        }, "<").from(n, {
                            autoAlpha: 0,
                            duration: .4,
                            ease: "app.out"
                        }, "<").from(e, {
                            scale: 0,
                            duration: .8,
                            ease: "back.out(3)"
                        }, "<")
                    }
                })()
            };
            let Ss = null;
            const Es = () => {
                    Ss && (xs && (xs.kill(), xs = null), ws && (ws.kill(), ws = null), Ss.kill(), Ss = null)
                },
                Ds = () => {
                    "index" === ky() && (_s(), Ms(), Ss || (xs.play(), ws.play(), Ss = xi.timeline({
                        paused: 1
                    }).add(xs, "<").add(ws, "<.4")))
                };
            let Ts = document.querySelectorAll(".home-pagination button");
            const As = () => {
                    Ts = document.querySelectorAll(".home-pagination button"), Ts.length && Ts.forEach(((t, e) => {
                        t.addEventListener("click", (t => {
                            bg(e)
                        }))
                    }))
                },
                Cs = 100,
                Ls = 301,
                Rs = 302,
                Ps = 306,
                Fs = 307,
                Os = 1e3,
                Is = 1001,
                Ns = 1002,
                Bs = 1003,
                zs = 1004,
                ks = 1005,
                Hs = 1006,
                Us = 1008,
                Gs = 1009,
                Ws = 1012,
                Vs = 1014,
                js = 1015,
                qs = 1016,
                Xs = 1020,
                Ys = 1022,
                Zs = 1023,
                Js = 1026,
                Qs = 1027,
                Ks = 2300,
                $s = 2301,
                to = 2302,
                eo = 2400,
                no = 2401,
                io = 2402,
                ro = 2500,
                so = 3e3,
                oo = 3001,
                ao = 3007,
                lo = 3002,
                co = 7680,
                uo = 35044,
                ho = 35048,
                po = "300 es";

            function fo() {}
            Object.assign(fo.prototype, {
                addEventListener: function(t, e) {
                    void 0 === this._listeners && (this._listeners = {});
                    const n = this._listeners;
                    void 0 === n[t] && (n[t] = []), -1 === n[t].indexOf(e) && n[t].push(e)
                },
                hasEventListener: function(t, e) {
                    if (void 0 === this._listeners) return !1;
                    const n = this._listeners;
                    return void 0 !== n[t] && -1 !== n[t].indexOf(e)
                },
                removeEventListener: function(t, e) {
                    if (void 0 === this._listeners) return;
                    const n = this._listeners[t];
                    if (void 0 !== n) {
                        const t = n.indexOf(e); - 1 !== t && n.splice(t, 1)
                    }
                },
                dispatchEvent: function(t) {
                    if (void 0 === this._listeners) return;
                    const e = this._listeners[t.type];
                    if (void 0 !== e) {
                        t.target = this;
                        const n = e.slice(0);
                        for (let e = 0, i = n.length; e < i; e++) n[e].call(this, t)
                    }
                }
            });
            const mo = [];
            for (let t = 0; t < 256; t++) mo[t] = (t < 16 ? "0" : "") + t.toString(16);
            let go = 1234567;
            const vo = {
                DEG2RAD: Math.PI / 180,
                RAD2DEG: 180 / Math.PI,
                generateUUID: function() {
                    const t = 4294967295 * Math.random() | 0,
                        e = 4294967295 * Math.random() | 0,
                        n = 4294967295 * Math.random() | 0,
                        i = 4294967295 * Math.random() | 0;
                    return (mo[255 & t] + mo[t >> 8 & 255] + mo[t >> 16 & 255] + mo[t >> 24 & 255] + "-" + mo[255 & e] + mo[e >> 8 & 255] + "-" + mo[e >> 16 & 15 | 64] + mo[e >> 24 & 255] + "-" + mo[63 & n | 128] + mo[n >> 8 & 255] + "-" + mo[n >> 16 & 255] + mo[n >> 24 & 255] + mo[255 & i] + mo[i >> 8 & 255] + mo[i >> 16 & 255] + mo[i >> 24 & 255]).toUpperCase()
                },
                clamp: function(t, e, n) {
                    return Math.max(e, Math.min(n, t))
                },
                euclideanModulo: function(t, e) {
                    return (t % e + e) % e
                },
                mapLinear: function(t, e, n, i, r) {
                    return i + (t - e) * (r - i) / (n - e)
                },
                lerp: function(t, e, n) {
                    return (1 - n) * t + n * e
                },
                damp: function(t, e, n, i) {
                    return vo.lerp(t, e, 1 - Math.exp(-n * i))
                },
                pingpong: function(t, e = 1) {
                    return e - Math.abs(vo.euclideanModulo(t, 2 * e) - e)
                },
                smoothstep: function(t, e, n) {
                    return t <= e ? 0 : t >= n ? 1 : (t = (t - e) / (n - e)) * t * (3 - 2 * t)
                },
                smootherstep: function(t, e, n) {
                    return t <= e ? 0 : t >= n ? 1 : (t = (t - e) / (n - e)) * t * t * (t * (6 * t - 15) + 10)
                },
                randInt: function(t, e) {
                    return t + Math.floor(Math.random() * (e - t + 1))
                },
                randFloat: function(t, e) {
                    return t + Math.random() * (e - t)
                },
                randFloatSpread: function(t) {
                    return t * (.5 - Math.random())
                },
                seededRandom: function(t) {
                    return void 0 !== t && (go = t % 2147483647), go = 16807 * go % 2147483647, (go - 1) / 2147483646
                },
                degToRad: function(t) {
                    return t * vo.DEG2RAD
                },
                radToDeg: function(t) {
                    return t * vo.RAD2DEG
                },
                isPowerOfTwo: function(t) {
                    return 0 == (t & t - 1) && 0 !== t
                },
                ceilPowerOfTwo: function(t) {
                    return Math.pow(2, Math.ceil(Math.log(t) / Math.LN2))
                },
                floorPowerOfTwo: function(t) {
                    return Math.pow(2, Math.floor(Math.log(t) / Math.LN2))
                },
                setQuaternionFromProperEuler: function(t, e, n, i, r) {
                    const s = Math.cos,
                        o = Math.sin,
                        a = s(n / 2),
                        l = o(n / 2),
                        c = s((e + i) / 2),
                        u = o((e + i) / 2),
                        h = s((e - i) / 2),
                        d = o((e - i) / 2),
                        p = s((i - e) / 2),
                        f = o((i - e) / 2);
                    switch (r) {
                        case "XYX":
                            t.set(a * u, l * h, l * d, a * c);
                            break;
                        case "YZY":
                            t.set(l * d, a * u, l * h, a * c);
                            break;
                        case "ZXZ":
                            t.set(l * h, l * d, a * u, a * c);
                            break;
                        case "XZX":
                            t.set(a * u, l * f, l * p, a * c);
                            break;
                        case "YXY":
                            t.set(l * p, a * u, l * f, a * c);
                            break;
                        case "ZYZ":
                            t.set(l * f, l * p, a * u, a * c);
                            break;
                        default:
                            console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + r)
                    }
                }
            };
            class yo {
                constructor(t = 0, e = 0) {
                    this.x = t, this.y = e
                }
                get width() {
                    return this.x
                }
                set width(t) {
                    this.x = t
                }
                get height() {
                    return this.y
                }
                set height(t) {
                    this.y = t
                }
                set(t, e) {
                    return this.x = t, this.y = e, this
                }
                setScalar(t) {
                    return this.x = t, this.y = t, this
                }
                setX(t) {
                    return this.x = t, this
                }
                setY(t) {
                    return this.y = t, this
                }
                setComponent(t, e) {
                    switch (t) {
                        case 0:
                            this.x = e;
                            break;
                        case 1:
                            this.y = e;
                            break;
                        default:
                            throw new Error("index is out of range: " + t)
                    }
                    return this
                }
                getComponent(t) {
                    switch (t) {
                        case 0:
                            return this.x;
                        case 1:
                            return this.y;
                        default:
                            throw new Error("index is out of range: " + t)
                    }
                }
                clone() {
                    return new this.constructor(this.x, this.y)
                }
                copy(t) {
                    return this.x = t.x, this.y = t.y, this
                }
                add(t, e) {
                    return void 0 !== e ? (console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(t, e)) : (this.x += t.x, this.y += t.y, this)
                }
                addScalar(t) {
                    return this.x += t, this.y += t, this
                }
                addVectors(t, e) {
                    return this.x = t.x + e.x, this.y = t.y + e.y, this
                }
                addScaledVector(t, e) {
                    return this.x += t.x * e, this.y += t.y * e, this
                }
                sub(t, e) {
                    return void 0 !== e ? (console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(t, e)) : (this.x -= t.x, this.y -= t.y, this)
                }
                subScalar(t) {
                    return this.x -= t, this.y -= t, this
                }
                subVectors(t, e) {
                    return this.x = t.x - e.x, this.y = t.y - e.y, this
                }
                multiply(t) {
                    return this.x *= t.x, this.y *= t.y, this
                }
                multiplyScalar(t) {
                    return this.x *= t, this.y *= t, this
                }
                divide(t) {
                    return this.x /= t.x, this.y /= t.y, this
                }
                divideScalar(t) {
                    return this.multiplyScalar(1 / t)
                }
                applyMatrix3(t) {
                    const e = this.x,
                        n = this.y,
                        i = t.elements;
                    return this.x = i[0] * e + i[3] * n + i[6], this.y = i[1] * e + i[4] * n + i[7], this
                }
                min(t) {
                    return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this
                }
                max(t) {
                    return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this
                }
                clamp(t, e) {
                    return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this
                }
                clampScalar(t, e) {
                    return this.x = Math.max(t, Math.min(e, this.x)), this.y = Math.max(t, Math.min(e, this.y)), this
                }
                clampLength(t, e) {
                    const n = this.length();
                    return this.divideScalar(n || 1).multiplyScalar(Math.max(t, Math.min(e, n)))
                }
                floor() {
                    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this
                }
                ceil() {
                    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this
                }
                round() {
                    return this.x = Math.round(this.x), this.y = Math.round(this.y), this
                }
                roundToZero() {
                    return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this
                }
                negate() {
                    return this.x = -this.x, this.y = -this.y, this
                }
                dot(t) {
                    return this.x * t.x + this.y * t.y
                }
                cross(t) {
                    return this.x * t.y - this.y * t.x
                }
                lengthSq() {
                    return this.x * this.x + this.y * this.y
                }
                length() {
                    return Math.sqrt(this.x * this.x + this.y * this.y)
                }
                manhattanLength() {
                    return Math.abs(this.x) + Math.abs(this.y)
                }
                normalize() {
                    return this.divideScalar(this.length() || 1)
                }
                angle() {
                    return Math.atan2(-this.y, -this.x) + Math.PI
                }
                distanceTo(t) {
                    return Math.sqrt(this.distanceToSquared(t))
                }
                distanceToSquared(t) {
                    const e = this.x - t.x,
                        n = this.y - t.y;
                    return e * e + n * n
                }
                manhattanDistanceTo(t) {
                    return Math.abs(this.x - t.x) + Math.abs(this.y - t.y)
                }
                setLength(t) {
                    return this.normalize().multiplyScalar(t)
                }
                lerp(t, e) {
                    return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this
                }
                lerpVectors(t, e, n) {
                    return this.x = t.x + (e.x - t.x) * n, this.y = t.y + (e.y - t.y) * n, this
                }
                equals(t) {
                    return t.x === this.x && t.y === this.y
                }
                fromArray(t, e = 0) {
                    return this.x = t[e], this.y = t[e + 1], this
                }
                toArray(t = [], e = 0) {
                    return t[e] = this.x, t[e + 1] = this.y, t
                }
                fromBufferAttribute(t, e, n) {
                    return void 0 !== n && console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute()."), this.x = t.getX(e), this.y = t.getY(e), this
                }
                rotateAround(t, e) {
                    const n = Math.cos(e),
                        i = Math.sin(e),
                        r = this.x - t.x,
                        s = this.y - t.y;
                    return this.x = r * n - s * i + t.x, this.y = r * i + s * n + t.y, this
                }
                random() {
                    return this.x = Math.random(), this.y = Math.random(), this
                }
            }
            yo.prototype.isVector2 = !0;
            class xo {
                constructor() {
                    this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1], arguments.length > 0 && console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.")
                }
                set(t, e, n, i, r, s, o, a, l) {
                    const c = this.elements;
                    return c[0] = t, c[1] = i, c[2] = o, c[3] = e, c[4] = r, c[5] = a, c[6] = n, c[7] = s, c[8] = l, this
                }
                identity() {
                    return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this
                }
                copy(t) {
                    const e = this.elements,
                        n = t.elements;
                    return e[0] = n[0], e[1] = n[1], e[2] = n[2], e[3] = n[3], e[4] = n[4], e[5] = n[5], e[6] = n[6], e[7] = n[7], e[8] = n[8], this
                }
                extractBasis(t, e, n) {
                    return t.setFromMatrix3Column(this, 0), e.setFromMatrix3Column(this, 1), n.setFromMatrix3Column(this, 2), this
                }
                setFromMatrix4(t) {
                    const e = t.elements;
                    return this.set(e[0], e[4], e[8], e[1], e[5], e[9], e[2], e[6], e[10]), this
                }
                multiply(t) {
                    return this.multiplyMatrices(this, t)
                }
                premultiply(t) {
                    return this.multiplyMatrices(t, this)
                }
                multiplyMatrices(t, e) {
                    const n = t.elements,
                        i = e.elements,
                        r = this.elements,
                        s = n[0],
                        o = n[3],
                        a = n[6],
                        l = n[1],
                        c = n[4],
                        u = n[7],
                        h = n[2],
                        d = n[5],
                        p = n[8],
                        f = i[0],
                        m = i[3],
                        g = i[6],
                        v = i[1],
                        y = i[4],
                        x = i[7],
                        _ = i[2],
                        b = i[5],
                        w = i[8];
                    return r[0] = s * f + o * v + a * _, r[3] = s * m + o * y + a * b, r[6] = s * g + o * x + a * w, r[1] = l * f + c * v + u * _, r[4] = l * m + c * y + u * b, r[7] = l * g + c * x + u * w, r[2] = h * f + d * v + p * _, r[5] = h * m + d * y + p * b, r[8] = h * g + d * x + p * w, this
                }
                multiplyScalar(t) {
                    const e = this.elements;
                    return e[0] *= t, e[3] *= t, e[6] *= t, e[1] *= t, e[4] *= t, e[7] *= t, e[2] *= t, e[5] *= t, e[8] *= t, this
                }
                determinant() {
                    const t = this.elements,
                        e = t[0],
                        n = t[1],
                        i = t[2],
                        r = t[3],
                        s = t[4],
                        o = t[5],
                        a = t[6],
                        l = t[7],
                        c = t[8];
                    return e * s * c - e * o * l - n * r * c + n * o * a + i * r * l - i * s * a
                }
                invert() {
                    const t = this.elements,
                        e = t[0],
                        n = t[1],
                        i = t[2],
                        r = t[3],
                        s = t[4],
                        o = t[5],
                        a = t[6],
                        l = t[7],
                        c = t[8],
                        u = c * s - o * l,
                        h = o * a - c * r,
                        d = l * r - s * a,
                        p = e * u + n * h + i * d;
                    if (0 === p) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
                    const f = 1 / p;
                    return t[0] = u * f, t[1] = (i * l - c * n) * f, t[2] = (o * n - i * s) * f, t[3] = h * f, t[4] = (c * e - i * a) * f, t[5] = (i * r - o * e) * f, t[6] = d * f, t[7] = (n * a - l * e) * f, t[8] = (s * e - n * r) * f, this
                }
                transpose() {
                    let t;
                    const e = this.elements;
                    return t = e[1], e[1] = e[3], e[3] = t, t = e[2], e[2] = e[6], e[6] = t, t = e[5], e[5] = e[7], e[7] = t, this
                }
                getNormalMatrix(t) {
                    return this.setFromMatrix4(t).invert().transpose()
                }
                transposeIntoArray(t) {
                    const e = this.elements;
                    return t[0] = e[0], t[1] = e[3], t[2] = e[6], t[3] = e[1], t[4] = e[4], t[5] = e[7], t[6] = e[2], t[7] = e[5], t[8] = e[8], this
                }
                setUvTransform(t, e, n, i, r, s, o) {
                    const a = Math.cos(r),
                        l = Math.sin(r);
                    return this.set(n * a, n * l, -n * (a * s + l * o) + s + t, -i * l, i * a, -i * (-l * s + a * o) + o + e, 0, 0, 1), this
                }
                scale(t, e) {
                    const n = this.elements;
                    return n[0] *= t, n[3] *= t, n[6] *= t, n[1] *= e, n[4] *= e, n[7] *= e, this
                }
                rotate(t) {
                    const e = Math.cos(t),
                        n = Math.sin(t),
                        i = this.elements,
                        r = i[0],
                        s = i[3],
                        o = i[6],
                        a = i[1],
                        l = i[4],
                        c = i[7];
                    return i[0] = e * r + n * a, i[3] = e * s + n * l, i[6] = e * o + n * c, i[1] = -n * r + e * a, i[4] = -n * s + e * l, i[7] = -n * o + e * c, this
                }
                translate(t, e) {
                    const n = this.elements;
                    return n[0] += t * n[2], n[3] += t * n[5], n[6] += t * n[8], n[1] += e * n[2], n[4] += e * n[5], n[7] += e * n[8], this
                }
                equals(t) {
                    const e = this.elements,
                        n = t.elements;
                    for (let t = 0; t < 9; t++)
                        if (e[t] !== n[t]) return !1;
                    return !0
                }
                fromArray(t, e = 0) {
                    for (let n = 0; n < 9; n++) this.elements[n] = t[n + e];
                    return this
                }
                toArray(t = [], e = 0) {
                    const n = this.elements;
                    return t[e] = n[0], t[e + 1] = n[1], t[e + 2] = n[2], t[e + 3] = n[3], t[e + 4] = n[4], t[e + 5] = n[5], t[e + 6] = n[6], t[e + 7] = n[7], t[e + 8] = n[8], t
                }
                clone() {
                    return (new this.constructor).fromArray(this.elements)
                }
            }
            let _o;
            xo.prototype.isMatrix3 = !0;
            const bo = {
                getDataURL: function(t) {
                    if (/^data:/i.test(t.src)) return t.src;
                    if ("undefined" == typeof HTMLCanvasElement) return t.src;
                    let e;
                    if (t instanceof HTMLCanvasElement) e = t;
                    else {
                        void 0 === _o && (_o = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas")), _o.width = t.width, _o.height = t.height;
                        const n = _o.getContext("2d");
                        t instanceof ImageData ? n.putImageData(t, 0, 0) : n.drawImage(t, 0, 0, t.width, t.height), e = _o
                    }
                    return e.width > 2048 || e.height > 2048 ? e.toDataURL("image/jpeg", .6) : e.toDataURL("image/png")
                }
            };
            let wo = 0;
            class Mo extends fo {
                constructor(t = Mo.DEFAULT_IMAGE, e = Mo.DEFAULT_MAPPING, n = 1001, i = 1001, r = 1006, s = 1008, o = 1023, a = 1009, l = 1, c = 3e3) {
                    super(), Object.defineProperty(this, "id", {
                        value: wo++
                    }), this.uuid = vo.generateUUID(), this.name = "", this.image = t, this.mipmaps = [], this.mapping = e, this.wrapS = n, this.wrapT = i, this.magFilter = r, this.minFilter = s, this.anisotropy = l, this.format = o, this.internalFormat = null, this.type = a, this.offset = new yo(0, 0), this.repeat = new yo(1, 1), this.center = new yo(0, 0), this.rotation = 0, this.matrixAutoUpdate = !0, this.matrix = new xo, this.generateMipmaps = !0, this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, this.encoding = c, this.version = 0, this.onUpdate = null
                }
                updateMatrix() {
                    this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y)
                }
                clone() {
                    return (new this.constructor).copy(this)
                }
                copy(t) {
                    return this.name = t.name, this.image = t.image, this.mipmaps = t.mipmaps.slice(0), this.mapping = t.mapping, this.wrapS = t.wrapS, this.wrapT = t.wrapT, this.magFilter = t.magFilter, this.minFilter = t.minFilter, this.anisotropy = t.anisotropy, this.format = t.format, this.internalFormat = t.internalFormat, this.type = t.type, this.offset.copy(t.offset), this.repeat.copy(t.repeat), this.center.copy(t.center), this.rotation = t.rotation, this.matrixAutoUpdate = t.matrixAutoUpdate, this.matrix.copy(t.matrix), this.generateMipmaps = t.generateMipmaps, this.premultiplyAlpha = t.premultiplyAlpha, this.flipY = t.flipY, this.unpackAlignment = t.unpackAlignment, this.encoding = t.encoding, this
                }
                toJSON(t) {
                    const e = void 0 === t || "string" == typeof t;
                    if (!e && void 0 !== t.textures[this.uuid]) return t.textures[this.uuid];
                    const n = {
                        metadata: {
                            version: 4.5,
                            type: "Texture",
                            generator: "Texture.toJSON"
                        },
                        uuid: this.uuid,
                        name: this.name,
                        mapping: this.mapping,
                        repeat: [this.repeat.x, this.repeat.y],
                        offset: [this.offset.x, this.offset.y],
                        center: [this.center.x, this.center.y],
                        rotation: this.rotation,
                        wrap: [this.wrapS, this.wrapT],
                        format: this.format,
                        type: this.type,
                        encoding: this.encoding,
                        minFilter: this.minFilter,
                        magFilter: this.magFilter,
                        anisotropy: this.anisotropy,
                        flipY: this.flipY,
                        premultiplyAlpha: this.premultiplyAlpha,
                        unpackAlignment: this.unpackAlignment
                    };
                    if (void 0 !== this.image) {
                        const i = this.image;
                        if (void 0 === i.uuid && (i.uuid = vo.generateUUID()), !e && void 0 === t.images[i.uuid]) {
                            let e;
                            if (Array.isArray(i)) {
                                e = [];
                                for (let t = 0, n = i.length; t < n; t++) i[t].isDataTexture ? e.push(So(i[t].image)) : e.push(So(i[t]))
                            } else e = So(i);
                            t.images[i.uuid] = {
                                uuid: i.uuid,
                                url: e
                            }
                        }
                        n.image = i.uuid
                    }
                    return e || (t.textures[this.uuid] = n), n
                }
                dispose() {
                    this.dispatchEvent({
                        type: "dispose"
                    })
                }
                transformUv(t) {
                    if (300 !== this.mapping) return t;
                    if (t.applyMatrix3(this.matrix), t.x < 0 || t.x > 1) switch (this.wrapS) {
                        case Os:
                            t.x = t.x - Math.floor(t.x);
                            break;
                        case Is:
                            t.x = t.x < 0 ? 0 : 1;
                            break;
                        case Ns:
                            1 === Math.abs(Math.floor(t.x) % 2) ? t.x = Math.ceil(t.x) - t.x : t.x = t.x - Math.floor(t.x)
                    }
                    if (t.y < 0 || t.y > 1) switch (this.wrapT) {
                        case Os:
                            t.y = t.y - Math.floor(t.y);
                            break;
                        case Is:
                            t.y = t.y < 0 ? 0 : 1;
                            break;
                        case Ns:
                            1 === Math.abs(Math.floor(t.y) % 2) ? t.y = Math.ceil(t.y) - t.y : t.y = t.y - Math.floor(t.y)
                    }
                    return this.flipY && (t.y = 1 - t.y), t
                }
                set needsUpdate(t) {
                    !0 === t && this.version++
                }
            }

            function So(t) {
                return "undefined" != typeof HTMLImageElement && t instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && t instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && t instanceof ImageBitmap ? bo.getDataURL(t) : t.data ? {
                    data: Array.prototype.slice.call(t.data),
                    width: t.width,
                    height: t.height,
                    type: t.data.constructor.name
                } : (console.warn("THREE.Texture: Unable to serialize Texture."), {})
            }
            Mo.DEFAULT_IMAGE = void 0, Mo.DEFAULT_MAPPING = 300, Mo.prototype.isTexture = !0;
            class Eo {
                constructor(t = 0, e = 0, n = 0, i = 1) {
                    this.x = t, this.y = e, this.z = n, this.w = i
                }
                get width() {
                    return this.z
                }
                set width(t) {
                    this.z = t
                }
                get height() {
                    return this.w
                }
                set height(t) {
                    this.w = t
                }
                set(t, e, n, i) {
                    return this.x = t, this.y = e, this.z = n, this.w = i, this
                }
                setScalar(t) {
                    return this.x = t, this.y = t, this.z = t, this.w = t, this
                }
                setX(t) {
                    return this.x = t, this
                }
                setY(t) {
                    return this.y = t, this
                }
                setZ(t) {
                    return this.z = t, this
                }
                setW(t) {
                    return this.w = t, this
                }
                setComponent(t, e) {
                    switch (t) {
                        case 0:
                            this.x = e;
                            break;
                        case 1:
                            this.y = e;
                            break;
                        case 2:
                            this.z = e;
                            break;
                        case 3:
                            this.w = e;
                            break;
                        default:
                            throw new Error("index is out of range: " + t)
                    }
                    return this
                }
                getComponent(t) {
                    switch (t) {
                        case 0:
                            return this.x;
                        case 1:
                            return this.y;
                        case 2:
                            return this.z;
                        case 3:
                            return this.w;
                        default:
                            throw new Error("index is out of range: " + t)
                    }
                }
                clone() {
                    return new this.constructor(this.x, this.y, this.z, this.w)
                }
                copy(t) {
                    return this.x = t.x, this.y = t.y, this.z = t.z, this.w = void 0 !== t.w ? t.w : 1, this
                }
                add(t, e) {
                    return void 0 !== e ? (console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(t, e)) : (this.x += t.x, this.y += t.y, this.z += t.z, this.w += t.w, this)
                }
                addScalar(t) {
                    return this.x += t, this.y += t, this.z += t, this.w += t, this
                }
                addVectors(t, e) {
                    return this.x = t.x + e.x, this.y = t.y + e.y, this.z = t.z + e.z, this.w = t.w + e.w, this
                }
                addScaledVector(t, e) {
                    return this.x += t.x * e, this.y += t.y * e, this.z += t.z * e, this.w += t.w * e, this
                }
                sub(t, e) {
                    return void 0 !== e ? (console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(t, e)) : (this.x -= t.x, this.y -= t.y, this.z -= t.z, this.w -= t.w, this)
                }
                subScalar(t) {
                    return this.x -= t, this.y -= t, this.z -= t, this.w -= t, this
                }
                subVectors(t, e) {
                    return this.x = t.x - e.x, this.y = t.y - e.y, this.z = t.z - e.z, this.w = t.w - e.w, this
                }
                multiply(t) {
                    return this.x *= t.x, this.y *= t.y, this.z *= t.z, this.w *= t.w, this
                }
                multiplyScalar(t) {
                    return this.x *= t, this.y *= t, this.z *= t, this.w *= t, this
                }
                applyMatrix4(t) {
                    const e = this.x,
                        n = this.y,
                        i = this.z,
                        r = this.w,
                        s = t.elements;
                    return this.x = s[0] * e + s[4] * n + s[8] * i + s[12] * r, this.y = s[1] * e + s[5] * n + s[9] * i + s[13] * r, this.z = s[2] * e + s[6] * n + s[10] * i + s[14] * r, this.w = s[3] * e + s[7] * n + s[11] * i + s[15] * r, this
                }
                divideScalar(t) {
                    return this.multiplyScalar(1 / t)
                }
                setAxisAngleFromQuaternion(t) {
                    this.w = 2 * Math.acos(t.w);
                    const e = Math.sqrt(1 - t.w * t.w);
                    return e < 1e-4 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = t.x / e, this.y = t.y / e, this.z = t.z / e), this
                }
                setAxisAngleFromRotationMatrix(t) {
                    let e, n, i, r;
                    const s = .01,
                        o = .1,
                        a = t.elements,
                        l = a[0],
                        c = a[4],
                        u = a[8],
                        h = a[1],
                        d = a[5],
                        p = a[9],
                        f = a[2],
                        m = a[6],
                        g = a[10];
                    if (Math.abs(c - h) < s && Math.abs(u - f) < s && Math.abs(p - m) < s) {
                        if (Math.abs(c + h) < o && Math.abs(u + f) < o && Math.abs(p + m) < o && Math.abs(l + d + g - 3) < o) return this.set(1, 0, 0, 0), this;
                        e = Math.PI;
                        const t = (l + 1) / 2,
                            a = (d + 1) / 2,
                            v = (g + 1) / 2,
                            y = (c + h) / 4,
                            x = (u + f) / 4,
                            _ = (p + m) / 4;
                        return t > a && t > v ? t < s ? (n = 0, i = .707106781, r = .707106781) : (n = Math.sqrt(t), i = y / n, r = x / n) : a > v ? a < s ? (n = .707106781, i = 0, r = .707106781) : (i = Math.sqrt(a), n = y / i, r = _ / i) : v < s ? (n = .707106781, i = .707106781, r = 0) : (r = Math.sqrt(v), n = x / r, i = _ / r), this.set(n, i, r, e), this
                    }
                    let v = Math.sqrt((m - p) * (m - p) + (u - f) * (u - f) + (h - c) * (h - c));
                    return Math.abs(v) < .001 && (v = 1), this.x = (m - p) / v, this.y = (u - f) / v, this.z = (h - c) / v, this.w = Math.acos((l + d + g - 1) / 2), this
                }
                min(t) {
                    return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this.z = Math.min(this.z, t.z), this.w = Math.min(this.w, t.w), this
                }
                max(t) {
                    return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this.z = Math.max(this.z, t.z), this.w = Math.max(this.w, t.w), this
                }
                clamp(t, e) {
                    return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this.z = Math.max(t.z, Math.min(e.z, this.z)), this.w = Math.max(t.w, Math.min(e.w, this.w)), this
                }
                clampScalar(t, e) {
                    return this.x = Math.max(t, Math.min(e, this.x)), this.y = Math.max(t, Math.min(e, this.y)), this.z = Math.max(t, Math.min(e, this.z)), this.w = Math.max(t, Math.min(e, this.w)), this
                }
                clampLength(t, e) {
                    const n = this.length();
                    return this.divideScalar(n || 1).multiplyScalar(Math.max(t, Math.min(e, n)))
                }
                floor() {
                    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this
                }
                ceil() {
                    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this
                }
                round() {
                    return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this
                }
                roundToZero() {
                    return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w), this
                }
                negate() {
                    return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this
                }
                dot(t) {
                    return this.x * t.x + this.y * t.y + this.z * t.z + this.w * t.w
                }
                lengthSq() {
                    return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
                }
                length() {
                    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)
                }
                manhattanLength() {
                    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
                }
                normalize() {
                    return this.divideScalar(this.length() || 1)
                }
                setLength(t) {
                    return this.normalize().multiplyScalar(t)
                }
                lerp(t, e) {
                    return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this.z += (t.z - this.z) * e, this.w += (t.w - this.w) * e, this
                }
                lerpVectors(t, e, n) {
                    return this.x = t.x + (e.x - t.x) * n, this.y = t.y + (e.y - t.y) * n, this.z = t.z + (e.z - t.z) * n, this.w = t.w + (e.w - t.w) * n, this
                }
                equals(t) {
                    return t.x === this.x && t.y === this.y && t.z === this.z && t.w === this.w
                }
                fromArray(t, e = 0) {
                    return this.x = t[e], this.y = t[e + 1], this.z = t[e + 2], this.w = t[e + 3], this
                }
                toArray(t = [], e = 0) {
                    return t[e] = this.x, t[e + 1] = this.y, t[e + 2] = this.z, t[e + 3] = this.w, t
                }
                fromBufferAttribute(t, e, n) {
                    return void 0 !== n && console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute()."), this.x = t.getX(e), this.y = t.getY(e), this.z = t.getZ(e), this.w = t.getW(e), this
                }
                random() {
                    return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this.w = Math.random(), this
                }
            }
            Eo.prototype.isVector4 = !0;
            class Do extends fo {
                constructor(t, e, n) {
                    super(), this.width = t, this.height = e, this.depth = 1, this.scissor = new Eo(0, 0, t, e), this.scissorTest = !1, this.viewport = new Eo(0, 0, t, e), n = n || {}, this.texture = new Mo(void 0, n.mapping, n.wrapS, n.wrapT, n.magFilter, n.minFilter, n.format, n.type, n.anisotropy, n.encoding), this.texture.image = {}, this.texture.image.width = t, this.texture.image.height = e, this.texture.image.depth = 1, this.texture.generateMipmaps = void 0 !== n.generateMipmaps && n.generateMipmaps, this.texture.minFilter = void 0 !== n.minFilter ? n.minFilter : Hs, this.depthBuffer = void 0 === n.depthBuffer || n.depthBuffer, this.stencilBuffer = void 0 !== n.stencilBuffer && n.stencilBuffer, this.depthTexture = void 0 !== n.depthTexture ? n.depthTexture : null
                }
                setTexture(t) {
                    t.image = {
                        width: this.width,
                        height: this.height,
                        depth: this.depth
                    }, this.texture = t
                }
                setSize(t, e, n = 1) {
                    this.width === t && this.height === e && this.depth === n || (this.width = t, this.height = e, this.depth = n, this.texture.image.width = t, this.texture.image.height = e, this.texture.image.depth = n, this.dispose()), this.viewport.set(0, 0, t, e), this.scissor.set(0, 0, t, e)
                }
                clone() {
                    return (new this.constructor).copy(this)
                }
                copy(t) {
                    return this.width = t.width, this.height = t.height, this.depth = t.depth, this.viewport.copy(t.viewport), this.texture = t.texture.clone(), this.depthBuffer = t.depthBuffer, this.stencilBuffer = t.stencilBuffer, this.depthTexture = t.depthTexture, this
                }
                dispose() {
                    this.dispatchEvent({
                        type: "dispose"
                    })
                }
            }
            Do.prototype.isWebGLRenderTarget = !0;
            (class extends Do {
                constructor(t, e, n) {
                    super(t, e, n), this.samples = 4
                }
                copy(t) {
                    return super.copy.call(this, t), this.samples = t.samples, this
                }
            }).prototype.isWebGLMultisampleRenderTarget = !0;
            class To {
                constructor(t = 0, e = 0, n = 0, i = 1) {
                    this._x = t, this._y = e, this._z = n, this._w = i
                }
                static slerp(t, e, n, i) {
                    return n.copy(t).slerp(e, i)
                }
                static slerpFlat(t, e, n, i, r, s, o) {
                    let a = n[i + 0],
                        l = n[i + 1],
                        c = n[i + 2],
                        u = n[i + 3];
                    const h = r[s + 0],
                        d = r[s + 1],
                        p = r[s + 2],
                        f = r[s + 3];
                    if (0 === o) return t[e + 0] = a, t[e + 1] = l, t[e + 2] = c, void(t[e + 3] = u);
                    if (1 === o) return t[e + 0] = h, t[e + 1] = d, t[e + 2] = p, void(t[e + 3] = f);
                    if (u !== f || a !== h || l !== d || c !== p) {
                        let t = 1 - o;
                        const e = a * h + l * d + c * p + u * f,
                            n = e >= 0 ? 1 : -1,
                            i = 1 - e * e;
                        if (i > Number.EPSILON) {
                            const r = Math.sqrt(i),
                                s = Math.atan2(r, e * n);
                            t = Math.sin(t * s) / r, o = Math.sin(o * s) / r
                        }
                        const r = o * n;
                        if (a = a * t + h * r, l = l * t + d * r, c = c * t + p * r, u = u * t + f * r, t === 1 - o) {
                            const t = 1 / Math.sqrt(a * a + l * l + c * c + u * u);
                            a *= t, l *= t, c *= t, u *= t
                        }
                    }
                    t[e] = a, t[e + 1] = l, t[e + 2] = c, t[e + 3] = u
                }
                static multiplyQuaternionsFlat(t, e, n, i, r, s) {
                    const o = n[i],
                        a = n[i + 1],
                        l = n[i + 2],
                        c = n[i + 3],
                        u = r[s],
                        h = r[s + 1],
                        d = r[s + 2],
                        p = r[s + 3];
                    return t[e] = o * p + c * u + a * d - l * h, t[e + 1] = a * p + c * h + l * u - o * d, t[e + 2] = l * p + c * d + o * h - a * u, t[e + 3] = c * p - o * u - a * h - l * d, t
                }
                get x() {
                    return this._x
                }
                set x(t) {
                    this._x = t, this._onChangeCallback()
                }
                get y() {
                    return this._y
                }
                set y(t) {
                    this._y = t, this._onChangeCallback()
                }
                get z() {
                    return this._z
                }
                set z(t) {
                    this._z = t, this._onChangeCallback()
                }
                get w() {
                    return this._w
                }
                set w(t) {
                    this._w = t, this._onChangeCallback()
                }
                set(t, e, n, i) {
                    return this._x = t, this._y = e, this._z = n, this._w = i, this._onChangeCallback(), this
                }
                clone() {
                    return new this.constructor(this._x, this._y, this._z, this._w)
                }
                copy(t) {
                    return this._x = t.x, this._y = t.y, this._z = t.z, this._w = t.w, this._onChangeCallback(), this
                }
                setFromEuler(t, e) {
                    if (!t || !t.isEuler) throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");
                    const n = t._x,
                        i = t._y,
                        r = t._z,
                        s = t._order,
                        o = Math.cos,
                        a = Math.sin,
                        l = o(n / 2),
                        c = o(i / 2),
                        u = o(r / 2),
                        h = a(n / 2),
                        d = a(i / 2),
                        p = a(r / 2);
                    switch (s) {
                        case "XYZ":
                            this._x = h * c * u + l * d * p, this._y = l * d * u - h * c * p, this._z = l * c * p + h * d * u, this._w = l * c * u - h * d * p;
                            break;
                        case "YXZ":
                            this._x = h * c * u + l * d * p, this._y = l * d * u - h * c * p, this._z = l * c * p - h * d * u, this._w = l * c * u + h * d * p;
                            break;
                        case "ZXY":
                            this._x = h * c * u - l * d * p, this._y = l * d * u + h * c * p, this._z = l * c * p + h * d * u, this._w = l * c * u - h * d * p;
                            break;
                        case "ZYX":
                            this._x = h * c * u - l * d * p, this._y = l * d * u + h * c * p, this._z = l * c * p - h * d * u, this._w = l * c * u + h * d * p;
                            break;
                        case "YZX":
                            this._x = h * c * u + l * d * p, this._y = l * d * u + h * c * p, this._z = l * c * p - h * d * u, this._w = l * c * u - h * d * p;
                            break;
                        case "XZY":
                            this._x = h * c * u - l * d * p, this._y = l * d * u - h * c * p, this._z = l * c * p + h * d * u, this._w = l * c * u + h * d * p;
                            break;
                        default:
                            console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + s)
                    }
                    return !1 !== e && this._onChangeCallback(), this
                }
                setFromAxisAngle(t, e) {
                    const n = e / 2,
                        i = Math.sin(n);
                    return this._x = t.x * i, this._y = t.y * i, this._z = t.z * i, this._w = Math.cos(n), this._onChangeCallback(), this
                }
                setFromRotationMatrix(t) {
                    const e = t.elements,
                        n = e[0],
                        i = e[4],
                        r = e[8],
                        s = e[1],
                        o = e[5],
                        a = e[9],
                        l = e[2],
                        c = e[6],
                        u = e[10],
                        h = n + o + u;
                    if (h > 0) {
                        const t = .5 / Math.sqrt(h + 1);
                        this._w = .25 / t, this._x = (c - a) * t, this._y = (r - l) * t, this._z = (s - i) * t
                    } else if (n > o && n > u) {
                        const t = 2 * Math.sqrt(1 + n - o - u);
                        this._w = (c - a) / t, this._x = .25 * t, this._y = (i + s) / t, this._z = (r + l) / t
                    } else if (o > u) {
                        const t = 2 * Math.sqrt(1 + o - n - u);
                        this._w = (r - l) / t, this._x = (i + s) / t, this._y = .25 * t, this._z = (a + c) / t
                    } else {
                        const t = 2 * Math.sqrt(1 + u - n - o);
                        this._w = (s - i) / t, this._x = (r + l) / t, this._y = (a + c) / t, this._z = .25 * t
                    }
                    return this._onChangeCallback(), this
                }
                setFromUnitVectors(t, e) {
                    let n = t.dot(e) + 1;
                    return n < 1e-6 ? (n = 0, Math.abs(t.x) > Math.abs(t.z) ? (this._x = -t.y, this._y = t.x, this._z = 0, this._w = n) : (this._x = 0, this._y = -t.z, this._z = t.y, this._w = n)) : (this._x = t.y * e.z - t.z * e.y, this._y = t.z * e.x - t.x * e.z, this._z = t.x * e.y - t.y * e.x, this._w = n), this.normalize()
                }
                angleTo(t) {
                    return 2 * Math.acos(Math.abs(vo.clamp(this.dot(t), -1, 1)))
                }
                rotateTowards(t, e) {
                    const n = this.angleTo(t);
                    if (0 === n) return this;
                    const i = Math.min(1, e / n);
                    return this.slerp(t, i), this
                }
                identity() {
                    return this.set(0, 0, 0, 1)
                }
                invert() {
                    return this.conjugate()
                }
                conjugate() {
                    return this._x *= -1, this._y *= -1, this._z *= -1, this._onChangeCallback(), this
                }
                dot(t) {
                    return this._x * t._x + this._y * t._y + this._z * t._z + this._w * t._w
                }
                lengthSq() {
                    return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w
                }
                length() {
                    return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w)
                }
                normalize() {
                    let t = this.length();
                    return 0 === t ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (t = 1 / t, this._x = this._x * t, this._y = this._y * t, this._z = this._z * t, this._w = this._w * t), this._onChangeCallback(), this
                }
                multiply(t, e) {
                    return void 0 !== e ? (console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."), this.multiplyQuaternions(t, e)) : this.multiplyQuaternions(this, t)
                }
                premultiply(t) {
                    return this.multiplyQuaternions(t, this)
                }
                multiplyQuaternions(t, e) {
                    const n = t._x,
                        i = t._y,
                        r = t._z,
                        s = t._w,
                        o = e._x,
                        a = e._y,
                        l = e._z,
                        c = e._w;
                    return this._x = n * c + s * o + i * l - r * a, this._y = i * c + s * a + r * o - n * l, this._z = r * c + s * l + n * a - i * o, this._w = s * c - n * o - i * a - r * l, this._onChangeCallback(), this
                }
                slerp(t, e) {
                    if (0 === e) return this;
                    if (1 === e) return this.copy(t);
                    const n = this._x,
                        i = this._y,
                        r = this._z,
                        s = this._w;
                    let o = s * t._w + n * t._x + i * t._y + r * t._z;
                    if (o < 0 ? (this._w = -t._w, this._x = -t._x, this._y = -t._y, this._z = -t._z, o = -o) : this.copy(t), o >= 1) return this._w = s, this._x = n, this._y = i, this._z = r, this;
                    const a = 1 - o * o;
                    if (a <= Number.EPSILON) {
                        const t = 1 - e;
                        return this._w = t * s + e * this._w, this._x = t * n + e * this._x, this._y = t * i + e * this._y, this._z = t * r + e * this._z, this.normalize(), this._onChangeCallback(), this
                    }
                    const l = Math.sqrt(a),
                        c = Math.atan2(l, o),
                        u = Math.sin((1 - e) * c) / l,
                        h = Math.sin(e * c) / l;
                    return this._w = s * u + this._w * h, this._x = n * u + this._x * h, this._y = i * u + this._y * h, this._z = r * u + this._z * h, this._onChangeCallback(), this
                }
                equals(t) {
                    return t._x === this._x && t._y === this._y && t._z === this._z && t._w === this._w
                }
                fromArray(t, e = 0) {
                    return this._x = t[e], this._y = t[e + 1], this._z = t[e + 2], this._w = t[e + 3], this._onChangeCallback(), this
                }
                toArray(t = [], e = 0) {
                    return t[e] = this._x, t[e + 1] = this._y, t[e + 2] = this._z, t[e + 3] = this._w, t
                }
                fromBufferAttribute(t, e) {
                    return this._x = t.getX(e), this._y = t.getY(e), this._z = t.getZ(e), this._w = t.getW(e), this
                }
                _onChange(t) {
                    return this._onChangeCallback = t, this
                }
                _onChangeCallback() {}
            }
            To.prototype.isQuaternion = !0;
            class Ao {
                constructor(t = 0, e = 0, n = 0) {
                    this.x = t, this.y = e, this.z = n
                }
                set(t, e, n) {
                    return void 0 === n && (n = this.z), this.x = t, this.y = e, this.z = n, this
                }
                setScalar(t) {
                    return this.x = t, this.y = t, this.z = t, this
                }
                setX(t) {
                    return this.x = t, this
                }
                setY(t) {
                    return this.y = t, this
                }
                setZ(t) {
                    return this.z = t, this
                }
                setComponent(t, e) {
                    switch (t) {
                        case 0:
                            this.x = e;
                            break;
                        case 1:
                            this.y = e;
                            break;
                        case 2:
                            this.z = e;
                            break;
                        default:
                            throw new Error("index is out of range: " + t)
                    }
                    return this
                }
                getComponent(t) {
                    switch (t) {
                        case 0:
                            return this.x;
                        case 1:
                            return this.y;
                        case 2:
                            return this.z;
                        default:
                            throw new Error("index is out of range: " + t)
                    }
                }
                clone() {
                    return new this.constructor(this.x, this.y, this.z)
                }
                copy(t) {
                    return this.x = t.x, this.y = t.y, this.z = t.z, this
                }
                add(t, e) {
                    return void 0 !== e ? (console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(t, e)) : (this.x += t.x, this.y += t.y, this.z += t.z, this)
                }
                addScalar(t) {
                    return this.x += t, this.y += t, this.z += t, this
                }
                addVectors(t, e) {
                    return this.x = t.x + e.x, this.y = t.y + e.y, this.z = t.z + e.z, this
                }
                addScaledVector(t, e) {
                    return this.x += t.x * e, this.y += t.y * e, this.z += t.z * e, this
                }
                sub(t, e) {
                    return void 0 !== e ? (console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(t, e)) : (this.x -= t.x, this.y -= t.y, this.z -= t.z, this)
                }
                subScalar(t) {
                    return this.x -= t, this.y -= t, this.z -= t, this
                }
                subVectors(t, e) {
                    return this.x = t.x - e.x, this.y = t.y - e.y, this.z = t.z - e.z, this
                }
                multiply(t, e) {
                    return void 0 !== e ? (console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."), this.multiplyVectors(t, e)) : (this.x *= t.x, this.y *= t.y, this.z *= t.z, this)
                }
                multiplyScalar(t) {
                    return this.x *= t, this.y *= t, this.z *= t, this
                }
                multiplyVectors(t, e) {
                    return this.x = t.x * e.x, this.y = t.y * e.y, this.z = t.z * e.z, this
                }
                applyEuler(t) {
                    return t && t.isEuler || console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."), this.applyQuaternion(Lo.setFromEuler(t))
                }
                applyAxisAngle(t, e) {
                    return this.applyQuaternion(Lo.setFromAxisAngle(t, e))
                }
                applyMatrix3(t) {
                    const e = this.x,
                        n = this.y,
                        i = this.z,
                        r = t.elements;
                    return this.x = r[0] * e + r[3] * n + r[6] * i, this.y = r[1] * e + r[4] * n + r[7] * i, this.z = r[2] * e + r[5] * n + r[8] * i, this
                }
                applyNormalMatrix(t) {
                    return this.applyMatrix3(t).normalize()
                }
                applyMatrix4(t) {
                    const e = this.x,
                        n = this.y,
                        i = this.z,
                        r = t.elements,
                        s = 1 / (r[3] * e + r[7] * n + r[11] * i + r[15]);
                    return this.x = (r[0] * e + r[4] * n + r[8] * i + r[12]) * s, this.y = (r[1] * e + r[5] * n + r[9] * i + r[13]) * s, this.z = (r[2] * e + r[6] * n + r[10] * i + r[14]) * s, this
                }
                applyQuaternion(t) {
                    const e = this.x,
                        n = this.y,
                        i = this.z,
                        r = t.x,
                        s = t.y,
                        o = t.z,
                        a = t.w,
                        l = a * e + s * i - o * n,
                        c = a * n + o * e - r * i,
                        u = a * i + r * n - s * e,
                        h = -r * e - s * n - o * i;
                    return this.x = l * a + h * -r + c * -o - u * -s, this.y = c * a + h * -s + u * -r - l * -o, this.z = u * a + h * -o + l * -s - c * -r, this
                }
                project(t) {
                    return this.applyMatrix4(t.matrixWorldInverse).applyMatrix4(t.projectionMatrix)
                }
                unproject(t) {
                    return this.applyMatrix4(t.projectionMatrixInverse).applyMatrix4(t.matrixWorld)
                }
                transformDirection(t) {
                    const e = this.x,
                        n = this.y,
                        i = this.z,
                        r = t.elements;
                    return this.x = r[0] * e + r[4] * n + r[8] * i, this.y = r[1] * e + r[5] * n + r[9] * i, this.z = r[2] * e + r[6] * n + r[10] * i, this.normalize()
                }
                divide(t) {
                    return this.x /= t.x, this.y /= t.y, this.z /= t.z, this
                }
                divideScalar(t) {
                    return this.multiplyScalar(1 / t)
                }
                min(t) {
                    return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this.z = Math.min(this.z, t.z), this
                }
                max(t) {
                    return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this.z = Math.max(this.z, t.z), this
                }
                clamp(t, e) {
                    return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this.z = Math.max(t.z, Math.min(e.z, this.z)), this
                }
                clampScalar(t, e) {
                    return this.x = Math.max(t, Math.min(e, this.x)), this.y = Math.max(t, Math.min(e, this.y)), this.z = Math.max(t, Math.min(e, this.z)), this
                }
                clampLength(t, e) {
                    const n = this.length();
                    return this.divideScalar(n || 1).multiplyScalar(Math.max(t, Math.min(e, n)))
                }
                floor() {
                    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this
                }
                ceil() {
                    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this
                }
                round() {
                    return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this
                }
                roundToZero() {
                    return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this
                }
                negate() {
                    return this.x = -this.x, this.y = -this.y, this.z = -this.z, this
                }
                dot(t) {
                    return this.x * t.x + this.y * t.y + this.z * t.z
                }
                lengthSq() {
                    return this.x * this.x + this.y * this.y + this.z * this.z
                }
                length() {
                    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
                }
                manhattanLength() {
                    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z)
                }
                normalize() {
                    return this.divideScalar(this.length() || 1)
                }
                setLength(t) {
                    return this.normalize().multiplyScalar(t)
                }
                lerp(t, e) {
                    return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this.z += (t.z - this.z) * e, this
                }
                lerpVectors(t, e, n) {
                    return this.x = t.x + (e.x - t.x) * n, this.y = t.y + (e.y - t.y) * n, this.z = t.z + (e.z - t.z) * n, this
                }
                cross(t, e) {
                    return void 0 !== e ? (console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."), this.crossVectors(t, e)) : this.crossVectors(this, t)
                }
                crossVectors(t, e) {
                    const n = t.x,
                        i = t.y,
                        r = t.z,
                        s = e.x,
                        o = e.y,
                        a = e.z;
                    return this.x = i * a - r * o, this.y = r * s - n * a, this.z = n * o - i * s, this
                }
                projectOnVector(t) {
                    const e = t.lengthSq();
                    if (0 === e) return this.set(0, 0, 0);
                    const n = t.dot(this) / e;
                    return this.copy(t).multiplyScalar(n)
                }
                projectOnPlane(t) {
                    return Co.copy(this).projectOnVector(t), this.sub(Co)
                }
                reflect(t) {
                    return this.sub(Co.copy(t).multiplyScalar(2 * this.dot(t)))
                }
                angleTo(t) {
                    const e = Math.sqrt(this.lengthSq() * t.lengthSq());
                    if (0 === e) return Math.PI / 2;
                    const n = this.dot(t) / e;
                    return Math.acos(vo.clamp(n, -1, 1))
                }
                distanceTo(t) {
                    return Math.sqrt(this.distanceToSquared(t))
                }
                distanceToSquared(t) {
                    const e = this.x - t.x,
                        n = this.y - t.y,
                        i = this.z - t.z;
                    return e * e + n * n + i * i
                }
                manhattanDistanceTo(t) {
                    return Math.abs(this.x - t.x) + Math.abs(this.y - t.y) + Math.abs(this.z - t.z)
                }
                setFromSpherical(t) {
                    return this.setFromSphericalCoords(t.radius, t.phi, t.theta)
                }
                setFromSphericalCoords(t, e, n) {
                    const i = Math.sin(e) * t;
                    return this.x = i * Math.sin(n), this.y = Math.cos(e) * t, this.z = i * Math.cos(n), this
                }
                setFromCylindrical(t) {
                    return this.setFromCylindricalCoords(t.radius, t.theta, t.y)
                }
                setFromCylindricalCoords(t, e, n) {
                    return this.x = t * Math.sin(e), this.y = n, this.z = t * Math.cos(e), this
                }
                setFromMatrixPosition(t) {
                    const e = t.elements;
                    return this.x = e[12], this.y = e[13], this.z = e[14], this
                }
                setFromMatrixScale(t) {
                    const e = this.setFromMatrixColumn(t, 0).length(),
                        n = this.setFromMatrixColumn(t, 1).length(),
                        i = this.setFromMatrixColumn(t, 2).length();
                    return this.x = e, this.y = n, this.z = i, this
                }
                setFromMatrixColumn(t, e) {
                    return this.fromArray(t.elements, 4 * e)
                }
                setFromMatrix3Column(t, e) {
                    return this.fromArray(t.elements, 3 * e)
                }
                equals(t) {
                    return t.x === this.x && t.y === this.y && t.z === this.z
                }
                fromArray(t, e = 0) {
                    return this.x = t[e], this.y = t[e + 1], this.z = t[e + 2], this
                }
                toArray(t = [], e = 0) {
                    return t[e] = this.x, t[e + 1] = this.y, t[e + 2] = this.z, t
                }
                fromBufferAttribute(t, e, n) {
                    return void 0 !== n && console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute()."), this.x = t.getX(e), this.y = t.getY(e), this.z = t.getZ(e), this
                }
                random() {
                    return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this
                }
            }
            Ao.prototype.isVector3 = !0;
            const Co = new Ao,
                Lo = new To;
            class Ro {
                constructor(t = new Ao(1 / 0, 1 / 0, 1 / 0), e = new Ao(-1 / 0, -1 / 0, -1 / 0)) {
                    this.min = t, this.max = e
                }
                set(t, e) {
                    return this.min.copy(t), this.max.copy(e), this
                }
                setFromArray(t) {
                    let e = 1 / 0,
                        n = 1 / 0,
                        i = 1 / 0,
                        r = -1 / 0,
                        s = -1 / 0,
                        o = -1 / 0;
                    for (let a = 0, l = t.length; a < l; a += 3) {
                        const l = t[a],
                            c = t[a + 1],
                            u = t[a + 2];
                        l < e && (e = l), c < n && (n = c), u < i && (i = u), l > r && (r = l), c > s && (s = c), u > o && (o = u)
                    }
                    return this.min.set(e, n, i), this.max.set(r, s, o), this
                }
                setFromBufferAttribute(t) {
                    let e = 1 / 0,
                        n = 1 / 0,
                        i = 1 / 0,
                        r = -1 / 0,
                        s = -1 / 0,
                        o = -1 / 0;
                    for (let a = 0, l = t.count; a < l; a++) {
                        const l = t.getX(a),
                            c = t.getY(a),
                            u = t.getZ(a);
                        l < e && (e = l), c < n && (n = c), u < i && (i = u), l > r && (r = l), c > s && (s = c), u > o && (o = u)
                    }
                    return this.min.set(e, n, i), this.max.set(r, s, o), this
                }
                setFromPoints(t) {
                    this.makeEmpty();
                    for (let e = 0, n = t.length; e < n; e++) this.expandByPoint(t[e]);
                    return this
                }
                setFromCenterAndSize(t, e) {
                    const n = Fo.copy(e).multiplyScalar(.5);
                    return this.min.copy(t).sub(n), this.max.copy(t).add(n), this
                }
                setFromObject(t) {
                    return this.makeEmpty(), this.expandByObject(t)
                }
                clone() {
                    return (new this.constructor).copy(this)
                }
                copy(t) {
                    return this.min.copy(t.min), this.max.copy(t.max), this
                }
                makeEmpty() {
                    return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this
                }
                isEmpty() {
                    return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z
                }
                getCenter(t) {
                    return void 0 === t && (console.warn("THREE.Box3: .getCenter() target is now required"), t = new Ao), this.isEmpty() ? t.set(0, 0, 0) : t.addVectors(this.min, this.max).multiplyScalar(.5)
                }
                getSize(t) {
                    return void 0 === t && (console.warn("THREE.Box3: .getSize() target is now required"), t = new Ao), this.isEmpty() ? t.set(0, 0, 0) : t.subVectors(this.max, this.min)
                }
                expandByPoint(t) {
                    return this.min.min(t), this.max.max(t), this
                }
                expandByVector(t) {
                    return this.min.sub(t), this.max.add(t), this
                }
                expandByScalar(t) {
                    return this.min.addScalar(-t), this.max.addScalar(t), this
                }
                expandByObject(t) {
                    t.updateWorldMatrix(!1, !1);
                    const e = t.geometry;
                    void 0 !== e && (null === e.boundingBox && e.computeBoundingBox(), Oo.copy(e.boundingBox), Oo.applyMatrix4(t.matrixWorld), this.union(Oo));
                    const n = t.children;
                    for (let t = 0, e = n.length; t < e; t++) this.expandByObject(n[t]);
                    return this
                }
                containsPoint(t) {
                    return !(t.x < this.min.x || t.x > this.max.x || t.y < this.min.y || t.y > this.max.y || t.z < this.min.z || t.z > this.max.z)
                }
                containsBox(t) {
                    return this.min.x <= t.min.x && t.max.x <= this.max.x && this.min.y <= t.min.y && t.max.y <= this.max.y && this.min.z <= t.min.z && t.max.z <= this.max.z
                }
                getParameter(t, e) {
                    return void 0 === e && (console.warn("THREE.Box3: .getParameter() target is now required"), e = new Ao), e.set((t.x - this.min.x) / (this.max.x - this.min.x), (t.y - this.min.y) / (this.max.y - this.min.y), (t.z - this.min.z) / (this.max.z - this.min.z))
                }
                intersectsBox(t) {
                    return !(t.max.x < this.min.x || t.min.x > this.max.x || t.max.y < this.min.y || t.min.y > this.max.y || t.max.z < this.min.z || t.min.z > this.max.z)
                }
                intersectsSphere(t) {
                    return this.clampPoint(t.center, Fo), Fo.distanceToSquared(t.center) <= t.radius * t.radius
                }
                intersectsPlane(t) {
                    let e, n;
                    return t.normal.x > 0 ? (e = t.normal.x * this.min.x, n = t.normal.x * this.max.x) : (e = t.normal.x * this.max.x, n = t.normal.x * this.min.x), t.normal.y > 0 ? (e += t.normal.y * this.min.y, n += t.normal.y * this.max.y) : (e += t.normal.y * this.max.y, n += t.normal.y * this.min.y), t.normal.z > 0 ? (e += t.normal.z * this.min.z, n += t.normal.z * this.max.z) : (e += t.normal.z * this.max.z, n += t.normal.z * this.min.z), e <= -t.constant && n >= -t.constant
                }
                intersectsTriangle(t) {
                    if (this.isEmpty()) return !1;
                    this.getCenter(Uo), Go.subVectors(this.max, Uo), Io.subVectors(t.a, Uo), No.subVectors(t.b, Uo), Bo.subVectors(t.c, Uo), zo.subVectors(No, Io), ko.subVectors(Bo, No), Ho.subVectors(Io, Bo);
                    let e = [0, -zo.z, zo.y, 0, -ko.z, ko.y, 0, -Ho.z, Ho.y, zo.z, 0, -zo.x, ko.z, 0, -ko.x, Ho.z, 0, -Ho.x, -zo.y, zo.x, 0, -ko.y, ko.x, 0, -Ho.y, Ho.x, 0];
                    return !!jo(e, Io, No, Bo, Go) && (e = [1, 0, 0, 0, 1, 0, 0, 0, 1], !!jo(e, Io, No, Bo, Go) && (Wo.crossVectors(zo, ko), e = [Wo.x, Wo.y, Wo.z], jo(e, Io, No, Bo, Go)))
                }
                clampPoint(t, e) {
                    return void 0 === e && (console.warn("THREE.Box3: .clampPoint() target is now required"), e = new Ao), e.copy(t).clamp(this.min, this.max)
                }
                distanceToPoint(t) {
                    return Fo.copy(t).clamp(this.min, this.max).sub(t).length()
                }
                getBoundingSphere(t) {
                    return void 0 === t && console.error("THREE.Box3: .getBoundingSphere() target is now required"), this.getCenter(t.center), t.radius = .5 * this.getSize(Fo).length(), t
                }
                intersect(t) {
                    return this.min.max(t.min), this.max.min(t.max), this.isEmpty() && this.makeEmpty(), this
                }
                union(t) {
                    return this.min.min(t.min), this.max.max(t.max), this
                }
                applyMatrix4(t) {
                    return this.isEmpty() || (Po[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(t), Po[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(t), Po[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(t), Po[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(t), Po[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(t), Po[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(t), Po[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(t), Po[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(t), this.setFromPoints(Po)), this
                }
                translate(t) {
                    return this.min.add(t), this.max.add(t), this
                }
                equals(t) {
                    return t.min.equals(this.min) && t.max.equals(this.max)
                }
            }
            Ro.prototype.isBox3 = !0;
            const Po = [new Ao, new Ao, new Ao, new Ao, new Ao, new Ao, new Ao, new Ao],
                Fo = new Ao,
                Oo = new Ro,
                Io = new Ao,
                No = new Ao,
                Bo = new Ao,
                zo = new Ao,
                ko = new Ao,
                Ho = new Ao,
                Uo = new Ao,
                Go = new Ao,
                Wo = new Ao,
                Vo = new Ao;

            function jo(t, e, n, i, r) {
                for (let s = 0, o = t.length - 3; s <= o; s += 3) {
                    Vo.fromArray(t, s);
                    const o = r.x * Math.abs(Vo.x) + r.y * Math.abs(Vo.y) + r.z * Math.abs(Vo.z),
                        a = e.dot(Vo),
                        l = n.dot(Vo),
                        c = i.dot(Vo);
                    if (Math.max(-Math.max(a, l, c), Math.min(a, l, c)) > o) return !1
                }
                return !0
            }
            const qo = new Ro;
            class Xo {
                constructor(t = new Ao, e = -1) {
                    this.center = t, this.radius = e
                }
                set(t, e) {
                    return this.center.copy(t), this.radius = e, this
                }
                setFromPoints(t, e) {
                    const n = this.center;
                    void 0 !== e ? n.copy(e) : qo.setFromPoints(t).getCenter(n);
                    let i = 0;
                    for (let e = 0, r = t.length; e < r; e++) i = Math.max(i, n.distanceToSquared(t[e]));
                    return this.radius = Math.sqrt(i), this
                }
                copy(t) {
                    return this.center.copy(t.center), this.radius = t.radius, this
                }
                isEmpty() {
                    return this.radius < 0
                }
                makeEmpty() {
                    return this.center.set(0, 0, 0), this.radius = -1, this
                }
                containsPoint(t) {
                    return t.distanceToSquared(this.center) <= this.radius * this.radius
                }
                distanceToPoint(t) {
                    return t.distanceTo(this.center) - this.radius
                }
                intersectsSphere(t) {
                    const e = this.radius + t.radius;
                    return t.center.distanceToSquared(this.center) <= e * e
                }
                intersectsBox(t) {
                    return t.intersectsSphere(this)
                }
                intersectsPlane(t) {
                    return Math.abs(t.distanceToPoint(this.center)) <= this.radius
                }
                clampPoint(t, e) {
                    const n = this.center.distanceToSquared(t);
                    return void 0 === e && (console.warn("THREE.Sphere: .clampPoint() target is now required"), e = new Ao), e.copy(t), n > this.radius * this.radius && (e.sub(this.center).normalize(), e.multiplyScalar(this.radius).add(this.center)), e
                }
                getBoundingBox(t) {
                    return void 0 === t && (console.warn("THREE.Sphere: .getBoundingBox() target is now required"), t = new Ro), this.isEmpty() ? (t.makeEmpty(), t) : (t.set(this.center, this.center), t.expandByScalar(this.radius), t)
                }
                applyMatrix4(t) {
                    return this.center.applyMatrix4(t), this.radius = this.radius * t.getMaxScaleOnAxis(), this
                }
                translate(t) {
                    return this.center.add(t), this
                }
                equals(t) {
                    return t.center.equals(this.center) && t.radius === this.radius
                }
                clone() {
                    return (new this.constructor).copy(this)
                }
            }
            const Yo = new Ao,
                Zo = new Ao,
                Jo = new Ao,
                Qo = new Ao,
                Ko = new Ao,
                $o = new Ao,
                ta = new Ao;
            class ea {
                constructor(t = new Ao, e = new Ao(0, 0, -1)) {
                    this.origin = t, this.direction = e
                }
                set(t, e) {
                    return this.origin.copy(t), this.direction.copy(e), this
                }
                copy(t) {
                    return this.origin.copy(t.origin), this.direction.copy(t.direction), this
                }
                at(t, e) {
                    return void 0 === e && (console.warn("THREE.Ray: .at() target is now required"), e = new Ao), e.copy(this.direction).multiplyScalar(t).add(this.origin)
                }
                lookAt(t) {
                    return this.direction.copy(t).sub(this.origin).normalize(), this
                }
                recast(t) {
                    return this.origin.copy(this.at(t, Yo)), this
                }
                closestPointToPoint(t, e) {
                    void 0 === e && (console.warn("THREE.Ray: .closestPointToPoint() target is now required"), e = new Ao), e.subVectors(t, this.origin);
                    const n = e.dot(this.direction);
                    return n < 0 ? e.copy(this.origin) : e.copy(this.direction).multiplyScalar(n).add(this.origin)
                }
                distanceToPoint(t) {
                    return Math.sqrt(this.distanceSqToPoint(t))
                }
                distanceSqToPoint(t) {
                    const e = Yo.subVectors(t, this.origin).dot(this.direction);
                    return e < 0 ? this.origin.distanceToSquared(t) : (Yo.copy(this.direction).multiplyScalar(e).add(this.origin), Yo.distanceToSquared(t))
                }
                distanceSqToSegment(t, e, n, i) {
                    Zo.copy(t).add(e).multiplyScalar(.5), Jo.copy(e).sub(t).normalize(), Qo.copy(this.origin).sub(Zo);
                    const r = .5 * t.distanceTo(e),
                        s = -this.direction.dot(Jo),
                        o = Qo.dot(this.direction),
                        a = -Qo.dot(Jo),
                        l = Qo.lengthSq(),
                        c = Math.abs(1 - s * s);
                    let u, h, d, p;
                    if (c > 0)
                        if (u = s * a - o, h = s * o - a, p = r * c, u >= 0)
                            if (h >= -p)
                                if (h <= p) {
                                    const t = 1 / c;
                                    u *= t, h *= t, d = u * (u + s * h + 2 * o) + h * (s * u + h + 2 * a) + l
                                } else h = r, u = Math.max(0, -(s * h + o)), d = -u * u + h * (h + 2 * a) + l;
                    else h = -r, u = Math.max(0, -(s * h + o)), d = -u * u + h * (h + 2 * a) + l;
                    else h <= -p ? (u = Math.max(0, -(-s * r + o)), h = u > 0 ? -r : Math.min(Math.max(-r, -a), r), d = -u * u + h * (h + 2 * a) + l) : h <= p ? (u = 0, h = Math.min(Math.max(-r, -a), r), d = h * (h + 2 * a) + l) : (u = Math.max(0, -(s * r + o)), h = u > 0 ? r : Math.min(Math.max(-r, -a), r), d = -u * u + h * (h + 2 * a) + l);
                    else h = s > 0 ? -r : r, u = Math.max(0, -(s * h + o)), d = -u * u + h * (h + 2 * a) + l;
                    return n && n.copy(this.direction).multiplyScalar(u).add(this.origin), i && i.copy(Jo).multiplyScalar(h).add(Zo), d
                }
                intersectSphere(t, e) {
                    Yo.subVectors(t.center, this.origin);
                    const n = Yo.dot(this.direction),
                        i = Yo.dot(Yo) - n * n,
                        r = t.radius * t.radius;
                    if (i > r) return null;
                    const s = Math.sqrt(r - i),
                        o = n - s,
                        a = n + s;
                    return o < 0 && a < 0 ? null : o < 0 ? this.at(a, e) : this.at(o, e)
                }
                intersectsSphere(t) {
                    return this.distanceSqToPoint(t.center) <= t.radius * t.radius
                }
                distanceToPlane(t) {
                    const e = t.normal.dot(this.direction);
                    if (0 === e) return 0 === t.distanceToPoint(this.origin) ? 0 : null;
                    const n = -(this.origin.dot(t.normal) + t.constant) / e;
                    return n >= 0 ? n : null
                }
                intersectPlane(t, e) {
                    const n = this.distanceToPlane(t);
                    return null === n ? null : this.at(n, e)
                }
                intersectsPlane(t) {
                    const e = t.distanceToPoint(this.origin);
                    if (0 === e) return !0;
                    return t.normal.dot(this.direction) * e < 0
                }
                intersectBox(t, e) {
                    let n, i, r, s, o, a;
                    const l = 1 / this.direction.x,
                        c = 1 / this.direction.y,
                        u = 1 / this.direction.z,
                        h = this.origin;
                    return l >= 0 ? (n = (t.min.x - h.x) * l, i = (t.max.x - h.x) * l) : (n = (t.max.x - h.x) * l, i = (t.min.x - h.x) * l), c >= 0 ? (r = (t.min.y - h.y) * c, s = (t.max.y - h.y) * c) : (r = (t.max.y - h.y) * c, s = (t.min.y - h.y) * c), n > s || r > i ? null : ((r > n || n != n) && (n = r), (s < i || i != i) && (i = s), u >= 0 ? (o = (t.min.z - h.z) * u, a = (t.max.z - h.z) * u) : (o = (t.max.z - h.z) * u, a = (t.min.z - h.z) * u), n > a || o > i ? null : ((o > n || n != n) && (n = o), (a < i || i != i) && (i = a), i < 0 ? null : this.at(n >= 0 ? n : i, e)))
                }
                intersectsBox(t) {
                    return null !== this.intersectBox(t, Yo)
                }
                intersectTriangle(t, e, n, i, r) {
                    Ko.subVectors(e, t), $o.subVectors(n, t), ta.crossVectors(Ko, $o);
                    let s, o = this.direction.dot(ta);
                    if (o > 0) {
                        if (i) return null;
                        s = 1
                    } else {
                        if (!(o < 0)) return null;
                        s = -1, o = -o
                    }
                    Qo.subVectors(this.origin, t);
                    const a = s * this.direction.dot($o.crossVectors(Qo, $o));
                    if (a < 0) return null;
                    const l = s * this.direction.dot(Ko.cross(Qo));
                    if (l < 0) return null;
                    if (a + l > o) return null;
                    const c = -s * Qo.dot(ta);
                    return c < 0 ? null : this.at(c / o, r)
                }
                applyMatrix4(t) {
                    return this.origin.applyMatrix4(t), this.direction.transformDirection(t), this
                }
                equals(t) {
                    return t.origin.equals(this.origin) && t.direction.equals(this.direction)
                }
                clone() {
                    return (new this.constructor).copy(this)
                }
            }
            class na {
                constructor() {
                    this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], arguments.length > 0 && console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.")
                }
                set(t, e, n, i, r, s, o, a, l, c, u, h, d, p, f, m) {
                    const g = this.elements;
                    return g[0] = t, g[4] = e, g[8] = n, g[12] = i, g[1] = r, g[5] = s, g[9] = o, g[13] = a, g[2] = l, g[6] = c, g[10] = u, g[14] = h, g[3] = d, g[7] = p, g[11] = f, g[15] = m, this
                }
                identity() {
                    return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
                }
                clone() {
                    return (new na).fromArray(this.elements)
                }
                copy(t) {
                    const e = this.elements,
                        n = t.elements;
                    return e[0] = n[0], e[1] = n[1], e[2] = n[2], e[3] = n[3], e[4] = n[4], e[5] = n[5], e[6] = n[6], e[7] = n[7], e[8] = n[8], e[9] = n[9], e[10] = n[10], e[11] = n[11], e[12] = n[12], e[13] = n[13], e[14] = n[14], e[15] = n[15], this
                }
                copyPosition(t) {
                    const e = this.elements,
                        n = t.elements;
                    return e[12] = n[12], e[13] = n[13], e[14] = n[14], this
                }
                setFromMatrix3(t) {
                    const e = t.elements;
                    return this.set(e[0], e[3], e[6], 0, e[1], e[4], e[7], 0, e[2], e[5], e[8], 0, 0, 0, 0, 1), this
                }
                extractBasis(t, e, n) {
                    return t.setFromMatrixColumn(this, 0), e.setFromMatrixColumn(this, 1), n.setFromMatrixColumn(this, 2), this
                }
                makeBasis(t, e, n) {
                    return this.set(t.x, e.x, n.x, 0, t.y, e.y, n.y, 0, t.z, e.z, n.z, 0, 0, 0, 0, 1), this
                }
                extractRotation(t) {
                    const e = this.elements,
                        n = t.elements,
                        i = 1 / ia.setFromMatrixColumn(t, 0).length(),
                        r = 1 / ia.setFromMatrixColumn(t, 1).length(),
                        s = 1 / ia.setFromMatrixColumn(t, 2).length();
                    return e[0] = n[0] * i, e[1] = n[1] * i, e[2] = n[2] * i, e[3] = 0, e[4] = n[4] * r, e[5] = n[5] * r, e[6] = n[6] * r, e[7] = 0, e[8] = n[8] * s, e[9] = n[9] * s, e[10] = n[10] * s, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, this
                }
                makeRotationFromEuler(t) {
                    t && t.isEuler || console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");
                    const e = this.elements,
                        n = t.x,
                        i = t.y,
                        r = t.z,
                        s = Math.cos(n),
                        o = Math.sin(n),
                        a = Math.cos(i),
                        l = Math.sin(i),
                        c = Math.cos(r),
                        u = Math.sin(r);
                    if ("XYZ" === t.order) {
                        const t = s * c,
                            n = s * u,
                            i = o * c,
                            r = o * u;
                        e[0] = a * c, e[4] = -a * u, e[8] = l, e[1] = n + i * l, e[5] = t - r * l, e[9] = -o * a, e[2] = r - t * l, e[6] = i + n * l, e[10] = s * a
                    } else if ("YXZ" === t.order) {
                        const t = a * c,
                            n = a * u,
                            i = l * c,
                            r = l * u;
                        e[0] = t + r * o, e[4] = i * o - n, e[8] = s * l, e[1] = s * u, e[5] = s * c, e[9] = -o, e[2] = n * o - i, e[6] = r + t * o, e[10] = s * a
                    } else if ("ZXY" === t.order) {
                        const t = a * c,
                            n = a * u,
                            i = l * c,
                            r = l * u;
                        e[0] = t - r * o, e[4] = -s * u, e[8] = i + n * o, e[1] = n + i * o, e[5] = s * c, e[9] = r - t * o, e[2] = -s * l, e[6] = o, e[10] = s * a
                    } else if ("ZYX" === t.order) {
                        const t = s * c,
                            n = s * u,
                            i = o * c,
                            r = o * u;
                        e[0] = a * c, e[4] = i * l - n, e[8] = t * l + r, e[1] = a * u, e[5] = r * l + t, e[9] = n * l - i, e[2] = -l, e[6] = o * a, e[10] = s * a
                    } else if ("YZX" === t.order) {
                        const t = s * a,
                            n = s * l,
                            i = o * a,
                            r = o * l;
                        e[0] = a * c, e[4] = r - t * u, e[8] = i * u + n, e[1] = u, e[5] = s * c, e[9] = -o * c, e[2] = -l * c, e[6] = n * u + i, e[10] = t - r * u
                    } else if ("XZY" === t.order) {
                        const t = s * a,
                            n = s * l,
                            i = o * a,
                            r = o * l;
                        e[0] = a * c, e[4] = -u, e[8] = l * c, e[1] = t * u + r, e[5] = s * c, e[9] = n * u - i, e[2] = i * u - n, e[6] = o * c, e[10] = r * u + t
                    }
                    return e[3] = 0, e[7] = 0, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, this
                }
                makeRotationFromQuaternion(t) {
                    return this.compose(sa, t, oa)
                }
                lookAt(t, e, n) {
                    const i = this.elements;
                    return ca.subVectors(t, e), 0 === ca.lengthSq() && (ca.z = 1), ca.normalize(), aa.crossVectors(n, ca), 0 === aa.lengthSq() && (1 === Math.abs(n.z) ? ca.x += 1e-4 : ca.z += 1e-4, ca.normalize(), aa.crossVectors(n, ca)), aa.normalize(), la.crossVectors(ca, aa), i[0] = aa.x, i[4] = la.x, i[8] = ca.x, i[1] = aa.y, i[5] = la.y, i[9] = ca.y, i[2] = aa.z, i[6] = la.z, i[10] = ca.z, this
                }
                multiply(t, e) {
                    return void 0 !== e ? (console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."), this.multiplyMatrices(t, e)) : this.multiplyMatrices(this, t)
                }
                premultiply(t) {
                    return this.multiplyMatrices(t, this)
                }
                multiplyMatrices(t, e) {
                    const n = t.elements,
                        i = e.elements,
                        r = this.elements,
                        s = n[0],
                        o = n[4],
                        a = n[8],
                        l = n[12],
                        c = n[1],
                        u = n[5],
                        h = n[9],
                        d = n[13],
                        p = n[2],
                        f = n[6],
                        m = n[10],
                        g = n[14],
                        v = n[3],
                        y = n[7],
                        x = n[11],
                        _ = n[15],
                        b = i[0],
                        w = i[4],
                        M = i[8],
                        S = i[12],
                        E = i[1],
                        D = i[5],
                        T = i[9],
                        A = i[13],
                        C = i[2],
                        L = i[6],
                        R = i[10],
                        P = i[14],
                        F = i[3],
                        O = i[7],
                        I = i[11],
                        N = i[15];
                    return r[0] = s * b + o * E + a * C + l * F, r[4] = s * w + o * D + a * L + l * O, r[8] = s * M + o * T + a * R + l * I, r[12] = s * S + o * A + a * P + l * N, r[1] = c * b + u * E + h * C + d * F, r[5] = c * w + u * D + h * L + d * O, r[9] = c * M + u * T + h * R + d * I, r[13] = c * S + u * A + h * P + d * N, r[2] = p * b + f * E + m * C + g * F, r[6] = p * w + f * D + m * L + g * O, r[10] = p * M + f * T + m * R + g * I, r[14] = p * S + f * A + m * P + g * N, r[3] = v * b + y * E + x * C + _ * F, r[7] = v * w + y * D + x * L + _ * O, r[11] = v * M + y * T + x * R + _ * I, r[15] = v * S + y * A + x * P + _ * N, this
                }
                multiplyScalar(t) {
                    const e = this.elements;
                    return e[0] *= t, e[4] *= t, e[8] *= t, e[12] *= t, e[1] *= t, e[5] *= t, e[9] *= t, e[13] *= t, e[2] *= t, e[6] *= t, e[10] *= t, e[14] *= t, e[3] *= t, e[7] *= t, e[11] *= t, e[15] *= t, this
                }
                determinant() {
                    const t = this.elements,
                        e = t[0],
                        n = t[4],
                        i = t[8],
                        r = t[12],
                        s = t[1],
                        o = t[5],
                        a = t[9],
                        l = t[13],
                        c = t[2],
                        u = t[6],
                        h = t[10],
                        d = t[14];
                    return t[3] * (+r * a * u - i * l * u - r * o * h + n * l * h + i * o * d - n * a * d) + t[7] * (+e * a * d - e * l * h + r * s * h - i * s * d + i * l * c - r * a * c) + t[11] * (+e * l * u - e * o * d - r * s * u + n * s * d + r * o * c - n * l * c) + t[15] * (-i * o * c - e * a * u + e * o * h + i * s * u - n * s * h + n * a * c)
                }
                transpose() {
                    const t = this.elements;
                    let e;
                    return e = t[1], t[1] = t[4], t[4] = e, e = t[2], t[2] = t[8], t[8] = e, e = t[6], t[6] = t[9], t[9] = e, e = t[3], t[3] = t[12], t[12] = e, e = t[7], t[7] = t[13], t[13] = e, e = t[11], t[11] = t[14], t[14] = e, this
                }
                setPosition(t, e, n) {
                    const i = this.elements;
                    return t.isVector3 ? (i[12] = t.x, i[13] = t.y, i[14] = t.z) : (i[12] = t, i[13] = e, i[14] = n), this
                }
                invert() {
                    const t = this.elements,
                        e = t[0],
                        n = t[1],
                        i = t[2],
                        r = t[3],
                        s = t[4],
                        o = t[5],
                        a = t[6],
                        l = t[7],
                        c = t[8],
                        u = t[9],
                        h = t[10],
                        d = t[11],
                        p = t[12],
                        f = t[13],
                        m = t[14],
                        g = t[15],
                        v = u * m * l - f * h * l + f * a * d - o * m * d - u * a * g + o * h * g,
                        y = p * h * l - c * m * l - p * a * d + s * m * d + c * a * g - s * h * g,
                        x = c * f * l - p * u * l + p * o * d - s * f * d - c * o * g + s * u * g,
                        _ = p * u * a - c * f * a - p * o * h + s * f * h + c * o * m - s * u * m,
                        b = e * v + n * y + i * x + r * _;
                    if (0 === b) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
                    const w = 1 / b;
                    return t[0] = v * w, t[1] = (f * h * r - u * m * r - f * i * d + n * m * d + u * i * g - n * h * g) * w, t[2] = (o * m * r - f * a * r + f * i * l - n * m * l - o * i * g + n * a * g) * w, t[3] = (u * a * r - o * h * r - u * i * l + n * h * l + o * i * d - n * a * d) * w, t[4] = y * w, t[5] = (c * m * r - p * h * r + p * i * d - e * m * d - c * i * g + e * h * g) * w, t[6] = (p * a * r - s * m * r - p * i * l + e * m * l + s * i * g - e * a * g) * w, t[7] = (s * h * r - c * a * r + c * i * l - e * h * l - s * i * d + e * a * d) * w, t[8] = x * w, t[9] = (p * u * r - c * f * r - p * n * d + e * f * d + c * n * g - e * u * g) * w, t[10] = (s * f * r - p * o * r + p * n * l - e * f * l - s * n * g + e * o * g) * w, t[11] = (c * o * r - s * u * r - c * n * l + e * u * l + s * n * d - e * o * d) * w, t[12] = _ * w, t[13] = (c * f * i - p * u * i + p * n * h - e * f * h - c * n * m + e * u * m) * w, t[14] = (p * o * i - s * f * i - p * n * a + e * f * a + s * n * m - e * o * m) * w, t[15] = (s * u * i - c * o * i + c * n * a - e * u * a - s * n * h + e * o * h) * w, this
                }
                scale(t) {
                    const e = this.elements,
                        n = t.x,
                        i = t.y,
                        r = t.z;
                    return e[0] *= n, e[4] *= i, e[8] *= r, e[1] *= n, e[5] *= i, e[9] *= r, e[2] *= n, e[6] *= i, e[10] *= r, e[3] *= n, e[7] *= i, e[11] *= r, this
                }
                getMaxScaleOnAxis() {
                    const t = this.elements,
                        e = t[0] * t[0] + t[1] * t[1] + t[2] * t[2],
                        n = t[4] * t[4] + t[5] * t[5] + t[6] * t[6],
                        i = t[8] * t[8] + t[9] * t[9] + t[10] * t[10];
                    return Math.sqrt(Math.max(e, n, i))
                }
                makeTranslation(t, e, n) {
                    return this.set(1, 0, 0, t, 0, 1, 0, e, 0, 0, 1, n, 0, 0, 0, 1), this
                }
                makeRotationX(t) {
                    const e = Math.cos(t),
                        n = Math.sin(t);
                    return this.set(1, 0, 0, 0, 0, e, -n, 0, 0, n, e, 0, 0, 0, 0, 1), this
                }
                makeRotationY(t) {
                    const e = Math.cos(t),
                        n = Math.sin(t);
                    return this.set(e, 0, n, 0, 0, 1, 0, 0, -n, 0, e, 0, 0, 0, 0, 1), this
                }
                makeRotationZ(t) {
                    const e = Math.cos(t),
                        n = Math.sin(t);
                    return this.set(e, -n, 0, 0, n, e, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
                }
                makeRotationAxis(t, e) {
                    const n = Math.cos(e),
                        i = Math.sin(e),
                        r = 1 - n,
                        s = t.x,
                        o = t.y,
                        a = t.z,
                        l = r * s,
                        c = r * o;
                    return this.set(l * s + n, l * o - i * a, l * a + i * o, 0, l * o + i * a, c * o + n, c * a - i * s, 0, l * a - i * o, c * a + i * s, r * a * a + n, 0, 0, 0, 0, 1), this
                }
                makeScale(t, e, n) {
                    return this.set(t, 0, 0, 0, 0, e, 0, 0, 0, 0, n, 0, 0, 0, 0, 1), this
                }
                makeShear(t, e, n) {
                    return this.set(1, e, n, 0, t, 1, n, 0, t, e, 1, 0, 0, 0, 0, 1), this
                }
                compose(t, e, n) {
                    const i = this.elements,
                        r = e._x,
                        s = e._y,
                        o = e._z,
                        a = e._w,
                        l = r + r,
                        c = s + s,
                        u = o + o,
                        h = r * l,
                        d = r * c,
                        p = r * u,
                        f = s * c,
                        m = s * u,
                        g = o * u,
                        v = a * l,
                        y = a * c,
                        x = a * u,
                        _ = n.x,
                        b = n.y,
                        w = n.z;
                    return i[0] = (1 - (f + g)) * _, i[1] = (d + x) * _, i[2] = (p - y) * _, i[3] = 0, i[4] = (d - x) * b, i[5] = (1 - (h + g)) * b, i[6] = (m + v) * b, i[7] = 0, i[8] = (p + y) * w, i[9] = (m - v) * w, i[10] = (1 - (h + f)) * w, i[11] = 0, i[12] = t.x, i[13] = t.y, i[14] = t.z, i[15] = 1, this
                }
                decompose(t, e, n) {
                    const i = this.elements;
                    let r = ia.set(i[0], i[1], i[2]).length();
                    const s = ia.set(i[4], i[5], i[6]).length(),
                        o = ia.set(i[8], i[9], i[10]).length();
                    this.determinant() < 0 && (r = -r), t.x = i[12], t.y = i[13], t.z = i[14], ra.copy(this);
                    const a = 1 / r,
                        l = 1 / s,
                        c = 1 / o;
                    return ra.elements[0] *= a, ra.elements[1] *= a, ra.elements[2] *= a, ra.elements[4] *= l, ra.elements[5] *= l, ra.elements[6] *= l, ra.elements[8] *= c, ra.elements[9] *= c, ra.elements[10] *= c, e.setFromRotationMatrix(ra), n.x = r, n.y = s, n.z = o, this
                }
                makePerspective(t, e, n, i, r, s) {
                    void 0 === s && console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");
                    const o = this.elements,
                        a = 2 * r / (e - t),
                        l = 2 * r / (n - i),
                        c = (e + t) / (e - t),
                        u = (n + i) / (n - i),
                        h = -(s + r) / (s - r),
                        d = -2 * s * r / (s - r);
                    return o[0] = a, o[4] = 0, o[8] = c, o[12] = 0, o[1] = 0, o[5] = l, o[9] = u, o[13] = 0, o[2] = 0, o[6] = 0, o[10] = h, o[14] = d, o[3] = 0, o[7] = 0, o[11] = -1, o[15] = 0, this
                }
                makeOrthographic(t, e, n, i, r, s) {
                    const o = this.elements,
                        a = 1 / (e - t),
                        l = 1 / (n - i),
                        c = 1 / (s - r),
                        u = (e + t) * a,
                        h = (n + i) * l,
                        d = (s + r) * c;
                    return o[0] = 2 * a, o[4] = 0, o[8] = 0, o[12] = -u, o[1] = 0, o[5] = 2 * l, o[9] = 0, o[13] = -h, o[2] = 0, o[6] = 0, o[10] = -2 * c, o[14] = -d, o[3] = 0, o[7] = 0, o[11] = 0, o[15] = 1, this
                }
                equals(t) {
                    const e = this.elements,
                        n = t.elements;
                    for (let t = 0; t < 16; t++)
                        if (e[t] !== n[t]) return !1;
                    return !0
                }
                fromArray(t, e = 0) {
                    for (let n = 0; n < 16; n++) this.elements[n] = t[n + e];
                    return this
                }
                toArray(t = [], e = 0) {
                    const n = this.elements;
                    return t[e] = n[0], t[e + 1] = n[1], t[e + 2] = n[2], t[e + 3] = n[3], t[e + 4] = n[4], t[e + 5] = n[5], t[e + 6] = n[6], t[e + 7] = n[7], t[e + 8] = n[8], t[e + 9] = n[9], t[e + 10] = n[10], t[e + 11] = n[11], t[e + 12] = n[12], t[e + 13] = n[13], t[e + 14] = n[14], t[e + 15] = n[15], t
                }
            }
            na.prototype.isMatrix4 = !0;
            const ia = new Ao,
                ra = new na,
                sa = new Ao(0, 0, 0),
                oa = new Ao(1, 1, 1),
                aa = new Ao,
                la = new Ao,
                ca = new Ao,
                ua = new na,
                ha = new To;
            class da {
                constructor(t = 0, e = 0, n = 0, i = da.DefaultOrder) {
                    this._x = t, this._y = e, this._z = n, this._order = i
                }
                get x() {
                    return this._x
                }
                set x(t) {
                    this._x = t, this._onChangeCallback()
                }
                get y() {
                    return this._y
                }
                set y(t) {
                    this._y = t, this._onChangeCallback()
                }
                get z() {
                    return this._z
                }
                set z(t) {
                    this._z = t, this._onChangeCallback()
                }
                get order() {
                    return this._order
                }
                set order(t) {
                    this._order = t, this._onChangeCallback()
                }
                set(t, e, n, i) {
                    return this._x = t, this._y = e, this._z = n, this._order = i || this._order, this._onChangeCallback(), this
                }
                clone() {
                    return new this.constructor(this._x, this._y, this._z, this._order)
                }
                copy(t) {
                    return this._x = t._x, this._y = t._y, this._z = t._z, this._order = t._order, this._onChangeCallback(), this
                }
                setFromRotationMatrix(t, e, n) {
                    const i = vo.clamp,
                        r = t.elements,
                        s = r[0],
                        o = r[4],
                        a = r[8],
                        l = r[1],
                        c = r[5],
                        u = r[9],
                        h = r[2],
                        d = r[6],
                        p = r[10];
                    switch (e = e || this._order) {
                        case "XYZ":
                            this._y = Math.asin(i(a, -1, 1)), Math.abs(a) < .9999999 ? (this._x = Math.atan2(-u, p), this._z = Math.atan2(-o, s)) : (this._x = Math.atan2(d, c), this._z = 0);
                            break;
                        case "YXZ":
                            this._x = Math.asin(-i(u, -1, 1)), Math.abs(u) < .9999999 ? (this._y = Math.atan2(a, p), this._z = Math.atan2(l, c)) : (this._y = Math.atan2(-h, s), this._z = 0);
                            break;
                        case "ZXY":
                            this._x = Math.asin(i(d, -1, 1)), Math.abs(d) < .9999999 ? (this._y = Math.atan2(-h, p), this._z = Math.atan2(-o, c)) : (this._y = 0, this._z = Math.atan2(l, s));
                            break;
                        case "ZYX":
                            this._y = Math.asin(-i(h, -1, 1)), Math.abs(h) < .9999999 ? (this._x = Math.atan2(d, p), this._z = Math.atan2(l, s)) : (this._x = 0, this._z = Math.atan2(-o, c));
                            break;
                        case "YZX":
                            this._z = Math.asin(i(l, -1, 1)), Math.abs(l) < .9999999 ? (this._x = Math.atan2(-u, c), this._y = Math.atan2(-h, s)) : (this._x = 0, this._y = Math.atan2(a, p));
                            break;
                        case "XZY":
                            this._z = Math.asin(-i(o, -1, 1)), Math.abs(o) < .9999999 ? (this._x = Math.atan2(d, c), this._y = Math.atan2(a, s)) : (this._x = Math.atan2(-u, p), this._y = 0);
                            break;
                        default:
                            console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + e)
                    }
                    return this._order = e, !1 !== n && this._onChangeCallback(), this
                }
                setFromQuaternion(t, e, n) {
                    return ua.makeRotationFromQuaternion(t), this.setFromRotationMatrix(ua, e, n)
                }
                setFromVector3(t, e) {
                    return this.set(t.x, t.y, t.z, e || this._order)
                }
                reorder(t) {
                    return ha.setFromEuler(this), this.setFromQuaternion(ha, t)
                }
                equals(t) {
                    return t._x === this._x && t._y === this._y && t._z === this._z && t._order === this._order
                }
                fromArray(t) {
                    return this._x = t[0], this._y = t[1], this._z = t[2], void 0 !== t[3] && (this._order = t[3]), this._onChangeCallback(), this
                }
                toArray(t = [], e = 0) {
                    return t[e] = this._x, t[e + 1] = this._y, t[e + 2] = this._z, t[e + 3] = this._order, t
                }
                toVector3(t) {
                    return t ? t.set(this._x, this._y, this._z) : new Ao(this._x, this._y, this._z)
                }
                _onChange(t) {
                    return this._onChangeCallback = t, this
                }
                _onChangeCallback() {}
            }
            da.prototype.isEuler = !0, da.DefaultOrder = "XYZ", da.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"];
            class pa {
                constructor() {
                    this.mask = 1
                }
                set(t) {
                    this.mask = 1 << t | 0
                }
                enable(t) {
                    this.mask |= 1 << t | 0
                }
                enableAll() {
                    this.mask = -1
                }
                toggle(t) {
                    this.mask ^= 1 << t | 0
                }
                disable(t) {
                    this.mask &= ~(1 << t | 0)
                }
                disableAll() {
                    this.mask = 0
                }
                test(t) {
                    return 0 != (this.mask & t.mask)
                }
            }
            let fa = 0;
            const ma = new Ao,
                ga = new To,
                va = new na,
                ya = new Ao,
                xa = new Ao,
                _a = new Ao,
                ba = new To,
                wa = new Ao(1, 0, 0),
                Ma = new Ao(0, 1, 0),
                Sa = new Ao(0, 0, 1),
                Ea = {
                    type: "added"
                },
                Da = {
                    type: "removed"
                };

            function Ta() {
                Object.defineProperty(this, "id", {
                    value: fa++
                }), this.uuid = vo.generateUUID(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = Ta.DefaultUp.clone();
                const t = new Ao,
                    e = new da,
                    n = new To,
                    i = new Ao(1, 1, 1);
                e._onChange((function() {
                    n.setFromEuler(e, !1)
                })), n._onChange((function() {
                    e.setFromQuaternion(n, void 0, !1)
                })), Object.defineProperties(this, {
                    position: {
                        configurable: !0,
                        enumerable: !0,
                        value: t
                    },
                    rotation: {
                        configurable: !0,
                        enumerable: !0,
                        value: e
                    },
                    quaternion: {
                        configurable: !0,
                        enumerable: !0,
                        value: n
                    },
                    scale: {
                        configurable: !0,
                        enumerable: !0,
                        value: i
                    },
                    modelViewMatrix: {
                        value: new na
                    },
                    normalMatrix: {
                        value: new xo
                    }
                }), this.matrix = new na, this.matrixWorld = new na, this.matrixAutoUpdate = Ta.DefaultMatrixAutoUpdate, this.matrixWorldNeedsUpdate = !1, this.layers = new pa, this.visible = !0, this.castShadow = !1, this.receiveShadow = !1, this.frustumCulled = !0, this.renderOrder = 0, this.animations = [], this.userData = {}
            }
            Ta.DefaultUp = new Ao(0, 1, 0), Ta.DefaultMatrixAutoUpdate = !0, Ta.prototype = Object.assign(Object.create(fo.prototype), {
                constructor: Ta,
                isObject3D: !0,
                onBeforeRender: function() {},
                onAfterRender: function() {},
                applyMatrix4: function(t) {
                    this.matrixAutoUpdate && this.updateMatrix(), this.matrix.premultiply(t), this.matrix.decompose(this.position, this.quaternion, this.scale)
                },
                applyQuaternion: function(t) {
                    return this.quaternion.premultiply(t), this
                },
                setRotationFromAxisAngle: function(t, e) {
                    this.quaternion.setFromAxisAngle(t, e)
                },
                setRotationFromEuler: function(t) {
                    this.quaternion.setFromEuler(t, !0)
                },
                setRotationFromMatrix: function(t) {
                    this.quaternion.setFromRotationMatrix(t)
                },
                setRotationFromQuaternion: function(t) {
                    this.quaternion.copy(t)
                },
                rotateOnAxis: function(t, e) {
                    return ga.setFromAxisAngle(t, e), this.quaternion.multiply(ga), this
                },
                rotateOnWorldAxis: function(t, e) {
                    return ga.setFromAxisAngle(t, e), this.quaternion.premultiply(ga), this
                },
                rotateX: function(t) {
                    return this.rotateOnAxis(wa, t)
                },
                rotateY: function(t) {
                    return this.rotateOnAxis(Ma, t)
                },
                rotateZ: function(t) {
                    return this.rotateOnAxis(Sa, t)
                },
                translateOnAxis: function(t, e) {
                    return ma.copy(t).applyQuaternion(this.quaternion), this.position.add(ma.multiplyScalar(e)), this
                },
                translateX: function(t) {
                    return this.translateOnAxis(wa, t)
                },
                translateY: function(t) {
                    return this.translateOnAxis(Ma, t)
                },
                translateZ: function(t) {
                    return this.translateOnAxis(Sa, t)
                },
                localToWorld: function(t) {
                    return t.applyMatrix4(this.matrixWorld)
                },
                worldToLocal: function(t) {
                    return t.applyMatrix4(va.copy(this.matrixWorld).invert())
                },
                lookAt: function(t, e, n) {
                    t.isVector3 ? ya.copy(t) : ya.set(t, e, n);
                    const i = this.parent;
                    this.updateWorldMatrix(!0, !1), xa.setFromMatrixPosition(this.matrixWorld), this.isCamera || this.isLight ? va.lookAt(xa, ya, this.up) : va.lookAt(ya, xa, this.up), this.quaternion.setFromRotationMatrix(va), i && (va.extractRotation(i.matrixWorld), ga.setFromRotationMatrix(va), this.quaternion.premultiply(ga.invert()))
                },
                add: function(t) {
                    if (arguments.length > 1) {
                        for (let t = 0; t < arguments.length; t++) this.add(arguments[t]);
                        return this
                    }
                    return t === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", t), this) : (t && t.isObject3D ? (null !== t.parent && t.parent.remove(t), t.parent = this, this.children.push(t), t.dispatchEvent(Ea)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", t), this)
                },
                remove: function(t) {
                    if (arguments.length > 1) {
                        for (let t = 0; t < arguments.length; t++) this.remove(arguments[t]);
                        return this
                    }
                    const e = this.children.indexOf(t);
                    return -1 !== e && (t.parent = null, this.children.splice(e, 1), t.dispatchEvent(Da)), this
                },
                clear: function() {
                    for (let t = 0; t < this.children.length; t++) {
                        const e = this.children[t];
                        e.parent = null, e.dispatchEvent(Da)
                    }
                    return this.children.length = 0, this
                },
                attach: function(t) {
                    return this.updateWorldMatrix(!0, !1), va.copy(this.matrixWorld).invert(), null !== t.parent && (t.parent.updateWorldMatrix(!0, !1), va.multiply(t.parent.matrixWorld)), t.applyMatrix4(va), this.add(t), t.updateWorldMatrix(!1, !0), this
                },
                getObjectById: function(t) {
                    return this.getObjectByProperty("id", t)
                },
                getObjectByName: function(t) {
                    return this.getObjectByProperty("name", t)
                },
                getObjectByProperty: function(t, e) {
                    if (this[t] === e) return this;
                    for (let n = 0, i = this.children.length; n < i; n++) {
                        const i = this.children[n].getObjectByProperty(t, e);
                        if (void 0 !== i) return i
                    }
                },
                getWorldPosition: function(t) {
                    return void 0 === t && (console.warn("THREE.Object3D: .getWorldPosition() target is now required"), t = new Ao), this.updateWorldMatrix(!0, !1), t.setFromMatrixPosition(this.matrixWorld)
                },
                getWorldQuaternion: function(t) {
                    return void 0 === t && (console.warn("THREE.Object3D: .getWorldQuaternion() target is now required"), t = new To), this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(xa, t, _a), t
                },
                getWorldScale: function(t) {
                    return void 0 === t && (console.warn("THREE.Object3D: .getWorldScale() target is now required"), t = new Ao), this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(xa, ba, t), t
                },
                getWorldDirection: function(t) {
                    void 0 === t && (console.warn("THREE.Object3D: .getWorldDirection() target is now required"), t = new Ao), this.updateWorldMatrix(!0, !1);
                    const e = this.matrixWorld.elements;
                    return t.set(e[8], e[9], e[10]).normalize()
                },
                raycast: function() {},
                traverse: function(t) {
                    t(this);
                    const e = this.children;
                    for (let n = 0, i = e.length; n < i; n++) e[n].traverse(t)
                },
                traverseVisible: function(t) {
                    if (!1 === this.visible) return;
                    t(this);
                    const e = this.children;
                    for (let n = 0, i = e.length; n < i; n++) e[n].traverseVisible(t)
                },
                traverseAncestors: function(t) {
                    const e = this.parent;
                    null !== e && (t(e), e.traverseAncestors(t))
                },
                updateMatrix: function() {
                    this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0
                },
                updateMatrixWorld: function(t) {
                    this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || t) && (null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), this.matrixWorldNeedsUpdate = !1, t = !0);
                    const e = this.children;
                    for (let n = 0, i = e.length; n < i; n++) e[n].updateMatrixWorld(t)
                },
                updateWorldMatrix: function(t, e) {
                    const n = this.parent;
                    if (!0 === t && null !== n && n.updateWorldMatrix(!0, !1), this.matrixAutoUpdate && this.updateMatrix(), null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), !0 === e) {
                        const t = this.children;
                        for (let e = 0, n = t.length; e < n; e++) t[e].updateWorldMatrix(!1, !0)
                    }
                },
                toJSON: function(t) {
                    const e = void 0 === t || "string" == typeof t,
                        n = {};
                    e && (t = {
                        geometries: {},
                        materials: {},
                        textures: {},
                        images: {},
                        shapes: {},
                        skeletons: {},
                        animations: {}
                    }, n.metadata = {
                        version: 4.5,
                        type: "Object",
                        generator: "Object3D.toJSON"
                    });
                    const i = {};

                    function r(e, n) {
                        return void 0 === e[n.uuid] && (e[n.uuid] = n.toJSON(t)), n.uuid
                    }
                    if (i.uuid = this.uuid, i.type = this.type, "" !== this.name && (i.name = this.name), !0 === this.castShadow && (i.castShadow = !0), !0 === this.receiveShadow && (i.receiveShadow = !0), !1 === this.visible && (i.visible = !1), !1 === this.frustumCulled && (i.frustumCulled = !1), 0 !== this.renderOrder && (i.renderOrder = this.renderOrder), "{}" !== JSON.stringify(this.userData) && (i.userData = this.userData), i.layers = this.layers.mask, i.matrix = this.matrix.toArray(), !1 === this.matrixAutoUpdate && (i.matrixAutoUpdate = !1), this.isInstancedMesh && (i.type = "InstancedMesh", i.count = this.count, i.instanceMatrix = this.instanceMatrix.toJSON()), this.isMesh || this.isLine || this.isPoints) {
                        i.geometry = r(t.geometries, this.geometry);
                        const e = this.geometry.parameters;
                        if (void 0 !== e && void 0 !== e.shapes) {
                            const n = e.shapes;
                            if (Array.isArray(n))
                                for (let e = 0, i = n.length; e < i; e++) {
                                    const i = n[e];
                                    r(t.shapes, i)
                                } else r(t.shapes, n)
                        }
                    }
                    if (this.isSkinnedMesh && (i.bindMode = this.bindMode, i.bindMatrix = this.bindMatrix.toArray(), void 0 !== this.skeleton && (r(t.skeletons, this.skeleton), i.skeleton = this.skeleton.uuid)), void 0 !== this.material)
                        if (Array.isArray(this.material)) {
                            const e = [];
                            for (let n = 0, i = this.material.length; n < i; n++) e.push(r(t.materials, this.material[n]));
                            i.material = e
                        } else i.material = r(t.materials, this.material);
                    if (this.children.length > 0) {
                        i.children = [];
                        for (let e = 0; e < this.children.length; e++) i.children.push(this.children[e].toJSON(t).object)
                    }
                    if (this.animations.length > 0) {
                        i.animations = [];
                        for (let e = 0; e < this.animations.length; e++) {
                            const n = this.animations[e];
                            i.animations.push(r(t.animations, n))
                        }
                    }
                    if (e) {
                        const e = s(t.geometries),
                            i = s(t.materials),
                            r = s(t.textures),
                            o = s(t.images),
                            a = s(t.shapes),
                            l = s(t.skeletons),
                            c = s(t.animations);
                        e.length > 0 && (n.geometries = e), i.length > 0 && (n.materials = i), r.length > 0 && (n.textures = r), o.length > 0 && (n.images = o), a.length > 0 && (n.shapes = a), l.length > 0 && (n.skeletons = l), c.length > 0 && (n.animations = c)
                    }
                    return n.object = i, n;

                    function s(t) {
                        const e = [];
                        for (const n in t) {
                            const i = t[n];
                            delete i.metadata, e.push(i)
                        }
                        return e
                    }
                },
                clone: function(t) {
                    return (new this.constructor).copy(this, t)
                },
                copy: function(t, e = !0) {
                    if (this.name = t.name, this.up.copy(t.up), this.position.copy(t.position), this.rotation.order = t.rotation.order, this.quaternion.copy(t.quaternion), this.scale.copy(t.scale), this.matrix.copy(t.matrix), this.matrixWorld.copy(t.matrixWorld), this.matrixAutoUpdate = t.matrixAutoUpdate, this.matrixWorldNeedsUpdate = t.matrixWorldNeedsUpdate, this.layers.mask = t.layers.mask, this.visible = t.visible, this.castShadow = t.castShadow, this.receiveShadow = t.receiveShadow, this.frustumCulled = t.frustumCulled, this.renderOrder = t.renderOrder, this.userData = JSON.parse(JSON.stringify(t.userData)), !0 === e)
                        for (let e = 0; e < t.children.length; e++) {
                            const n = t.children[e];
                            this.add(n.clone())
                        }
                    return this
                }
            });
            const Aa = new Ao,
                Ca = new Ao,
                La = new xo;
            class Ra {
                constructor(t = new Ao(1, 0, 0), e = 0) {
                    this.normal = t, this.constant = e
                }
                set(t, e) {
                    return this.normal.copy(t), this.constant = e, this
                }
                setComponents(t, e, n, i) {
                    return this.normal.set(t, e, n), this.constant = i, this
                }
                setFromNormalAndCoplanarPoint(t, e) {
                    return this.normal.copy(t), this.constant = -e.dot(this.normal), this
                }
                setFromCoplanarPoints(t, e, n) {
                    const i = Aa.subVectors(n, e).cross(Ca.subVectors(t, e)).normalize();
                    return this.setFromNormalAndCoplanarPoint(i, t), this
                }
                copy(t) {
                    return this.normal.copy(t.normal), this.constant = t.constant, this
                }
                normalize() {
                    const t = 1 / this.normal.length();
                    return this.normal.multiplyScalar(t), this.constant *= t, this
                }
                negate() {
                    return this.constant *= -1, this.normal.negate(), this
                }
                distanceToPoint(t) {
                    return this.normal.dot(t) + this.constant
                }
                distanceToSphere(t) {
                    return this.distanceToPoint(t.center) - t.radius
                }
                projectPoint(t, e) {
                    return void 0 === e && (console.warn("THREE.Plane: .projectPoint() target is now required"), e = new Ao), e.copy(this.normal).multiplyScalar(-this.distanceToPoint(t)).add(t)
                }
                intersectLine(t, e) {
                    void 0 === e && (console.warn("THREE.Plane: .intersectLine() target is now required"), e = new Ao);
                    const n = t.delta(Aa),
                        i = this.normal.dot(n);
                    if (0 === i) return 0 === this.distanceToPoint(t.start) ? e.copy(t.start) : void 0;
                    const r = -(t.start.dot(this.normal) + this.constant) / i;
                    return r < 0 || r > 1 ? void 0 : e.copy(n).multiplyScalar(r).add(t.start)
                }
                intersectsLine(t) {
                    const e = this.distanceToPoint(t.start),
                        n = this.distanceToPoint(t.end);
                    return e < 0 && n > 0 || n < 0 && e > 0
                }
                intersectsBox(t) {
                    return t.intersectsPlane(this)
                }
                intersectsSphere(t) {
                    return t.intersectsPlane(this)
                }
                coplanarPoint(t) {
                    return void 0 === t && (console.warn("THREE.Plane: .coplanarPoint() target is now required"), t = new Ao), t.copy(this.normal).multiplyScalar(-this.constant)
                }
                applyMatrix4(t, e) {
                    const n = e || La.getNormalMatrix(t),
                        i = this.coplanarPoint(Aa).applyMatrix4(t),
                        r = this.normal.applyMatrix3(n).normalize();
                    return this.constant = -i.dot(r), this
                }
                translate(t) {
                    return this.constant -= t.dot(this.normal), this
                }
                equals(t) {
                    return t.normal.equals(this.normal) && t.constant === this.constant
                }
                clone() {
                    return (new this.constructor).copy(this)
                }
            }
            Ra.prototype.isPlane = !0;
            const Pa = new Ao,
                Fa = new Ao,
                Oa = new Ao,
                Ia = new Ao,
                Na = new Ao,
                Ba = new Ao,
                za = new Ao,
                ka = new Ao,
                Ha = new Ao,
                Ua = new Ao;
            class Ga {
                constructor(t = new Ao, e = new Ao, n = new Ao) {
                    this.a = t, this.b = e, this.c = n
                }
                static getNormal(t, e, n, i) {
                    void 0 === i && (console.warn("THREE.Triangle: .getNormal() target is now required"), i = new Ao), i.subVectors(n, e), Pa.subVectors(t, e), i.cross(Pa);
                    const r = i.lengthSq();
                    return r > 0 ? i.multiplyScalar(1 / Math.sqrt(r)) : i.set(0, 0, 0)
                }
                static getBarycoord(t, e, n, i, r) {
                    Pa.subVectors(i, e), Fa.subVectors(n, e), Oa.subVectors(t, e);
                    const s = Pa.dot(Pa),
                        o = Pa.dot(Fa),
                        a = Pa.dot(Oa),
                        l = Fa.dot(Fa),
                        c = Fa.dot(Oa),
                        u = s * l - o * o;
                    if (void 0 === r && (console.warn("THREE.Triangle: .getBarycoord() target is now required"), r = new Ao), 0 === u) return r.set(-2, -1, -1);
                    const h = 1 / u,
                        d = (l * a - o * c) * h,
                        p = (s * c - o * a) * h;
                    return r.set(1 - d - p, p, d)
                }
                static containsPoint(t, e, n, i) {
                    return this.getBarycoord(t, e, n, i, Ia), Ia.x >= 0 && Ia.y >= 0 && Ia.x + Ia.y <= 1
                }
                static getUV(t, e, n, i, r, s, o, a) {
                    return this.getBarycoord(t, e, n, i, Ia), a.set(0, 0), a.addScaledVector(r, Ia.x), a.addScaledVector(s, Ia.y), a.addScaledVector(o, Ia.z), a
                }
                static isFrontFacing(t, e, n, i) {
                    return Pa.subVectors(n, e), Fa.subVectors(t, e), Pa.cross(Fa).dot(i) < 0
                }
                set(t, e, n) {
                    return this.a.copy(t), this.b.copy(e), this.c.copy(n), this
                }
                setFromPointsAndIndices(t, e, n, i) {
                    return this.a.copy(t[e]), this.b.copy(t[n]), this.c.copy(t[i]), this
                }
                clone() {
                    return (new this.constructor).copy(this)
                }
                copy(t) {
                    return this.a.copy(t.a), this.b.copy(t.b), this.c.copy(t.c), this
                }
                getArea() {
                    return Pa.subVectors(this.c, this.b), Fa.subVectors(this.a, this.b), .5 * Pa.cross(Fa).length()
                }
                getMidpoint(t) {
                    return void 0 === t && (console.warn("THREE.Triangle: .getMidpoint() target is now required"), t = new Ao), t.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3)
                }
                getNormal(t) {
                    return Ga.getNormal(this.a, this.b, this.c, t)
                }
                getPlane(t) {
                    return void 0 === t && (console.warn("THREE.Triangle: .getPlane() target is now required"), t = new Ra), t.setFromCoplanarPoints(this.a, this.b, this.c)
                }
                getBarycoord(t, e) {
                    return Ga.getBarycoord(t, this.a, this.b, this.c, e)
                }
                getUV(t, e, n, i, r) {
                    return Ga.getUV(t, this.a, this.b, this.c, e, n, i, r)
                }
                containsPoint(t) {
                    return Ga.containsPoint(t, this.a, this.b, this.c)
                }
                isFrontFacing(t) {
                    return Ga.isFrontFacing(this.a, this.b, this.c, t)
                }
                intersectsBox(t) {
                    return t.intersectsTriangle(this)
                }
                closestPointToPoint(t, e) {
                    void 0 === e && (console.warn("THREE.Triangle: .closestPointToPoint() target is now required"), e = new Ao);
                    const n = this.a,
                        i = this.b,
                        r = this.c;
                    let s, o;
                    Na.subVectors(i, n), Ba.subVectors(r, n), ka.subVectors(t, n);
                    const a = Na.dot(ka),
                        l = Ba.dot(ka);
                    if (a <= 0 && l <= 0) return e.copy(n);
                    Ha.subVectors(t, i);
                    const c = Na.dot(Ha),
                        u = Ba.dot(Ha);
                    if (c >= 0 && u <= c) return e.copy(i);
                    const h = a * u - c * l;
                    if (h <= 0 && a >= 0 && c <= 0) return s = a / (a - c), e.copy(n).addScaledVector(Na, s);
                    Ua.subVectors(t, r);
                    const d = Na.dot(Ua),
                        p = Ba.dot(Ua);
                    if (p >= 0 && d <= p) return e.copy(r);
                    const f = d * l - a * p;
                    if (f <= 0 && l >= 0 && p <= 0) return o = l / (l - p), e.copy(n).addScaledVector(Ba, o);
                    const m = c * p - d * u;
                    if (m <= 0 && u - c >= 0 && d - p >= 0) return za.subVectors(r, i), o = (u - c) / (u - c + (d - p)), e.copy(i).addScaledVector(za, o);
                    const g = 1 / (m + f + h);
                    return s = f * g, o = h * g, e.copy(n).addScaledVector(Na, s).addScaledVector(Ba, o)
                }
                equals(t) {
                    return t.a.equals(this.a) && t.b.equals(this.b) && t.c.equals(this.c)
                }
            }
            let Wa = 0;

            function Va() {
                Object.defineProperty(this, "id", {
                    value: Wa++
                }), this.uuid = vo.generateUUID(), this.name = "", this.type = "Material", this.fog = !0, this.blending = 1, this.side = 0, this.vertexColors = !1, this.opacity = 1, this.transparent = !1, this.blendSrc = 204, this.blendDst = 205, this.blendEquation = Cs, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.depthFunc = 3, this.depthTest = !0, this.depthWrite = !0, this.stencilWriteMask = 255, this.stencilFunc = 519, this.stencilRef = 0, this.stencilFuncMask = 255, this.stencilFail = co, this.stencilZFail = co, this.stencilZPass = co, this.stencilWrite = !1, this.clippingPlanes = null, this.clipIntersection = !1, this.clipShadows = !1, this.shadowSide = null, this.colorWrite = !0, this.precision = null, this.polygonOffset = !1, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.dithering = !1, this.alphaTest = 0, this.premultipliedAlpha = !1, this.visible = !0, this.toneMapped = !0, this.userData = {}, this.version = 0
            }
            Va.prototype = Object.assign(Object.create(fo.prototype), {
                constructor: Va,
                isMaterial: !0,
                onBeforeCompile: function() {},
                customProgramCacheKey: function() {
                    return this.onBeforeCompile.toString()
                },
                setValues: function(t) {
                    if (void 0 !== t)
                        for (const e in t) {
                            const n = t[e];
                            if (void 0 === n) {
                                console.warn("THREE.Material: '" + e + "' parameter is undefined.");
                                continue
                            }
                            if ("shading" === e) {
                                console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."), this.flatShading = 1 === n;
                                continue
                            }
                            const i = this[e];
                            void 0 !== i ? i && i.isColor ? i.set(n) : i && i.isVector3 && n && n.isVector3 ? i.copy(n) : this[e] = n : console.warn("THREE." + this.type + ": '" + e + "' is not a property of this material.")
                        }
                },
                toJSON: function(t) {
                    const e = void 0 === t || "string" == typeof t;
                    e && (t = {
                        textures: {},
                        images: {}
                    });
                    const n = {
                        metadata: {
                            version: 4.5,
                            type: "Material",
                            generator: "Material.toJSON"
                        }
                    };

                    function i(t) {
                        const e = [];
                        for (const n in t) {
                            const i = t[n];
                            delete i.metadata, e.push(i)
                        }
                        return e
                    }
                    if (n.uuid = this.uuid, n.type = this.type, "" !== this.name && (n.name = this.name), this.color && this.color.isColor && (n.color = this.color.getHex()), void 0 !== this.roughness && (n.roughness = this.roughness), void 0 !== this.metalness && (n.metalness = this.metalness), this.sheen && this.sheen.isColor && (n.sheen = this.sheen.getHex()), this.emissive && this.emissive.isColor && (n.emissive = this.emissive.getHex()), this.emissiveIntensity && 1 !== this.emissiveIntensity && (n.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (n.specular = this.specular.getHex()), void 0 !== this.shininess && (n.shininess = this.shininess), void 0 !== this.clearcoat && (n.clearcoat = this.clearcoat), void 0 !== this.clearcoatRoughness && (n.clearcoatRoughness = this.clearcoatRoughness), this.clearcoatMap && this.clearcoatMap.isTexture && (n.clearcoatMap = this.clearcoatMap.toJSON(t).uuid), this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (n.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(t).uuid), this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (n.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(t).uuid, n.clearcoatNormalScale = this.clearcoatNormalScale.toArray()), this.map && this.map.isTexture && (n.map = this.map.toJSON(t).uuid), this.matcap && this.matcap.isTexture && (n.matcap = this.matcap.toJSON(t).uuid), this.alphaMap && this.alphaMap.isTexture && (n.alphaMap = this.alphaMap.toJSON(t).uuid), this.lightMap && this.lightMap.isTexture && (n.lightMap = this.lightMap.toJSON(t).uuid, n.lightMapIntensity = this.lightMapIntensity), this.aoMap && this.aoMap.isTexture && (n.aoMap = this.aoMap.toJSON(t).uuid, n.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (n.bumpMap = this.bumpMap.toJSON(t).uuid, n.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (n.normalMap = this.normalMap.toJSON(t).uuid, n.normalMapType = this.normalMapType, n.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (n.displacementMap = this.displacementMap.toJSON(t).uuid, n.displacementScale = this.displacementScale, n.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (n.roughnessMap = this.roughnessMap.toJSON(t).uuid), this.metalnessMap && this.metalnessMap.isTexture && (n.metalnessMap = this.metalnessMap.toJSON(t).uuid), this.emissiveMap && this.emissiveMap.isTexture && (n.emissiveMap = this.emissiveMap.toJSON(t).uuid), this.specularMap && this.specularMap.isTexture && (n.specularMap = this.specularMap.toJSON(t).uuid), this.envMap && this.envMap.isTexture && (n.envMap = this.envMap.toJSON(t).uuid, n.reflectivity = this.reflectivity, n.refractionRatio = this.refractionRatio, void 0 !== this.combine && (n.combine = this.combine), void 0 !== this.envMapIntensity && (n.envMapIntensity = this.envMapIntensity)), this.gradientMap && this.gradientMap.isTexture && (n.gradientMap = this.gradientMap.toJSON(t).uuid), void 0 !== this.size && (n.size = this.size), void 0 !== this.sizeAttenuation && (n.sizeAttenuation = this.sizeAttenuation), 1 !== this.blending && (n.blending = this.blending), 0 !== this.side && (n.side = this.side), this.vertexColors && (n.vertexColors = !0), this.opacity < 1 && (n.opacity = this.opacity), !0 === this.transparent && (n.transparent = this.transparent), n.depthFunc = this.depthFunc, n.depthTest = this.depthTest, n.depthWrite = this.depthWrite, n.stencilWrite = this.stencilWrite, n.stencilWriteMask = this.stencilWriteMask, n.stencilFunc = this.stencilFunc, n.stencilRef = this.stencilRef, n.stencilFuncMask = this.stencilFuncMask, n.stencilFail = this.stencilFail, n.stencilZFail = this.stencilZFail, n.stencilZPass = this.stencilZPass, this.rotation && 0 !== this.rotation && (n.rotation = this.rotation), !0 === this.polygonOffset && (n.polygonOffset = !0), 0 !== this.polygonOffsetFactor && (n.polygonOffsetFactor = this.polygonOffsetFactor), 0 !== this.polygonOffsetUnits && (n.polygonOffsetUnits = this.polygonOffsetUnits), this.linewidth && 1 !== this.linewidth && (n.linewidth = this.linewidth), void 0 !== this.dashSize && (n.dashSize = this.dashSize), void 0 !== this.gapSize && (n.gapSize = this.gapSize), void 0 !== this.scale && (n.scale = this.scale), !0 === this.dithering && (n.dithering = !0), this.alphaTest > 0 && (n.alphaTest = this.alphaTest), !0 === this.premultipliedAlpha && (n.premultipliedAlpha = this.premultipliedAlpha), !0 === this.wireframe && (n.wireframe = this.wireframe), this.wireframeLinewidth > 1 && (n.wireframeLinewidth = this.wireframeLinewidth), "round" !== this.wireframeLinecap && (n.wireframeLinecap = this.wireframeLinecap), "round" !== this.wireframeLinejoin && (n.wireframeLinejoin = this.wireframeLinejoin), !0 === this.morphTargets && (n.morphTargets = !0), !0 === this.morphNormals && (n.morphNormals = !0), !0 === this.skinning && (n.skinning = !0), !0 === this.flatShading && (n.flatShading = this.flatShading), !1 === this.visible && (n.visible = !1), !1 === this.toneMapped && (n.toneMapped = !1), "{}" !== JSON.stringify(this.userData) && (n.userData = this.userData), e) {
                        const e = i(t.textures),
                            r = i(t.images);
                        e.length > 0 && (n.textures = e), r.length > 0 && (n.images = r)
                    }
                    return n
                },
                clone: function() {
                    return (new this.constructor).copy(this)
                },
                copy: function(t) {
                    this.name = t.name, this.fog = t.fog, this.blending = t.blending, this.side = t.side, this.vertexColors = t.vertexColors, this.opacity = t.opacity, this.transparent = t.transparent, this.blendSrc = t.blendSrc, this.blendDst = t.blendDst, this.blendEquation = t.blendEquation, this.blendSrcAlpha = t.blendSrcAlpha, this.blendDstAlpha = t.blendDstAlpha, this.blendEquationAlpha = t.blendEquationAlpha, this.depthFunc = t.depthFunc, this.depthTest = t.depthTest, this.depthWrite = t.depthWrite, this.stencilWriteMask = t.stencilWriteMask, this.stencilFunc = t.stencilFunc, this.stencilRef = t.stencilRef, this.stencilFuncMask = t.stencilFuncMask, this.stencilFail = t.stencilFail, this.stencilZFail = t.stencilZFail, this.stencilZPass = t.stencilZPass, this.stencilWrite = t.stencilWrite;
                    const e = t.clippingPlanes;
                    let n = null;
                    if (null !== e) {
                        const t = e.length;
                        n = new Array(t);
                        for (let i = 0; i !== t; ++i) n[i] = e[i].clone()
                    }
                    return this.clippingPlanes = n, this.clipIntersection = t.clipIntersection, this.clipShadows = t.clipShadows, this.shadowSide = t.shadowSide, this.colorWrite = t.colorWrite, this.precision = t.precision, this.polygonOffset = t.polygonOffset, this.polygonOffsetFactor = t.polygonOffsetFactor, this.polygonOffsetUnits = t.polygonOffsetUnits, this.dithering = t.dithering, this.alphaTest = t.alphaTest, this.premultipliedAlpha = t.premultipliedAlpha, this.visible = t.visible, this.toneMapped = t.toneMapped, this.userData = JSON.parse(JSON.stringify(t.userData)), this
                },
                dispose: function() {
                    this.dispatchEvent({
                        type: "dispose"
                    })
                }
            }), Object.defineProperty(Va.prototype, "needsUpdate", {
                set: function(t) {
                    !0 === t && this.version++
                }
            });
            const ja = {
                    aliceblue: 15792383,
                    antiquewhite: 16444375,
                    aqua: 65535,
                    aquamarine: 8388564,
                    azure: 15794175,
                    beige: 16119260,
                    bisque: 16770244,
                    black: 0,
                    blanchedalmond: 16772045,
                    blue: 255,
                    blueviolet: 9055202,
                    brown: 10824234,
                    burlywood: 14596231,
                    cadetblue: 6266528,
                    chartreuse: 8388352,
                    chocolate: 13789470,
                    coral: 16744272,
                    cornflowerblue: 6591981,
                    cornsilk: 16775388,
                    crimson: 14423100,
                    cyan: 65535,
                    darkblue: 139,
                    darkcyan: 35723,
                    darkgoldenrod: 12092939,
                    darkgray: 11119017,
                    darkgreen: 25600,
                    darkgrey: 11119017,
                    darkkhaki: 12433259,
                    darkmagenta: 9109643,
                    darkolivegreen: 5597999,
                    darkorange: 16747520,
                    darkorchid: 10040012,
                    darkred: 9109504,
                    darksalmon: 15308410,
                    darkseagreen: 9419919,
                    darkslateblue: 4734347,
                    darkslategray: 3100495,
                    darkslategrey: 3100495,
                    darkturquoise: 52945,
                    darkviolet: 9699539,
                    deeppink: 16716947,
                    deepskyblue: 49151,
                    dimgray: 6908265,
                    dimgrey: 6908265,
                    dodgerblue: 2003199,
                    firebrick: 11674146,
                    floralwhite: 16775920,
                    forestgreen: 2263842,
                    fuchsia: 16711935,
                    gainsboro: 14474460,
                    ghostwhite: 16316671,
                    gold: 16766720,
                    goldenrod: 14329120,
                    gray: 8421504,
                    green: 32768,
                    greenyellow: 11403055,
                    grey: 8421504,
                    honeydew: 15794160,
                    hotpink: 16738740,
                    indianred: 13458524,
                    indigo: 4915330,
                    ivory: 16777200,
                    khaki: 15787660,
                    lavender: 15132410,
                    lavenderblush: 16773365,
                    lawngreen: 8190976,
                    lemonchiffon: 16775885,
                    lightblue: 11393254,
                    lightcoral: 15761536,
                    lightcyan: 14745599,
                    lightgoldenrodyellow: 16448210,
                    lightgray: 13882323,
                    lightgreen: 9498256,
                    lightgrey: 13882323,
                    lightpink: 16758465,
                    lightsalmon: 16752762,
                    lightseagreen: 2142890,
                    lightskyblue: 8900346,
                    lightslategray: 7833753,
                    lightslategrey: 7833753,
                    lightsteelblue: 11584734,
                    lightyellow: 16777184,
                    lime: 65280,
                    limegreen: 3329330,
                    linen: 16445670,
                    magenta: 16711935,
                    maroon: 8388608,
                    mediumaquamarine: 6737322,
                    mediumblue: 205,
                    mediumorchid: 12211667,
                    mediumpurple: 9662683,
                    mediumseagreen: 3978097,
                    mediumslateblue: 8087790,
                    mediumspringgreen: 64154,
                    mediumturquoise: 4772300,
                    mediumvioletred: 13047173,
                    midnightblue: 1644912,
                    mintcream: 16121850,
                    mistyrose: 16770273,
                    moccasin: 16770229,
                    navajowhite: 16768685,
                    navy: 128,
                    oldlace: 16643558,
                    olive: 8421376,
                    olivedrab: 7048739,
                    orange: 16753920,
                    orangered: 16729344,
                    orchid: 14315734,
                    palegoldenrod: 15657130,
                    palegreen: 10025880,
                    paleturquoise: 11529966,
                    palevioletred: 14381203,
                    papayawhip: 16773077,
                    peachpuff: 16767673,
                    peru: 13468991,
                    pink: 16761035,
                    plum: 14524637,
                    powderblue: 11591910,
                    purple: 8388736,
                    rebeccapurple: 6697881,
                    red: 16711680,
                    rosybrown: 12357519,
                    royalblue: 4286945,
                    saddlebrown: 9127187,
                    salmon: 16416882,
                    sandybrown: 16032864,
                    seagreen: 3050327,
                    seashell: 16774638,
                    sienna: 10506797,
                    silver: 12632256,
                    skyblue: 8900331,
                    slateblue: 6970061,
                    slategray: 7372944,
                    slategrey: 7372944,
                    snow: 16775930,
                    springgreen: 65407,
                    steelblue: 4620980,
                    tan: 13808780,
                    teal: 32896,
                    thistle: 14204888,
                    tomato: 16737095,
                    turquoise: 4251856,
                    violet: 15631086,
                    wheat: 16113331,
                    white: 16777215,
                    whitesmoke: 16119285,
                    yellow: 16776960,
                    yellowgreen: 10145074
                },
                qa = {
                    h: 0,
                    s: 0,
                    l: 0
                },
                Xa = {
                    h: 0,
                    s: 0,
                    l: 0
                };

            function Ya(t, e, n) {
                return n < 0 && (n += 1), n > 1 && (n -= 1), n < 1 / 6 ? t + 6 * (e - t) * n : n < .5 ? e : n < 2 / 3 ? t + 6 * (e - t) * (2 / 3 - n) : t
            }

            function Za(t) {
                return t < .04045 ? .0773993808 * t : Math.pow(.9478672986 * t + .0521327014, 2.4)
            }

            function Ja(t) {
                return t < .0031308 ? 12.92 * t : 1.055 * Math.pow(t, .41666) - .055
            }
            class Qa {
                constructor(t, e, n) {
                    return void 0 === e && void 0 === n ? this.set(t) : this.setRGB(t, e, n)
                }
                set(t) {
                    return t && t.isColor ? this.copy(t) : "number" == typeof t ? this.setHex(t) : "string" == typeof t && this.setStyle(t), this
                }
                setScalar(t) {
                    return this.r = t, this.g = t, this.b = t, this
                }
                setHex(t) {
                    return t = Math.floor(t), this.r = (t >> 16 & 255) / 255, this.g = (t >> 8 & 255) / 255, this.b = (255 & t) / 255, this
                }
                setRGB(t, e, n) {
                    return this.r = t, this.g = e, this.b = n, this
                }
                setHSL(t, e, n) {
                    if (t = vo.euclideanModulo(t, 1), e = vo.clamp(e, 0, 1), n = vo.clamp(n, 0, 1), 0 === e) this.r = this.g = this.b = n;
                    else {
                        const i = n <= .5 ? n * (1 + e) : n + e - n * e,
                            r = 2 * n - i;
                        this.r = Ya(r, i, t + 1 / 3), this.g = Ya(r, i, t), this.b = Ya(r, i, t - 1 / 3)
                    }
                    return this
                }
                setStyle(t) {
                    function e(e) {
                        void 0 !== e && parseFloat(e) < 1 && console.warn("THREE.Color: Alpha component of " + t + " will be ignored.")
                    }
                    let n;
                    if (n = /^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(t)) {
                        let t;
                        const i = n[1],
                            r = n[2];
                        switch (i) {
                            case "rgb":
                            case "rgba":
                                if (t = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(r)) return this.r = Math.min(255, parseInt(t[1], 10)) / 255, this.g = Math.min(255, parseInt(t[2], 10)) / 255, this.b = Math.min(255, parseInt(t[3], 10)) / 255, e(t[4]), this;
                                if (t = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(r)) return this.r = Math.min(100, parseInt(t[1], 10)) / 100, this.g = Math.min(100, parseInt(t[2], 10)) / 100, this.b = Math.min(100, parseInt(t[3], 10)) / 100, e(t[4]), this;
                                break;
                            case "hsl":
                            case "hsla":
                                if (t = /^\s*(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(r)) {
                                    const n = parseFloat(t[1]) / 360,
                                        i = parseInt(t[2], 10) / 100,
                                        r = parseInt(t[3], 10) / 100;
                                    return e(t[4]), this.setHSL(n, i, r)
                                }
                        }
                    } else if (n = /^\#([A-Fa-f\d]+)$/.exec(t)) {
                        const t = n[1],
                            e = t.length;
                        if (3 === e) return this.r = parseInt(t.charAt(0) + t.charAt(0), 16) / 255, this.g = parseInt(t.charAt(1) + t.charAt(1), 16) / 255, this.b = parseInt(t.charAt(2) + t.charAt(2), 16) / 255, this;
                        if (6 === e) return this.r = parseInt(t.charAt(0) + t.charAt(1), 16) / 255, this.g = parseInt(t.charAt(2) + t.charAt(3), 16) / 255, this.b = parseInt(t.charAt(4) + t.charAt(5), 16) / 255, this
                    }
                    return t && t.length > 0 ? this.setColorName(t) : this
                }
                setColorName(t) {
                    const e = ja[t];
                    return void 0 !== e ? this.setHex(e) : console.warn("THREE.Color: Unknown color " + t), this
                }
                clone() {
                    return new this.constructor(this.r, this.g, this.b)
                }
                copy(t) {
                    return this.r = t.r, this.g = t.g, this.b = t.b, this
                }
                copyGammaToLinear(t, e = 2) {
                    return this.r = Math.pow(t.r, e), this.g = Math.pow(t.g, e), this.b = Math.pow(t.b, e), this
                }
                copyLinearToGamma(t, e = 2) {
                    const n = e > 0 ? 1 / e : 1;
                    return this.r = Math.pow(t.r, n), this.g = Math.pow(t.g, n), this.b = Math.pow(t.b, n), this
                }
                convertGammaToLinear(t) {
                    return this.copyGammaToLinear(this, t), this
                }
                convertLinearToGamma(t) {
                    return this.copyLinearToGamma(this, t), this
                }
                copySRGBToLinear(t) {
                    return this.r = Za(t.r), this.g = Za(t.g), this.b = Za(t.b), this
                }
                copyLinearToSRGB(t) {
                    return this.r = Ja(t.r), this.g = Ja(t.g), this.b = Ja(t.b), this
                }
                convertSRGBToLinear() {
                    return this.copySRGBToLinear(this), this
                }
                convertLinearToSRGB() {
                    return this.copyLinearToSRGB(this), this
                }
                getHex() {
                    return 255 * this.r << 16 ^ 255 * this.g << 8 ^ 255 * this.b << 0
                }
                getHexString() {
                    return ("000000" + this.getHex().toString(16)).slice(-6)
                }
                getHSL(t) {
                    void 0 === t && (console.warn("THREE.Color: .getHSL() target is now required"), t = {
                        h: 0,
                        s: 0,
                        l: 0
                    });
                    const e = this.r,
                        n = this.g,
                        i = this.b,
                        r = Math.max(e, n, i),
                        s = Math.min(e, n, i);
                    let o, a;
                    const l = (s + r) / 2;
                    if (s === r) o = 0, a = 0;
                    else {
                        const t = r - s;
                        switch (a = l <= .5 ? t / (r + s) : t / (2 - r - s), r) {
                            case e:
                                o = (n - i) / t + (n < i ? 6 : 0);
                                break;
                            case n:
                                o = (i - e) / t + 2;
                                break;
                            case i:
                                o = (e - n) / t + 4
                        }
                        o /= 6
                    }
                    return t.h = o, t.s = a, t.l = l, t
                }
                getStyle() {
                    return "rgb(" + (255 * this.r | 0) + "," + (255 * this.g | 0) + "," + (255 * this.b | 0) + ")"
                }
                offsetHSL(t, e, n) {
                    return this.getHSL(qa), qa.h += t, qa.s += e, qa.l += n, this.setHSL(qa.h, qa.s, qa.l), this
                }
                add(t) {
                    return this.r += t.r, this.g += t.g, this.b += t.b, this
                }
                addColors(t, e) {
                    return this.r = t.r + e.r, this.g = t.g + e.g, this.b = t.b + e.b, this
                }
                addScalar(t) {
                    return this.r += t, this.g += t, this.b += t, this
                }
                sub(t) {
                    return this.r = Math.max(0, this.r - t.r), this.g = Math.max(0, this.g - t.g), this.b = Math.max(0, this.b - t.b), this
                }
                multiply(t) {
                    return this.r *= t.r, this.g *= t.g, this.b *= t.b, this
                }
                multiplyScalar(t) {
                    return this.r *= t, this.g *= t, this.b *= t, this
                }
                lerp(t, e) {
                    return this.r += (t.r - this.r) * e, this.g += (t.g - this.g) * e, this.b += (t.b - this.b) * e, this
                }
                lerpColors(t, e, n) {
                    return this.r = t.r + (e.r - t.r) * n, this.g = t.g + (e.g - t.g) * n, this.b = t.b + (e.b - t.b) * n, this
                }
                lerpHSL(t, e) {
                    this.getHSL(qa), t.getHSL(Xa);
                    const n = vo.lerp(qa.h, Xa.h, e),
                        i = vo.lerp(qa.s, Xa.s, e),
                        r = vo.lerp(qa.l, Xa.l, e);
                    return this.setHSL(n, i, r), this
                }
                equals(t) {
                    return t.r === this.r && t.g === this.g && t.b === this.b
                }
                fromArray(t, e = 0) {
                    return this.r = t[e], this.g = t[e + 1], this.b = t[e + 2], this
                }
                toArray(t = [], e = 0) {
                    return t[e] = this.r, t[e + 1] = this.g, t[e + 2] = this.b, t
                }
                fromBufferAttribute(t, e) {
                    return this.r = t.getX(e), this.g = t.getY(e), this.b = t.getZ(e), !0 === t.normalized && (this.r /= 255, this.g /= 255, this.b /= 255), this
                }
                toJSON() {
                    return this.getHex()
                }
            }
            Qa.NAMES = ja, Qa.prototype.isColor = !0, Qa.prototype.r = 1, Qa.prototype.g = 1, Qa.prototype.b = 1;
            class Ka extends Va {
                constructor(t) {
                    super(), this.type = "MeshBasicMaterial", this.color = new Qa(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = 0, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.setValues(t)
                }
                copy(t) {
                    return super.copy(t), this.color.copy(t.color), this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this
                }
            }
            Ka.prototype.isMeshBasicMaterial = !0;
            const $a = new Ao,
                tl = new yo;

            function el(t, e, n) {
                if (Array.isArray(t)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
                this.name = "", this.array = t, this.itemSize = e, this.count = void 0 !== t ? t.length / e : 0, this.normalized = !0 === n, this.usage = uo, this.updateRange = {
                    offset: 0,
                    count: -1
                }, this.version = 0
            }

            function nl(t, e, n) {
                el.call(this, new Int8Array(t), e, n)
            }

            function il(t, e, n) {
                el.call(this, new Uint8Array(t), e, n)
            }

            function rl(t, e, n) {
                el.call(this, new Uint8ClampedArray(t), e, n)
            }

            function sl(t, e, n) {
                el.call(this, new Int16Array(t), e, n)
            }

            function ol(t, e, n) {
                el.call(this, new Uint16Array(t), e, n)
            }

            function al(t, e, n) {
                el.call(this, new Int32Array(t), e, n)
            }

            function ll(t, e, n) {
                el.call(this, new Uint32Array(t), e, n)
            }

            function cl(t, e, n) {
                el.call(this, new Uint16Array(t), e, n)
            }

            function ul(t, e, n) {
                el.call(this, new Float32Array(t), e, n)
            }

            function hl(t, e, n) {
                el.call(this, new Float64Array(t), e, n)
            }

            function dl(t) {
                if (0 === t.length) return -1 / 0;
                let e = t[0];
                for (let n = 1, i = t.length; n < i; ++n) t[n] > e && (e = t[n]);
                return e
            }
            Object.defineProperty(el.prototype, "needsUpdate", {
                set: function(t) {
                    !0 === t && this.version++
                }
            }), Object.assign(el.prototype, {
                isBufferAttribute: !0,
                onUploadCallback: function() {},
                setUsage: function(t) {
                    return this.usage = t, this
                },
                copy: function(t) {
                    return this.name = t.name, this.array = new t.array.constructor(t.array), this.itemSize = t.itemSize, this.count = t.count, this.normalized = t.normalized, this.usage = t.usage, this
                },
                copyAt: function(t, e, n) {
                    t *= this.itemSize, n *= e.itemSize;
                    for (let i = 0, r = this.itemSize; i < r; i++) this.array[t + i] = e.array[n + i];
                    return this
                },
                copyArray: function(t) {
                    return this.array.set(t), this
                },
                copyColorsArray: function(t) {
                    const e = this.array;
                    let n = 0;
                    for (let i = 0, r = t.length; i < r; i++) {
                        let r = t[i];
                        void 0 === r && (console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined", i), r = new Qa), e[n++] = r.r, e[n++] = r.g, e[n++] = r.b
                    }
                    return this
                },
                copyVector2sArray: function(t) {
                    const e = this.array;
                    let n = 0;
                    for (let i = 0, r = t.length; i < r; i++) {
                        let r = t[i];
                        void 0 === r && (console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined", i), r = new yo), e[n++] = r.x, e[n++] = r.y
                    }
                    return this
                },
                copyVector3sArray: function(t) {
                    const e = this.array;
                    let n = 0;
                    for (let i = 0, r = t.length; i < r; i++) {
                        let r = t[i];
                        void 0 === r && (console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined", i), r = new Ao), e[n++] = r.x, e[n++] = r.y, e[n++] = r.z
                    }
                    return this
                },
                copyVector4sArray: function(t) {
                    const e = this.array;
                    let n = 0;
                    for (let i = 0, r = t.length; i < r; i++) {
                        let r = t[i];
                        void 0 === r && (console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined", i), r = new Eo), e[n++] = r.x, e[n++] = r.y, e[n++] = r.z, e[n++] = r.w
                    }
                    return this
                },
                applyMatrix3: function(t) {
                    if (2 === this.itemSize)
                        for (let e = 0, n = this.count; e < n; e++) tl.fromBufferAttribute(this, e), tl.applyMatrix3(t), this.setXY(e, tl.x, tl.y);
                    else if (3 === this.itemSize)
                        for (let e = 0, n = this.count; e < n; e++) $a.fromBufferAttribute(this, e), $a.applyMatrix3(t), this.setXYZ(e, $a.x, $a.y, $a.z);
                    return this
                },
                applyMatrix4: function(t) {
                    for (let e = 0, n = this.count; e < n; e++) $a.x = this.getX(e), $a.y = this.getY(e), $a.z = this.getZ(e), $a.applyMatrix4(t), this.setXYZ(e, $a.x, $a.y, $a.z);
                    return this
                },
                applyNormalMatrix: function(t) {
                    for (let e = 0, n = this.count; e < n; e++) $a.x = this.getX(e), $a.y = this.getY(e), $a.z = this.getZ(e), $a.applyNormalMatrix(t), this.setXYZ(e, $a.x, $a.y, $a.z);
                    return this
                },
                transformDirection: function(t) {
                    for (let e = 0, n = this.count; e < n; e++) $a.x = this.getX(e), $a.y = this.getY(e), $a.z = this.getZ(e), $a.transformDirection(t), this.setXYZ(e, $a.x, $a.y, $a.z);
                    return this
                },
                set: function(t, e = 0) {
                    return this.array.set(t, e), this
                },
                getX: function(t) {
                    return this.array[t * this.itemSize]
                },
                setX: function(t, e) {
                    return this.array[t * this.itemSize] = e, this
                },
                getY: function(t) {
                    return this.array[t * this.itemSize + 1]
                },
                setY: function(t, e) {
                    return this.array[t * this.itemSize + 1] = e, this
                },
                getZ: function(t) {
                    return this.array[t * this.itemSize + 2]
                },
                setZ: function(t, e) {
                    return this.array[t * this.itemSize + 2] = e, this
                },
                getW: function(t) {
                    return this.array[t * this.itemSize + 3]
                },
                setW: function(t, e) {
                    return this.array[t * this.itemSize + 3] = e, this
                },
                setXY: function(t, e, n) {
                    return t *= this.itemSize, this.array[t + 0] = e, this.array[t + 1] = n, this
                },
                setXYZ: function(t, e, n, i) {
                    return t *= this.itemSize, this.array[t + 0] = e, this.array[t + 1] = n, this.array[t + 2] = i, this
                },
                setXYZW: function(t, e, n, i, r) {
                    return t *= this.itemSize, this.array[t + 0] = e, this.array[t + 1] = n, this.array[t + 2] = i, this.array[t + 3] = r, this
                },
                onUpload: function(t) {
                    return this.onUploadCallback = t, this
                },
                clone: function() {
                    return new this.constructor(this.array, this.itemSize).copy(this)
                },
                toJSON: function() {
                    return {
                        itemSize: this.itemSize,
                        type: this.array.constructor.name,
                        array: Array.prototype.slice.call(this.array),
                        normalized: this.normalized
                    }
                }
            }), nl.prototype = Object.create(el.prototype), nl.prototype.constructor = nl, il.prototype = Object.create(el.prototype), il.prototype.constructor = il, rl.prototype = Object.create(el.prototype), rl.prototype.constructor = rl, sl.prototype = Object.create(el.prototype), sl.prototype.constructor = sl, ol.prototype = Object.create(el.prototype), ol.prototype.constructor = ol, al.prototype = Object.create(el.prototype), al.prototype.constructor = al, ll.prototype = Object.create(el.prototype), ll.prototype.constructor = ll, cl.prototype = Object.create(el.prototype), cl.prototype.constructor = cl, cl.prototype.isFloat16BufferAttribute = !0, ul.prototype = Object.create(el.prototype), ul.prototype.constructor = ul, hl.prototype = Object.create(el.prototype), hl.prototype.constructor = hl;
            Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array;
            let pl = 0;
            const fl = new na,
                ml = new Ta,
                gl = new Ao,
                vl = new Ro,
                yl = new Ro,
                xl = new Ao;

            function _l() {
                Object.defineProperty(this, "id", {
                    value: pl++
                }), this.uuid = vo.generateUUID(), this.name = "", this.type = "BufferGeometry", this.index = null, this.attributes = {}, this.morphAttributes = {}, this.morphTargetsRelative = !1, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = {
                    start: 0,
                    count: 1 / 0
                }, this.userData = {}
            }
            _l.prototype = Object.assign(Object.create(fo.prototype), {
                constructor: _l,
                isBufferGeometry: !0,
                getIndex: function() {
                    return this.index
                },
                setIndex: function(t) {
                    return Array.isArray(t) ? this.index = new(dl(t) > 65535 ? ll : ol)(t, 1) : this.index = t, this
                },
                getAttribute: function(t) {
                    return this.attributes[t]
                },
                setAttribute: function(t, e) {
                    return this.attributes[t] = e, this
                },
                deleteAttribute: function(t) {
                    return delete this.attributes[t], this
                },
                hasAttribute: function(t) {
                    return void 0 !== this.attributes[t]
                },
                addGroup: function(t, e, n = 0) {
                    this.groups.push({
                        start: t,
                        count: e,
                        materialIndex: n
                    })
                },
                clearGroups: function() {
                    this.groups = []
                },
                setDrawRange: function(t, e) {
                    this.drawRange.start = t, this.drawRange.count = e
                },
                applyMatrix4: function(t) {
                    const e = this.attributes.position;
                    void 0 !== e && (e.applyMatrix4(t), e.needsUpdate = !0);
                    const n = this.attributes.normal;
                    if (void 0 !== n) {
                        const e = (new xo).getNormalMatrix(t);
                        n.applyNormalMatrix(e), n.needsUpdate = !0
                    }
                    const i = this.attributes.tangent;
                    return void 0 !== i && (i.transformDirection(t), i.needsUpdate = !0), null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), this
                },
                rotateX: function(t) {
                    return fl.makeRotationX(t), this.applyMatrix4(fl), this
                },
                rotateY: function(t) {
                    return fl.makeRotationY(t), this.applyMatrix4(fl), this
                },
                rotateZ: function(t) {
                    return fl.makeRotationZ(t), this.applyMatrix4(fl), this
                },
                translate: function(t, e, n) {
                    return fl.makeTranslation(t, e, n), this.applyMatrix4(fl), this
                },
                scale: function(t, e, n) {
                    return fl.makeScale(t, e, n), this.applyMatrix4(fl), this
                },
                lookAt: function(t) {
                    return ml.lookAt(t), ml.updateMatrix(), this.applyMatrix4(ml.matrix), this
                },
                center: function() {
                    return this.computeBoundingBox(), this.boundingBox.getCenter(gl).negate(), this.translate(gl.x, gl.y, gl.z), this
                },
                setFromPoints: function(t) {
                    const e = [];
                    for (let n = 0, i = t.length; n < i; n++) {
                        const i = t[n];
                        e.push(i.x, i.y, i.z || 0)
                    }
                    return this.setAttribute("position", new ul(e, 3)), this
                },
                computeBoundingBox: function() {
                    null === this.boundingBox && (this.boundingBox = new Ro);
                    const t = this.attributes.position,
                        e = this.morphAttributes.position;
                    if (t && t.isGLBufferAttribute) return console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".', this), void this.boundingBox.set(new Ao(-1 / 0, -1 / 0, -1 / 0), new Ao(1 / 0, 1 / 0, 1 / 0));
                    if (void 0 !== t) {
                        if (this.boundingBox.setFromBufferAttribute(t), e)
                            for (let t = 0, n = e.length; t < n; t++) {
                                const n = e[t];
                                vl.setFromBufferAttribute(n), this.morphTargetsRelative ? (xl.addVectors(this.boundingBox.min, vl.min), this.boundingBox.expandByPoint(xl), xl.addVectors(this.boundingBox.max, vl.max), this.boundingBox.expandByPoint(xl)) : (this.boundingBox.expandByPoint(vl.min), this.boundingBox.expandByPoint(vl.max))
                            }
                    } else this.boundingBox.makeEmpty();
                    (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this)
                },
                computeBoundingSphere: function() {
                    null === this.boundingSphere && (this.boundingSphere = new Xo);
                    const t = this.attributes.position,
                        e = this.morphAttributes.position;
                    if (t && t.isGLBufferAttribute) return console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".', this), void this.boundingSphere.set(new Ao, 1 / 0);
                    if (t) {
                        const n = this.boundingSphere.center;
                        if (vl.setFromBufferAttribute(t), e)
                            for (let t = 0, n = e.length; t < n; t++) {
                                const n = e[t];
                                yl.setFromBufferAttribute(n), this.morphTargetsRelative ? (xl.addVectors(vl.min, yl.min), vl.expandByPoint(xl), xl.addVectors(vl.max, yl.max), vl.expandByPoint(xl)) : (vl.expandByPoint(yl.min), vl.expandByPoint(yl.max))
                            }
                        vl.getCenter(n);
                        let i = 0;
                        for (let e = 0, r = t.count; e < r; e++) xl.fromBufferAttribute(t, e), i = Math.max(i, n.distanceToSquared(xl));
                        if (e)
                            for (let r = 0, s = e.length; r < s; r++) {
                                const s = e[r],
                                    o = this.morphTargetsRelative;
                                for (let e = 0, r = s.count; e < r; e++) xl.fromBufferAttribute(s, e), o && (gl.fromBufferAttribute(t, e), xl.add(gl)), i = Math.max(i, n.distanceToSquared(xl))
                            }
                        this.boundingSphere.radius = Math.sqrt(i), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this)
                    }
                },
                computeFaceNormals: function() {},
                computeTangents: function() {
                    const t = this.index,
                        e = this.attributes;
                    if (null === t || void 0 === e.position || void 0 === e.normal || void 0 === e.uv) return void console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
                    const n = t.array,
                        i = e.position.array,
                        r = e.normal.array,
                        s = e.uv.array,
                        o = i.length / 3;
                    void 0 === e.tangent && this.setAttribute("tangent", new el(new Float32Array(4 * o), 4));
                    const a = e.tangent.array,
                        l = [],
                        c = [];
                    for (let t = 0; t < o; t++) l[t] = new Ao, c[t] = new Ao;
                    const u = new Ao,
                        h = new Ao,
                        d = new Ao,
                        p = new yo,
                        f = new yo,
                        m = new yo,
                        g = new Ao,
                        v = new Ao;

                    function y(t, e, n) {
                        u.fromArray(i, 3 * t), h.fromArray(i, 3 * e), d.fromArray(i, 3 * n), p.fromArray(s, 2 * t), f.fromArray(s, 2 * e), m.fromArray(s, 2 * n), h.sub(u), d.sub(u), f.sub(p), m.sub(p);
                        const r = 1 / (f.x * m.y - m.x * f.y);
                        isFinite(r) && (g.copy(h).multiplyScalar(m.y).addScaledVector(d, -f.y).multiplyScalar(r), v.copy(d).multiplyScalar(f.x).addScaledVector(h, -m.x).multiplyScalar(r), l[t].add(g), l[e].add(g), l[n].add(g), c[t].add(v), c[e].add(v), c[n].add(v))
                    }
                    let x = this.groups;
                    0 === x.length && (x = [{
                        start: 0,
                        count: n.length
                    }]);
                    for (let t = 0, e = x.length; t < e; ++t) {
                        const e = x[t],
                            i = e.start;
                        for (let t = i, r = i + e.count; t < r; t += 3) y(n[t + 0], n[t + 1], n[t + 2])
                    }
                    const _ = new Ao,
                        b = new Ao,
                        w = new Ao,
                        M = new Ao;

                    function S(t) {
                        w.fromArray(r, 3 * t), M.copy(w);
                        const e = l[t];
                        _.copy(e), _.sub(w.multiplyScalar(w.dot(e))).normalize(), b.crossVectors(M, e);
                        const n = b.dot(c[t]) < 0 ? -1 : 1;
                        a[4 * t] = _.x, a[4 * t + 1] = _.y, a[4 * t + 2] = _.z, a[4 * t + 3] = n
                    }
                    for (let t = 0, e = x.length; t < e; ++t) {
                        const e = x[t],
                            i = e.start;
                        for (let t = i, r = i + e.count; t < r; t += 3) S(n[t + 0]), S(n[t + 1]), S(n[t + 2])
                    }
                },
                computeVertexNormals: function() {
                    const t = this.index,
                        e = this.getAttribute("position");
                    if (void 0 !== e) {
                        let n = this.getAttribute("normal");
                        if (void 0 === n) n = new el(new Float32Array(3 * e.count), 3), this.setAttribute("normal", n);
                        else
                            for (let t = 0, e = n.count; t < e; t++) n.setXYZ(t, 0, 0, 0);
                        const i = new Ao,
                            r = new Ao,
                            s = new Ao,
                            o = new Ao,
                            a = new Ao,
                            l = new Ao,
                            c = new Ao,
                            u = new Ao;
                        if (t)
                            for (let h = 0, d = t.count; h < d; h += 3) {
                                const d = t.getX(h + 0),
                                    p = t.getX(h + 1),
                                    f = t.getX(h + 2);
                                i.fromBufferAttribute(e, d), r.fromBufferAttribute(e, p), s.fromBufferAttribute(e, f), c.subVectors(s, r), u.subVectors(i, r), c.cross(u), o.fromBufferAttribute(n, d), a.fromBufferAttribute(n, p), l.fromBufferAttribute(n, f), o.add(c), a.add(c), l.add(c), n.setXYZ(d, o.x, o.y, o.z), n.setXYZ(p, a.x, a.y, a.z), n.setXYZ(f, l.x, l.y, l.z)
                            } else
                                for (let t = 0, o = e.count; t < o; t += 3) i.fromBufferAttribute(e, t + 0), r.fromBufferAttribute(e, t + 1), s.fromBufferAttribute(e, t + 2), c.subVectors(s, r), u.subVectors(i, r), c.cross(u), n.setXYZ(t + 0, c.x, c.y, c.z), n.setXYZ(t + 1, c.x, c.y, c.z), n.setXYZ(t + 2, c.x, c.y, c.z);
                        this.normalizeNormals(), n.needsUpdate = !0
                    }
                },
                merge: function(t, e) {
                    if (!t || !t.isBufferGeometry) return void console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.", t);
                    void 0 === e && (e = 0, console.warn("THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."));
                    const n = this.attributes;
                    for (const i in n) {
                        if (void 0 === t.attributes[i]) continue;
                        const r = n[i].array,
                            s = t.attributes[i],
                            o = s.array,
                            a = s.itemSize * e,
                            l = Math.min(o.length, r.length - a);
                        for (let t = 0, e = a; t < l; t++, e++) r[e] = o[t]
                    }
                    return this
                },
                normalizeNormals: function() {
                    const t = this.attributes.normal;
                    for (let e = 0, n = t.count; e < n; e++) xl.fromBufferAttribute(t, e), xl.normalize(), t.setXYZ(e, xl.x, xl.y, xl.z)
                },
                toNonIndexed: function() {
                    function t(t, e) {
                        const n = t.array,
                            i = t.itemSize,
                            r = t.normalized,
                            s = new n.constructor(e.length * i);
                        let o = 0,
                            a = 0;
                        for (let t = 0, r = e.length; t < r; t++) {
                            o = e[t] * i;
                            for (let t = 0; t < i; t++) s[a++] = n[o++]
                        }
                        return new el(s, i, r)
                    }
                    if (null === this.index) return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."), this;
                    const e = new _l,
                        n = this.index.array,
                        i = this.attributes;
                    for (const r in i) {
                        const s = t(i[r], n);
                        e.setAttribute(r, s)
                    }
                    const r = this.morphAttributes;
                    for (const i in r) {
                        const s = [],
                            o = r[i];
                        for (let e = 0, i = o.length; e < i; e++) {
                            const i = t(o[e], n);
                            s.push(i)
                        }
                        e.morphAttributes[i] = s
                    }
                    e.morphTargetsRelative = this.morphTargetsRelative;
                    const s = this.groups;
                    for (let t = 0, n = s.length; t < n; t++) {
                        const n = s[t];
                        e.addGroup(n.start, n.count, n.materialIndex)
                    }
                    return e
                },
                toJSON: function() {
                    const t = {
                        metadata: {
                            version: 4.5,
                            type: "BufferGeometry",
                            generator: "BufferGeometry.toJSON"
                        }
                    };
                    if (t.uuid = this.uuid, t.type = this.type, "" !== this.name && (t.name = this.name), Object.keys(this.userData).length > 0 && (t.userData = this.userData), void 0 !== this.parameters) {
                        const e = this.parameters;
                        for (const n in e) void 0 !== e[n] && (t[n] = e[n]);
                        return t
                    }
                    t.data = {
                        attributes: {}
                    };
                    const e = this.index;
                    null !== e && (t.data.index = {
                        type: e.array.constructor.name,
                        array: Array.prototype.slice.call(e.array)
                    });
                    const n = this.attributes;
                    for (const e in n) {
                        const i = n[e],
                            r = i.toJSON(t.data);
                        "" !== i.name && (r.name = i.name), t.data.attributes[e] = r
                    }
                    const i = {};
                    let r = !1;
                    for (const e in this.morphAttributes) {
                        const n = this.morphAttributes[e],
                            s = [];
                        for (let e = 0, i = n.length; e < i; e++) {
                            const i = n[e],
                                r = i.toJSON(t.data);
                            "" !== i.name && (r.name = i.name), s.push(r)
                        }
                        s.length > 0 && (i[e] = s, r = !0)
                    }
                    r && (t.data.morphAttributes = i, t.data.morphTargetsRelative = this.morphTargetsRelative);
                    const s = this.groups;
                    s.length > 0 && (t.data.groups = JSON.parse(JSON.stringify(s)));
                    const o = this.boundingSphere;
                    return null !== o && (t.data.boundingSphere = {
                        center: o.center.toArray(),
                        radius: o.radius
                    }), t
                },
                clone: function() {
                    return (new _l).copy(this)
                },
                copy: function(t) {
                    this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null;
                    const e = {};
                    this.name = t.name;
                    const n = t.index;
                    null !== n && this.setIndex(n.clone(e));
                    const i = t.attributes;
                    for (const t in i) {
                        const n = i[t];
                        this.setAttribute(t, n.clone(e))
                    }
                    const r = t.morphAttributes;
                    for (const t in r) {
                        const n = [],
                            i = r[t];
                        for (let t = 0, r = i.length; t < r; t++) n.push(i[t].clone(e));
                        this.morphAttributes[t] = n
                    }
                    this.morphTargetsRelative = t.morphTargetsRelative;
                    const s = t.groups;
                    for (let t = 0, e = s.length; t < e; t++) {
                        const e = s[t];
                        this.addGroup(e.start, e.count, e.materialIndex)
                    }
                    const o = t.boundingBox;
                    null !== o && (this.boundingBox = o.clone());
                    const a = t.boundingSphere;
                    return null !== a && (this.boundingSphere = a.clone()), this.drawRange.start = t.drawRange.start, this.drawRange.count = t.drawRange.count, this.userData = t.userData, this
                },
                dispose: function() {
                    this.dispatchEvent({
                        type: "dispose"
                    })
                }
            });
            const bl = new na,
                wl = new ea,
                Ml = new Xo,
                Sl = new Ao,
                El = new Ao,
                Dl = new Ao,
                Tl = new Ao,
                Al = new Ao,
                Cl = new Ao,
                Ll = new Ao,
                Rl = new Ao,
                Pl = new Ao,
                Fl = new yo,
                Ol = new yo,
                Il = new yo,
                Nl = new Ao,
                Bl = new Ao;

            function zl(t = new _l, e = new Ka) {
                Ta.call(this), this.type = "Mesh", this.geometry = t, this.material = e, this.updateMorphTargets()
            }

            function kl(t, e, n, i, r, s, o, a, l, c, u, h) {
                Sl.fromBufferAttribute(r, c), El.fromBufferAttribute(r, u), Dl.fromBufferAttribute(r, h);
                const d = t.morphTargetInfluences;
                if (e.morphTargets && s && d) {
                    Ll.set(0, 0, 0), Rl.set(0, 0, 0), Pl.set(0, 0, 0);
                    for (let t = 0, e = s.length; t < e; t++) {
                        const e = d[t],
                            n = s[t];
                        0 !== e && (Tl.fromBufferAttribute(n, c), Al.fromBufferAttribute(n, u), Cl.fromBufferAttribute(n, h), o ? (Ll.addScaledVector(Tl, e), Rl.addScaledVector(Al, e), Pl.addScaledVector(Cl, e)) : (Ll.addScaledVector(Tl.sub(Sl), e), Rl.addScaledVector(Al.sub(El), e), Pl.addScaledVector(Cl.sub(Dl), e)))
                    }
                    Sl.add(Ll), El.add(Rl), Dl.add(Pl)
                }
                t.isSkinnedMesh && e.skinning && (t.boneTransform(c, Sl), t.boneTransform(u, El), t.boneTransform(h, Dl));
                const p = function(t, e, n, i, r, s, o, a) {
                    let l;
                    if (l = 1 === e.side ? i.intersectTriangle(o, s, r, !0, a) : i.intersectTriangle(r, s, o, 2 !== e.side, a), null === l) return null;
                    Bl.copy(a), Bl.applyMatrix4(t.matrixWorld);
                    const c = n.ray.origin.distanceTo(Bl);
                    return c < n.near || c > n.far ? null : {
                        distance: c,
                        point: Bl.clone(),
                        object: t
                    }
                }(t, e, n, i, Sl, El, Dl, Nl);
                if (p) {
                    a && (Fl.fromBufferAttribute(a, c), Ol.fromBufferAttribute(a, u), Il.fromBufferAttribute(a, h), p.uv = Ga.getUV(Nl, Sl, El, Dl, Fl, Ol, Il, new yo)), l && (Fl.fromBufferAttribute(l, c), Ol.fromBufferAttribute(l, u), Il.fromBufferAttribute(l, h), p.uv2 = Ga.getUV(Nl, Sl, El, Dl, Fl, Ol, Il, new yo));
                    const t = {
                        a: c,
                        b: u,
                        c: h,
                        normal: new Ao,
                        materialIndex: 0
                    };
                    Ga.getNormal(Sl, El, Dl, t.normal), p.face = t
                }
                return p
            }
            zl.prototype = Object.assign(Object.create(Ta.prototype), {
                constructor: zl,
                isMesh: !0,
                copy: function(t) {
                    return Ta.prototype.copy.call(this, t), void 0 !== t.morphTargetInfluences && (this.morphTargetInfluences = t.morphTargetInfluences.slice()), void 0 !== t.morphTargetDictionary && (this.morphTargetDictionary = Object.assign({}, t.morphTargetDictionary)), this.material = t.material, this.geometry = t.geometry, this
                },
                updateMorphTargets: function() {
                    const t = this.geometry;
                    if (t.isBufferGeometry) {
                        const e = t.morphAttributes,
                            n = Object.keys(e);
                        if (n.length > 0) {
                            const t = e[n[0]];
                            if (void 0 !== t) {
                                this.morphTargetInfluences = [], this.morphTargetDictionary = {};
                                for (let e = 0, n = t.length; e < n; e++) {
                                    const n = t[e].name || String(e);
                                    this.morphTargetInfluences.push(0), this.morphTargetDictionary[n] = e
                                }
                            }
                        }
                    } else {
                        const e = t.morphTargets;
                        void 0 !== e && e.length > 0 && console.error("THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")
                    }
                },
                raycast: function(t, e) {
                    const n = this.geometry,
                        i = this.material,
                        r = this.matrixWorld;
                    if (void 0 === i) return;
                    if (null === n.boundingSphere && n.computeBoundingSphere(), Ml.copy(n.boundingSphere), Ml.applyMatrix4(r), !1 === t.ray.intersectsSphere(Ml)) return;
                    if (bl.copy(r).invert(), wl.copy(t.ray).applyMatrix4(bl), null !== n.boundingBox && !1 === wl.intersectsBox(n.boundingBox)) return;
                    let s;
                    if (n.isBufferGeometry) {
                        const r = n.index,
                            o = n.attributes.position,
                            a = n.morphAttributes.position,
                            l = n.morphTargetsRelative,
                            c = n.attributes.uv,
                            u = n.attributes.uv2,
                            h = n.groups,
                            d = n.drawRange;
                        if (null !== r)
                            if (Array.isArray(i))
                                for (let n = 0, p = h.length; n < p; n++) {
                                    const p = h[n],
                                        f = i[p.materialIndex];
                                    for (let n = Math.max(p.start, d.start), i = Math.min(p.start + p.count, d.start + d.count); n < i; n += 3) {
                                        const i = r.getX(n),
                                            h = r.getX(n + 1),
                                            d = r.getX(n + 2);
                                        s = kl(this, f, t, wl, o, a, l, c, u, i, h, d), s && (s.faceIndex = Math.floor(n / 3), s.face.materialIndex = p.materialIndex, e.push(s))
                                    }
                                } else {
                                    for (let n = Math.max(0, d.start), h = Math.min(r.count, d.start + d.count); n < h; n += 3) {
                                        const h = r.getX(n),
                                            d = r.getX(n + 1),
                                            p = r.getX(n + 2);
                                        s = kl(this, i, t, wl, o, a, l, c, u, h, d, p), s && (s.faceIndex = Math.floor(n / 3), e.push(s))
                                    }
                                } else if (void 0 !== o)
                                    if (Array.isArray(i))
                                        for (let n = 0, r = h.length; n < r; n++) {
                                            const r = h[n],
                                                p = i[r.materialIndex];
                                            for (let n = Math.max(r.start, d.start), i = Math.min(r.start + r.count, d.start + d.count); n < i; n += 3) {
                                                s = kl(this, p, t, wl, o, a, l, c, u, n, n + 1, n + 2), s && (s.faceIndex = Math.floor(n / 3), s.face.materialIndex = r.materialIndex, e.push(s))
                                            }
                                        } else {
                                            for (let n = Math.max(0, d.start), r = Math.min(o.count, d.start + d.count); n < r; n += 3) {
                                                s = kl(this, i, t, wl, o, a, l, c, u, n, n + 1, n + 2), s && (s.faceIndex = Math.floor(n / 3), e.push(s))
                                            }
                                        }
                    } else n.isGeometry && console.error("THREE.Mesh.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")
                }
            });
            class Hl extends _l {
                constructor(t = 1, e = 1, n = 1, i = 1, r = 1, s = 1) {
                    super(), this.type = "BoxGeometry", this.parameters = {
                        width: t,
                        height: e,
                        depth: n,
                        widthSegments: i,
                        heightSegments: r,
                        depthSegments: s
                    };
                    const o = this;
                    i = Math.floor(i), r = Math.floor(r), s = Math.floor(s);
                    const a = [],
                        l = [],
                        c = [],
                        u = [];
                    let h = 0,
                        d = 0;

                    function p(t, e, n, i, r, s, p, f, m, g, v) {
                        const y = s / m,
                            x = p / g,
                            _ = s / 2,
                            b = p / 2,
                            w = f / 2,
                            M = m + 1,
                            S = g + 1;
                        let E = 0,
                            D = 0;
                        const T = new Ao;
                        for (let s = 0; s < S; s++) {
                            const o = s * x - b;
                            for (let a = 0; a < M; a++) {
                                const h = a * y - _;
                                T[t] = h * i, T[e] = o * r, T[n] = w, l.push(T.x, T.y, T.z), T[t] = 0, T[e] = 0, T[n] = f > 0 ? 1 : -1, c.push(T.x, T.y, T.z), u.push(a / m), u.push(1 - s / g), E += 1
                            }
                        }
                        for (let t = 0; t < g; t++)
                            for (let e = 0; e < m; e++) {
                                const n = h + e + M * t,
                                    i = h + e + M * (t + 1),
                                    r = h + (e + 1) + M * (t + 1),
                                    s = h + (e + 1) + M * t;
                                a.push(n, i, s), a.push(i, r, s), D += 6
                            }
                        o.addGroup(d, D, v), d += D, h += E
                    }
                    p("z", "y", "x", -1, -1, n, e, t, s, r, 0), p("z", "y", "x", 1, -1, n, e, -t, s, r, 1), p("x", "z", "y", 1, 1, t, n, e, i, s, 2), p("x", "z", "y", 1, -1, t, n, -e, i, s, 3), p("x", "y", "z", 1, -1, t, e, n, i, r, 4), p("x", "y", "z", -1, -1, t, e, -n, i, r, 5), this.setIndex(a), this.setAttribute("position", new ul(l, 3)), this.setAttribute("normal", new ul(c, 3)), this.setAttribute("uv", new ul(u, 2))
                }
            }

            function Ul(t) {
                const e = {};
                for (const n in t) {
                    e[n] = {};
                    for (const i in t[n]) {
                        const r = t[n][i];
                        r && (r.isColor || r.isMatrix3 || r.isMatrix4 || r.isVector2 || r.isVector3 || r.isVector4 || r.isTexture || r.isQuaternion) ? e[n][i] = r.clone() : Array.isArray(r) ? e[n][i] = r.slice() : e[n][i] = r
                    }
                }
                return e
            }

            function Gl(t) {
                const e = {};
                for (let n = 0; n < t.length; n++) {
                    const i = Ul(t[n]);
                    for (const t in i) e[t] = i[t]
                }
                return e
            }
            const Wl = {
                clone: Ul,
                merge: Gl
            };

            function Vl(t) {
                Va.call(this), this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, this.vertexShader = "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}", this.fragmentShader = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}", this.linewidth = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.clipping = !1, this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.extensions = {
                    derivatives: !1,
                    fragDepth: !1,
                    drawBuffers: !1,
                    shaderTextureLOD: !1
                }, this.defaultAttributeValues = {
                    color: [1, 1, 1],
                    uv: [0, 0],
                    uv2: [0, 0]
                }, this.index0AttributeName = void 0, this.uniformsNeedUpdate = !1, this.glslVersion = null, void 0 !== t && (void 0 !== t.attributes && console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."), this.setValues(t))
            }

            function jl() {
                Ta.call(this), this.type = "Camera", this.matrixWorldInverse = new na, this.projectionMatrix = new na, this.projectionMatrixInverse = new na
            }

            function ql(t = 50, e = 1, n = .1, i = 2e3) {
                jl.call(this), this.type = "PerspectiveCamera", this.fov = t, this.zoom = 1, this.near = n, this.far = i, this.focus = 10, this.aspect = e, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix()
            }
            Vl.prototype = Object.create(Va.prototype), Vl.prototype.constructor = Vl, Vl.prototype.isShaderMaterial = !0, Vl.prototype.copy = function(t) {
                return Va.prototype.copy.call(this, t), this.fragmentShader = t.fragmentShader, this.vertexShader = t.vertexShader, this.uniforms = Ul(t.uniforms), this.defines = Object.assign({}, t.defines), this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.lights = t.lights, this.clipping = t.clipping, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this.extensions = Object.assign({}, t.extensions), this.glslVersion = t.glslVersion, this
            }, Vl.prototype.toJSON = function(t) {
                const e = Va.prototype.toJSON.call(this, t);
                e.glslVersion = this.glslVersion, e.uniforms = {};
                for (const n in this.uniforms) {
                    const i = this.uniforms[n].value;
                    i && i.isTexture ? e.uniforms[n] = {
                        type: "t",
                        value: i.toJSON(t).uuid
                    } : i && i.isColor ? e.uniforms[n] = {
                        type: "c",
                        value: i.getHex()
                    } : i && i.isVector2 ? e.uniforms[n] = {
                        type: "v2",
                        value: i.toArray()
                    } : i && i.isVector3 ? e.uniforms[n] = {
                        type: "v3",
                        value: i.toArray()
                    } : i && i.isVector4 ? e.uniforms[n] = {
                        type: "v4",
                        value: i.toArray()
                    } : i && i.isMatrix3 ? e.uniforms[n] = {
                        type: "m3",
                        value: i.toArray()
                    } : i && i.isMatrix4 ? e.uniforms[n] = {
                        type: "m4",
                        value: i.toArray()
                    } : e.uniforms[n] = {
                        value: i
                    }
                }
                Object.keys(this.defines).length > 0 && (e.defines = this.defines), e.vertexShader = this.vertexShader, e.fragmentShader = this.fragmentShader;
                const n = {};
                for (const t in this.extensions) !0 === this.extensions[t] && (n[t] = !0);
                return Object.keys(n).length > 0 && (e.extensions = n), e
            }, jl.prototype = Object.assign(Object.create(Ta.prototype), {
                constructor: jl,
                isCamera: !0,
                copy: function(t, e) {
                    return Ta.prototype.copy.call(this, t, e), this.matrixWorldInverse.copy(t.matrixWorldInverse), this.projectionMatrix.copy(t.projectionMatrix), this.projectionMatrixInverse.copy(t.projectionMatrixInverse), this
                },
                getWorldDirection: function(t) {
                    void 0 === t && (console.warn("THREE.Camera: .getWorldDirection() target is now required"), t = new Ao), this.updateWorldMatrix(!0, !1);
                    const e = this.matrixWorld.elements;
                    return t.set(-e[8], -e[9], -e[10]).normalize()
                },
                updateMatrixWorld: function(t) {
                    Ta.prototype.updateMatrixWorld.call(this, t), this.matrixWorldInverse.copy(this.matrixWorld).invert()
                },
                updateWorldMatrix: function(t, e) {
                    Ta.prototype.updateWorldMatrix.call(this, t, e), this.matrixWorldInverse.copy(this.matrixWorld).invert()
                },
                clone: function() {
                    return (new this.constructor).copy(this)
                }
            }), ql.prototype = Object.assign(Object.create(jl.prototype), {
                constructor: ql,
                isPerspectiveCamera: !0,
                copy: function(t, e) {
                    return jl.prototype.copy.call(this, t, e), this.fov = t.fov, this.zoom = t.zoom, this.near = t.near, this.far = t.far, this.focus = t.focus, this.aspect = t.aspect, this.view = null === t.view ? null : Object.assign({}, t.view), this.filmGauge = t.filmGauge, this.filmOffset = t.filmOffset, this
                },
                setFocalLength: function(t) {
                    const e = .5 * this.getFilmHeight() / t;
                    this.fov = 2 * vo.RAD2DEG * Math.atan(e), this.updateProjectionMatrix()
                },
                getFocalLength: function() {
                    const t = Math.tan(.5 * vo.DEG2RAD * this.fov);
                    return .5 * this.getFilmHeight() / t
                },
                getEffectiveFOV: function() {
                    return 2 * vo.RAD2DEG * Math.atan(Math.tan(.5 * vo.DEG2RAD * this.fov) / this.zoom)
                },
                getFilmWidth: function() {
                    return this.filmGauge * Math.min(this.aspect, 1)
                },
                getFilmHeight: function() {
                    return this.filmGauge / Math.max(this.aspect, 1)
                },
                setViewOffset: function(t, e, n, i, r, s) {
                    this.aspect = t / e, null === this.view && (this.view = {
                        enabled: !0,
                        fullWidth: 1,
                        fullHeight: 1,
                        offsetX: 0,
                        offsetY: 0,
                        width: 1,
                        height: 1
                    }), this.view.enabled = !0, this.view.fullWidth = t, this.view.fullHeight = e, this.view.offsetX = n, this.view.offsetY = i, this.view.width = r, this.view.height = s, this.updateProjectionMatrix()
                },
                clearViewOffset: function() {
                    null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix()
                },
                updateProjectionMatrix: function() {
                    const t = this.near;
                    let e = t * Math.tan(.5 * vo.DEG2RAD * this.fov) / this.zoom,
                        n = 2 * e,
                        i = this.aspect * n,
                        r = -.5 * i;
                    const s = this.view;
                    if (null !== this.view && this.view.enabled) {
                        const t = s.fullWidth,
                            o = s.fullHeight;
                        r += s.offsetX * i / t, e -= s.offsetY * n / o, i *= s.width / t, n *= s.height / o
                    }
                    const o = this.filmOffset;
                    0 !== o && (r += t * o / this.getFilmWidth()), this.projectionMatrix.makePerspective(r, r + i, e, e - n, t, this.far), this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
                },
                toJSON: function(t) {
                    const e = Ta.prototype.toJSON.call(this, t);
                    return e.object.fov = this.fov, e.object.zoom = this.zoom, e.object.near = this.near, e.object.far = this.far, e.object.focus = this.focus, e.object.aspect = this.aspect, null !== this.view && (e.object.view = Object.assign({}, this.view)), e.object.filmGauge = this.filmGauge, e.object.filmOffset = this.filmOffset, e
                }
            });
            const Xl = 90;
            class Yl extends Ta {
                constructor(t, e, n) {
                    if (super(), this.type = "CubeCamera", !0 !== n.isWebGLCubeRenderTarget) return void console.error("THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter.");
                    this.renderTarget = n;
                    const i = new ql(Xl, 1, t, e);
                    i.layers = this.layers, i.up.set(0, -1, 0), i.lookAt(new Ao(1, 0, 0)), this.add(i);
                    const r = new ql(Xl, 1, t, e);
                    r.layers = this.layers, r.up.set(0, -1, 0), r.lookAt(new Ao(-1, 0, 0)), this.add(r);
                    const s = new ql(Xl, 1, t, e);
                    s.layers = this.layers, s.up.set(0, 0, 1), s.lookAt(new Ao(0, 1, 0)), this.add(s);
                    const o = new ql(Xl, 1, t, e);
                    o.layers = this.layers, o.up.set(0, 0, -1), o.lookAt(new Ao(0, -1, 0)), this.add(o);
                    const a = new ql(Xl, 1, t, e);
                    a.layers = this.layers, a.up.set(0, -1, 0), a.lookAt(new Ao(0, 0, 1)), this.add(a);
                    const l = new ql(Xl, 1, t, e);
                    l.layers = this.layers, l.up.set(0, -1, 0), l.lookAt(new Ao(0, 0, -1)), this.add(l)
                }
                update(t, e) {
                    null === this.parent && this.updateMatrixWorld();
                    const n = this.renderTarget,
                        [i, r, s, o, a, l] = this.children,
                        c = t.xr.enabled,
                        u = t.getRenderTarget();
                    t.xr.enabled = !1;
                    const h = n.texture.generateMipmaps;
                    n.texture.generateMipmaps = !1, t.setRenderTarget(n, 0), t.render(e, i), t.setRenderTarget(n, 1), t.render(e, r), t.setRenderTarget(n, 2), t.render(e, s), t.setRenderTarget(n, 3), t.render(e, o), t.setRenderTarget(n, 4), t.render(e, a), n.texture.generateMipmaps = h, t.setRenderTarget(n, 5), t.render(e, l), t.setRenderTarget(u), t.xr.enabled = c
                }
            }
            class Zl extends Mo {
                constructor(t, e, n, i, r, s, o, a, l, c) {
                    super(t = void 0 !== t ? t : [], e = void 0 !== e ? e : Ls, n, i, r, s, o = void 0 !== o ? o : Ys, a, l, c), this._needsFlipEnvMap = !0, this.flipY = !1
                }
                get images() {
                    return this.image
                }
                set images(t) {
                    this.image = t
                }
            }
            Zl.prototype.isCubeTexture = !0;
            class Jl extends Do {
                constructor(t, e, n) {
                    Number.isInteger(e) && (console.warn("THREE.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget( size, options )"), e = n), super(t, t, e), e = e || {}, this.texture = new Zl(void 0, e.mapping, e.wrapS, e.wrapT, e.magFilter, e.minFilter, e.format, e.type, e.anisotropy, e.encoding), this.texture.generateMipmaps = void 0 !== e.generateMipmaps && e.generateMipmaps, this.texture.minFilter = void 0 !== e.minFilter ? e.minFilter : Hs, this.texture._needsFlipEnvMap = !1
                }
                fromEquirectangularTexture(t, e) {
                    this.texture.type = e.type, this.texture.format = Zs, this.texture.encoding = e.encoding, this.texture.generateMipmaps = e.generateMipmaps, this.texture.minFilter = e.minFilter, this.texture.magFilter = e.magFilter;
                    const n = {
                            uniforms: {
                                tEquirect: {
                                    value: null
                                }
                            },
                            vertexShader: "\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\tvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n\t\t\t\t\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvWorldDirection = transformDirection( position, modelMatrix );\n\n\t\t\t\t\t#include <begin_vertex>\n\t\t\t\t\t#include <project_vertex>\n\n\t\t\t\t}\n\t\t\t",
                            fragmentShader: "\n\n\t\t\t\tuniform sampler2D tEquirect;\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\t#include <common>\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec3 direction = normalize( vWorldDirection );\n\n\t\t\t\t\tvec2 sampleUV = equirectUv( direction );\n\n\t\t\t\t\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\n\t\t\t\t}\n\t\t\t"
                        },
                        i = new Hl(5, 5, 5),
                        r = new Vl({
                            name: "CubemapFromEquirect",
                            uniforms: Ul(n.uniforms),
                            vertexShader: n.vertexShader,
                            fragmentShader: n.fragmentShader,
                            side: 1,
                            blending: 0
                        });
                    r.uniforms.tEquirect.value = e;
                    const s = new zl(i, r),
                        o = e.minFilter;
                    e.minFilter === Us && (e.minFilter = Hs);
                    return new Yl(1, 10, this).update(t, s), e.minFilter = o, s.geometry.dispose(), s.material.dispose(), this
                }
                clear(t, e, n, i) {
                    const r = t.getRenderTarget();
                    for (let r = 0; r < 6; r++) t.setRenderTarget(this, r), t.clear(e, n, i);
                    t.setRenderTarget(r)
                }
            }
            Jl.prototype.isWebGLCubeRenderTarget = !0;
            class Ql extends Mo {
                constructor(t, e, n, i, r, s, o, a, l, c, u, h) {
                    super(null, s, o, a, l, c, i, r, u, h), this.image = {
                        data: t || null,
                        width: e || 1,
                        height: n || 1
                    }, this.magFilter = void 0 !== l ? l : Bs, this.minFilter = void 0 !== c ? c : Bs, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1, this.needsUpdate = !0
                }
            }
            Ql.prototype.isDataTexture = !0;
            const Kl = new Xo,
                $l = new Ao;
            class tc {
                constructor(t = new Ra, e = new Ra, n = new Ra, i = new Ra, r = new Ra, s = new Ra) {
                    this.planes = [t, e, n, i, r, s]
                }
                set(t, e, n, i, r, s) {
                    const o = this.planes;
                    return o[0].copy(t), o[1].copy(e), o[2].copy(n), o[3].copy(i), o[4].copy(r), o[5].copy(s), this
                }
                copy(t) {
                    const e = this.planes;
                    for (let n = 0; n < 6; n++) e[n].copy(t.planes[n]);
                    return this
                }
                setFromProjectionMatrix(t) {
                    const e = this.planes,
                        n = t.elements,
                        i = n[0],
                        r = n[1],
                        s = n[2],
                        o = n[3],
                        a = n[4],
                        l = n[5],
                        c = n[6],
                        u = n[7],
                        h = n[8],
                        d = n[9],
                        p = n[10],
                        f = n[11],
                        m = n[12],
                        g = n[13],
                        v = n[14],
                        y = n[15];
                    return e[0].setComponents(o - i, u - a, f - h, y - m).normalize(), e[1].setComponents(o + i, u + a, f + h, y + m).normalize(), e[2].setComponents(o + r, u + l, f + d, y + g).normalize(), e[3].setComponents(o - r, u - l, f - d, y - g).normalize(), e[4].setComponents(o - s, u - c, f - p, y - v).normalize(), e[5].setComponents(o + s, u + c, f + p, y + v).normalize(), this
                }
                intersectsObject(t) {
                    const e = t.geometry;
                    return null === e.boundingSphere && e.computeBoundingSphere(), Kl.copy(e.boundingSphere).applyMatrix4(t.matrixWorld), this.intersectsSphere(Kl)
                }
                intersectsSprite(t) {
                    return Kl.center.set(0, 0, 0), Kl.radius = .7071067811865476, Kl.applyMatrix4(t.matrixWorld), this.intersectsSphere(Kl)
                }
                intersectsSphere(t) {
                    const e = this.planes,
                        n = t.center,
                        i = -t.radius;
                    for (let t = 0; t < 6; t++) {
                        if (e[t].distanceToPoint(n) < i) return !1
                    }
                    return !0
                }
                intersectsBox(t) {
                    const e = this.planes;
                    for (let n = 0; n < 6; n++) {
                        const i = e[n];
                        if ($l.x = i.normal.x > 0 ? t.max.x : t.min.x, $l.y = i.normal.y > 0 ? t.max.y : t.min.y, $l.z = i.normal.z > 0 ? t.max.z : t.min.z, i.distanceToPoint($l) < 0) return !1
                    }
                    return !0
                }
                containsPoint(t) {
                    const e = this.planes;
                    for (let n = 0; n < 6; n++)
                        if (e[n].distanceToPoint(t) < 0) return !1;
                    return !0
                }
                clone() {
                    return (new this.constructor).copy(this)
                }
            }

            function ec() {
                let t = null,
                    e = !1,
                    n = null,
                    i = null;

                function r(e, s) {
                    n(e, s), i = t.requestAnimationFrame(r)
                }
                return {
                    start: function() {
                        !0 !== e && null !== n && (i = t.requestAnimationFrame(r), e = !0)
                    },
                    stop: function() {
                        t.cancelAnimationFrame(i), e = !1
                    },
                    setAnimationLoop: function(t) {
                        n = t
                    },
                    setContext: function(e) {
                        t = e
                    }
                }
            }

            function nc(t, e) {
                const n = e.isWebGL2,
                    i = new WeakMap;
                return {
                    get: function(t) {
                        return t.isInterleavedBufferAttribute && (t = t.data), i.get(t)
                    },
                    remove: function(e) {
                        e.isInterleavedBufferAttribute && (e = e.data);
                        const n = i.get(e);
                        n && (t.deleteBuffer(n.buffer), i.delete(e))
                    },
                    update: function(e, r) {
                        if (e.isGLBufferAttribute) {
                            const t = i.get(e);
                            return void((!t || t.version < e.version) && i.set(e, {
                                buffer: e.buffer,
                                type: e.type,
                                bytesPerElement: e.elementSize,
                                version: e.version
                            }))
                        }
                        e.isInterleavedBufferAttribute && (e = e.data);
                        const s = i.get(e);
                        void 0 === s ? i.set(e, function(e, i) {
                            const r = e.array,
                                s = e.usage,
                                o = t.createBuffer();
                            t.bindBuffer(i, o), t.bufferData(i, r, s), e.onUploadCallback();
                            let a = 5126;
                            return r instanceof Float32Array ? a = 5126 : r instanceof Float64Array ? console.warn("THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.") : r instanceof Uint16Array ? e.isFloat16BufferAttribute ? n ? a = 5131 : console.warn("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.") : a = 5123 : r instanceof Int16Array ? a = 5122 : r instanceof Uint32Array ? a = 5125 : r instanceof Int32Array ? a = 5124 : r instanceof Int8Array ? a = 5120 : r instanceof Uint8Array && (a = 5121), {
                                buffer: o,
                                type: a,
                                bytesPerElement: r.BYTES_PER_ELEMENT,
                                version: e.version
                            }
                        }(e, r)) : s.version < e.version && (! function(e, i, r) {
                            const s = i.array,
                                o = i.updateRange;
                            t.bindBuffer(r, e), -1 === o.count ? t.bufferSubData(r, 0, s) : (n ? t.bufferSubData(r, o.offset * s.BYTES_PER_ELEMENT, s, o.offset, o.count) : t.bufferSubData(r, o.offset * s.BYTES_PER_ELEMENT, s.subarray(o.offset, o.offset + o.count)), o.count = -1)
                        }(s.buffer, e, r), s.version = e.version)
                    }
                }
            }
            class ic extends _l {
                constructor(t = 1, e = 1, n = 1, i = 1) {
                    super(), this.type = "PlaneGeometry", this.parameters = {
                        width: t,
                        height: e,
                        widthSegments: n,
                        heightSegments: i
                    };
                    const r = t / 2,
                        s = e / 2,
                        o = Math.floor(n),
                        a = Math.floor(i),
                        l = o + 1,
                        c = a + 1,
                        u = t / o,
                        h = e / a,
                        d = [],
                        p = [],
                        f = [],
                        m = [];
                    for (let t = 0; t < c; t++) {
                        const e = t * h - s;
                        for (let n = 0; n < l; n++) {
                            const i = n * u - r;
                            p.push(i, -e, 0), f.push(0, 0, 1), m.push(n / o), m.push(1 - t / a)
                        }
                    }
                    for (let t = 0; t < a; t++)
                        for (let e = 0; e < o; e++) {
                            const n = e + l * t,
                                i = e + l * (t + 1),
                                r = e + 1 + l * (t + 1),
                                s = e + 1 + l * t;
                            d.push(n, i, s), d.push(i, r, s)
                        }
                    this.setIndex(d), this.setAttribute("position", new ul(p, 3)), this.setAttribute("normal", new ul(f, 3)), this.setAttribute("uv", new ul(m, 2))
                }
            }
            const rc = {
                    alphamap_fragment: "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif",
                    alphamap_pars_fragment: "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
                    alphatest_fragment: "#ifdef ALPHATEST\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n#endif",
                    aomap_fragment: "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\t#endif\n#endif",
                    aomap_pars_fragment: "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif",
                    begin_vertex: "vec3 transformed = vec3( position );",
                    beginnormal_vertex: "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif",
                    bsdfs: "vec2 integrateSpecularBRDF( const in float dotNV, const in float roughness ) {\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\treturn vec2( -1.04, 1.04 ) * a004 + r.zw;\n}\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\tif( cutoffDistance > 0.0 ) {\n\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t}\n\treturn distanceFalloff;\n#else\n\tif( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t}\n\treturn 1.0;\n#endif\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nvec3 F_Schlick_RoughnessDependent( const in vec3 F0, const in float dotNV, const in float roughness ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotNV - 6.98316 ) * dotNV );\n\tvec3 Fr = max( vec3( 1.0 - roughness ), F0 ) - F0;\n\treturn Fr * fresnel + F0;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\treturn 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( incidentLight.direction + viewDir );\n\tfloat dotNL = saturate( dot( normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( G * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nvec3 BRDF_Specular_GGX_Environment( const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\treturn specularColor * brdf.x + brdf.y;\n}\nvoid BRDF_Specular_Multiscattering_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tvec3 F = F_Schlick_RoughnessDependent( specularColor, dotNV, roughness );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\tvec3 FssEss = F * brdf.x + brdf.y;\n\tfloat Ess = brdf.x + brdf.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie(float roughness, float NoH) {\n\tfloat invAlpha = 1.0 / roughness;\n\tfloat cos2h = NoH * NoH;\n\tfloat sin2h = max(1.0 - cos2h, 0.0078125);\treturn (2.0 + invAlpha) * pow(sin2h, invAlpha * 0.5) / (2.0 * PI);\n}\nfloat V_Neubelt(float NoV, float NoL) {\n\treturn saturate(1.0 / (4.0 * (NoL + NoV - NoL * NoV)));\n}\nvec3 BRDF_Specular_Sheen( const in float roughness, const in vec3 L, const in GeometricContext geometry, vec3 specularColor ) {\n\tvec3 N = geometry.normal;\n\tvec3 V = geometry.viewDir;\n\tvec3 H = normalize( V + L );\n\tfloat dotNH = saturate( dot( N, H ) );\n\treturn specularColor * D_Charlie( roughness, dotNH ) * V_Neubelt( dot(N, V), dot(N, L) );\n}\n#endif",
                    bumpmap_pars_fragment: "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 ) * faceDirection;\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif",
                    clipping_planes_fragment: "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#pragma unroll_loop_end\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\tif ( clipped ) discard;\n\t#endif\n#endif",
                    clipping_planes_pars_fragment: "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif",
                    clipping_planes_pars_vertex: "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n#endif",
                    clipping_planes_vertex: "#if NUM_CLIPPING_PLANES > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif",
                    color_fragment: "#ifdef USE_COLOR\n\tdiffuseColor.rgb *= vColor;\n#endif",
                    color_pars_fragment: "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif",
                    color_pars_vertex: "#if defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvarying vec3 vColor;\n#endif",
                    color_vertex: "#if defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor.xyz *= color.xyz;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif",
                    common: "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract(sin(sn) * c);\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat max3( vec3 v ) { return max( max( v.x, v.y ), v.z ); }\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\treturn - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}",
                    cube_uv_reflection_fragment: "#ifdef ENVMAP_TYPE_CUBE_UV\n\t#define cubeUV_maxMipLevel 8.0\n\t#define cubeUV_minMipLevel 4.0\n\t#define cubeUV_maxTileSize 256.0\n\t#define cubeUV_minTileSize 16.0\n\tfloat getFace( vec3 direction ) {\n\t\tvec3 absDirection = abs( direction );\n\t\tfloat face = - 1.0;\n\t\tif ( absDirection.x > absDirection.z ) {\n\t\t\tif ( absDirection.x > absDirection.y )\n\t\t\t\tface = direction.x > 0.0 ? 0.0 : 3.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t} else {\n\t\t\tif ( absDirection.z > absDirection.y )\n\t\t\t\tface = direction.z > 0.0 ? 2.0 : 5.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t}\n\t\treturn face;\n\t}\n\tvec2 getUV( vec3 direction, float face ) {\n\t\tvec2 uv;\n\t\tif ( face == 0.0 ) {\n\t\t\tuv = vec2( direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 1.0 ) {\n\t\t\tuv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n\t\t} else if ( face == 2.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.y ) / abs( direction.z );\n\t\t} else if ( face == 3.0 ) {\n\t\t\tuv = vec2( - direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 4.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.z ) / abs( direction.y );\n\t\t} else {\n\t\t\tuv = vec2( direction.x, direction.y ) / abs( direction.z );\n\t\t}\n\t\treturn 0.5 * ( uv + 1.0 );\n\t}\n\tvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n\t\tfloat face = getFace( direction );\n\t\tfloat filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n\t\tmipInt = max( mipInt, cubeUV_minMipLevel );\n\t\tfloat faceSize = exp2( mipInt );\n\t\tfloat texelSize = 1.0 / ( 3.0 * cubeUV_maxTileSize );\n\t\tvec2 uv = getUV( direction, face ) * ( faceSize - 1.0 );\n\t\tvec2 f = fract( uv );\n\t\tuv += 0.5 - f;\n\t\tif ( face > 2.0 ) {\n\t\t\tuv.y += faceSize;\n\t\t\tface -= 3.0;\n\t\t}\n\t\tuv.x += face * faceSize;\n\t\tif ( mipInt < cubeUV_maxMipLevel ) {\n\t\t\tuv.y += 2.0 * cubeUV_maxTileSize;\n\t\t}\n\t\tuv.y += filterInt * 2.0 * cubeUV_minTileSize;\n\t\tuv.x += 3.0 * max( 0.0, cubeUV_maxTileSize - 2.0 * faceSize );\n\t\tuv *= texelSize;\n\t\tvec3 tl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.x += texelSize;\n\t\tvec3 tr = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.y += texelSize;\n\t\tvec3 br = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.x -= texelSize;\n\t\tvec3 bl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tvec3 tm = mix( tl, tr, f.x );\n\t\tvec3 bm = mix( bl, br, f.x );\n\t\treturn mix( tm, bm, f.y );\n\t}\n\t#define r0 1.0\n\t#define v0 0.339\n\t#define m0 - 2.0\n\t#define r1 0.8\n\t#define v1 0.276\n\t#define m1 - 1.0\n\t#define r4 0.4\n\t#define v4 0.046\n\t#define m4 2.0\n\t#define r5 0.305\n\t#define v5 0.016\n\t#define m5 3.0\n\t#define r6 0.21\n\t#define v6 0.0038\n\t#define m6 4.0\n\tfloat roughnessToMip( float roughness ) {\n\t\tfloat mip = 0.0;\n\t\tif ( roughness >= r1 ) {\n\t\t\tmip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;\n\t\t} else if ( roughness >= r4 ) {\n\t\t\tmip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;\n\t\t} else if ( roughness >= r5 ) {\n\t\t\tmip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;\n\t\t} else if ( roughness >= r6 ) {\n\t\t\tmip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;\n\t\t} else {\n\t\t\tmip = - 2.0 * log2( 1.16 * roughness );\t\t}\n\t\treturn mip;\n\t}\n\tvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n\t\tfloat mip = clamp( roughnessToMip( roughness ), m0, cubeUV_maxMipLevel );\n\t\tfloat mipF = fract( mip );\n\t\tfloat mipInt = floor( mip );\n\t\tvec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n\t\tif ( mipF == 0.0 ) {\n\t\t\treturn vec4( color0, 1.0 );\n\t\t} else {\n\t\t\tvec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n\t\t\treturn vec4( mix( color0, color1, mipF ), 1.0 );\n\t\t}\n\t}\n#endif",
                    defaultnormal_vertex: "vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\tmat3 m = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\ttransformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif",
                    displacementmap_pars_vertex: "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif",
                    displacementmap_vertex: "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif",
                    emissivemap_fragment: "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif",
                    emissivemap_pars_fragment: "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif",
                    encodings_fragment: "gl_FragColor = linearToOutputTexel( gl_FragColor );",
                    encodings_pars_fragment: "\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * value.a * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat M = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat D = max( maxRange / maxRGB, 1.0 );\n\tD = clamp( floor( D ) / 255.0, 0.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value ) {\n\tvec3 Xp_Y_XYZp = cLogLuvM * value.rgb;\n\tXp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );\n\tvec4 vResult;\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\tvResult.w = fract( Le );\n\tvResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;\n\treturn vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n\tfloat Le = value.z * 255.0 + value.w;\n\tvec3 Xp_Y_XYZp;\n\tXp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\tvec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;\n\treturn vec4( max( vRGB, 0.0 ), 1.0 );\n}",
                    envmap_fragment: "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifndef ENVMAP_TYPE_CUBE_UV\n\t\tenvColor = envMapTexelToLinear( envColor );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif",
                    envmap_common_pars_fragment: "#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\tuniform int maxMipLevel;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif",
                    envmap_pars_fragment: "#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif",
                    envmap_pars_vertex: "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif",
                    envmap_physical_pars_fragment: "#if defined( USE_ENVMAP )\n\t#ifdef ENVMAP_MODE_REFRACTION\n\t\tuniform float refractionRatio;\n\t#endif\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n\t\t#else\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\t\t#endif\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t}\n\tfloat getSpecularMIPLevel( const in float roughness, const in int maxMIPLevel ) {\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat sigma = PI * roughness * roughness / ( 1.0 + roughness );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar + log2( sigma );\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\t}\n\tvec3 getLightProbeIndirectRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in int maxMIPLevel ) {\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( -viewDir, normal );\n\t\t\treflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( -viewDir, normal, refractionRatio );\n\t\t#endif\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( roughness, maxMIPLevel );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n\t\t#endif\n\t\treturn envMapColor.rgb * envMapIntensity;\n\t}\n#endif",
                    envmap_vertex: "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif",
                    fog_vertex: "#ifdef USE_FOG\n\tfogDepth = - mvPosition.z;\n#endif",
                    fog_pars_vertex: "#ifdef USE_FOG\n\tvarying float fogDepth;\n#endif",
                    fog_fragment: "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * fogDepth * fogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif",
                    fog_pars_fragment: "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float fogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif",
                    gradientmap_pars_fragment: "#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn texture2D( gradientMap, coord ).rgb;\n\t#else\n\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t#endif\n}",
                    lightmap_fragment: "#ifdef USE_LIGHTMAP\n\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\treflectedLight.indirectDiffuse += PI * lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n#endif",
                    lightmap_pars_fragment: "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif",
                    lights_lambert_vertex: "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n\tvIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\nvIndirectFront += getAmbientLightIrradiance( ambientLightColor );\nvIndirectFront += getLightProbeIrradiance( lightProbe, geometry );\n#ifdef DOUBLE_SIDED\n\tvIndirectBack += getAmbientLightIrradiance( ambientLightColor );\n\tvIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry );\n#endif\n#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif",
                    lights_pars_begin: "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in GeometricContext geometry ) {\n\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treturn irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tdirectLight.color = pointLight.color;\n\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\t\tif ( angleCos > spotLight.coneCos ) {\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tirradiance *= PI;\n\t\t#endif\n\t\treturn irradiance;\n\t}\n#endif",
                    lights_toon_fragment: "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;",
                    lights_toon_pars_fragment: "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct ToonMaterial {\n\tvec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon\n#define Material_LightProbeLOD( material )\t(0)",
                    lights_phong_fragment: "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;",
                    lights_phong_pars_fragment: "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n\tvec3 diffuseColor;\n\tvec3 specularColor;\n\tfloat specularShininess;\n\tfloat specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)",
                    lights_physical_fragment: "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.specularRoughness = max( roughnessFactor, 0.0525 );material.specularRoughness += geometryRoughness;\nmaterial.specularRoughness = min( material.specularRoughness, 1.0 );\n#ifdef REFLECTIVITY\n\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#endif\n#ifdef CLEARCOAT\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\t#ifdef USE_CLEARCOATMAP\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vUv ).x;\n\t#endif\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\n\t#endif\n\tmaterial.clearcoat = saturate( material.clearcoat );\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheen;\n#endif",
                    lights_physical_pars_fragment: "struct PhysicalMaterial {\n\tvec3 diffuseColor;\n\tfloat specularRoughness;\n\tvec3 specularColor;\n#ifdef CLEARCOAT\n\tfloat clearcoat;\n\tfloat clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tvec3 sheenColor;\n#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearcoatDHRApprox( const in float roughness, const in float dotNL ) {\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.specularRoughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\t#ifdef CLEARCOAT\n\t\tfloat ccDotNL = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = ccDotNL * directLight.color;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tccIrradiance *= PI;\n\t\t#endif\n\t\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\t\treflectedLight.directSpecular += ccIrradiance * material.clearcoat * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n\t#else\n\t\tfloat clearcoatDHR = 0.0;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_Sheen(\n\t\t\tmaterial.specularRoughness,\n\t\t\tdirectLight.direction,\n\t\t\tgeometry,\n\t\t\tmaterial.sheenColor\n\t\t);\n\t#else\n\t\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.normal, material.specularColor, material.specularRoughness);\n\t#endif\n\treflectedLight.directDiffuse += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef CLEARCOAT\n\t\tfloat ccDotNV = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular += clearcoatRadiance * material.clearcoat * BRDF_Specular_GGX_Environment( geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n\t\tfloat ccDotNL = ccDotNV;\n\t\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\t#else\n\t\tfloat clearcoatDHR = 0.0;\n\t#endif\n\tfloat clearcoatInv = 1.0 - clearcoatDHR;\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\tBRDF_Specular_Multiscattering_Environment( geometry, material.specularColor, material.specularRoughness, singleScattering, multiScattering );\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );\n\treflectedLight.indirectSpecular += clearcoatInv * radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}",
                    lights_fragment_begin: "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef CLEARCOAT\n\tgeometry.clearcoatNormal = clearcoatNormal;\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif",
                    lights_fragment_maps: "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\tvec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.normal, material.specularRoughness, maxMipLevel );\n\t#ifdef CLEARCOAT\n\t\tclearcoatRadiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness, maxMipLevel );\n\t#endif\n#endif",
                    lights_fragment_end: "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif",
                    logdepthbuf_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif",
                    logdepthbuf_pars_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif",
                    logdepthbuf_pars_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif",
                    logdepthbuf_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif",
                    map_fragment: "#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif",
                    map_pars_fragment: "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif",
                    map_particle_fragment: "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n#endif\n#ifdef USE_MAP\n\tvec4 mapTexel = texture2D( map, uv );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif",
                    map_particle_pars_fragment: "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tuniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
                    metalnessmap_fragment: "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif",
                    metalnessmap_pars_fragment: "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif",
                    morphnormal_vertex: "#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n#endif",
                    morphtarget_pars_vertex: "#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifndef USE_MORPHNORMALS\n\t\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\t\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif",
                    morphtarget_vertex: "#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n\t\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\t\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\t\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\t\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t#endif\n#endif",
                    normal_fragment_begin: "float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\t#ifdef USE_TANGENT\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\ttangent = tangent * faceDirection;\n\t\t\tbitangent = bitangent * faceDirection;\n\t\t#endif\n\t\t#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\t\t#endif\n\t#endif\n#endif\nvec3 geometryNormal = normal;",
                    normal_fragment_maps: "#ifdef OBJECTSPACE_NORMALMAP\n\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\t#ifdef USE_TANGENT\n\t\tnormal = normalize( vTBN * mapN );\n\t#else\n\t\tnormal = perturbNormal2Arb( -vViewPosition, normal, mapN, faceDirection );\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif",
                    normalmap_pars_fragment: "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {\n\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tvec3 N = surf_norm;\n\t\tvec3 q1perp = cross( q1, N );\n\t\tvec3 q0perp = cross( N, q0 );\n\t\tvec3 T = q1perp * st0.x + q0perp * st1.x;\n\t\tvec3 B = q1perp * st0.y + q0perp * st1.y;\n\t\tfloat det = max( dot( T, T ), dot( B, B ) );\n\t\tfloat scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );\n\t\treturn normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );\n\t}\n#endif",
                    clearcoat_normal_fragment_begin: "#ifdef CLEARCOAT\n\tvec3 clearcoatNormal = geometryNormal;\n#endif",
                    clearcoat_normal_fragment_maps: "#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\t#ifdef USE_TANGENT\n\t\tclearcoatNormal = normalize( vTBN * clearcoatMapN );\n\t#else\n\t\tclearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );\n\t#endif\n#endif",
                    clearcoat_pars_fragment: "#ifdef USE_CLEARCOATMAP\n\tuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform sampler2D clearcoatRoughnessMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif",
                    packing: "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ));\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w);\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}",
                    premultiplied_alpha_fragment: "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif",
                    project_vertex: "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;",
                    dithering_fragment: "#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif",
                    dithering_pars_fragment: "#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif",
                    roughnessmap_fragment: "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif",
                    roughnessmap_pars_fragment: "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif",
                    shadowmap_pars_fragment: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif",
                    shadowmap_pars_vertex: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif",
                    shadowmap_vertex: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0\n\t\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\tvec4 shadowWorldPosition;\n\t#endif\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n#endif",
                    shadowmask_pars_fragment: "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#endif\n\treturn shadow;\n}",
                    skinbase_vertex: "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif",
                    skinning_pars_vertex: "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform highp sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif",
                    skinning_vertex: "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif",
                    skinnormal_vertex: "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif",
                    specularmap_fragment: "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif",
                    specularmap_pars_fragment: "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif",
                    tonemapping_fragment: "#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif",
                    tonemapping_pars_fragment: "#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n\treturn a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tconst mat3 ACESInputMat = mat3(\n\t\tvec3( 0.59719, 0.07600, 0.02840 ),\t\tvec3( 0.35458, 0.90834, 0.13383 ),\n\t\tvec3( 0.04823, 0.01566, 0.83777 )\n\t);\n\tconst mat3 ACESOutputMat = mat3(\n\t\tvec3(  1.60475, -0.10208, -0.00327 ),\t\tvec3( -0.53108,  1.10813, -0.07276 ),\n\t\tvec3( -0.07367, -0.00605,  1.07602 )\n\t);\n\tcolor *= toneMappingExposure / 0.6;\n\tcolor = ACESInputMat * color;\n\tcolor = RRTAndODTFit( color );\n\tcolor = ACESOutputMat * color;\n\treturn saturate( color );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }",
                    transmissionmap_fragment: "#ifdef USE_TRANSMISSIONMAP\n\ttotalTransmission *= texture2D( transmissionMap, vUv ).r;\n#endif",
                    transmissionmap_pars_fragment: "#ifdef USE_TRANSMISSIONMAP\n\tuniform sampler2D transmissionMap;\n#endif",
                    uv_pars_fragment: "#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n\tvarying vec2 vUv;\n#endif",
                    uv_pars_vertex: "#ifdef USE_UV\n\t#ifdef UVS_VERTEX_ONLY\n\t\tvec2 vUv;\n\t#else\n\t\tvarying vec2 vUv;\n\t#endif\n\tuniform mat3 uvTransform;\n#endif",
                    uv_vertex: "#ifdef USE_UV\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif",
                    uv2_pars_fragment: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif",
                    uv2_pars_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n\tuniform mat3 uv2Transform;\n#endif",
                    uv2_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif",
                    worldpos_vertex: "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif",
                    background_frag: "uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
                    background_vert: "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}",
                    cube_frag: "#include <envmap_common_pars_fragment>\nuniform float opacity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\tvec3 vReflect = vWorldDirection;\n\t#include <envmap_fragment>\n\tgl_FragColor = envColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
                    cube_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}",
                    depth_frag: "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t#endif\n}",
                    depth_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}",
                    distanceRGBA_frag: "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}",
                    distanceRGBA_vert: "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}",
                    equirect_frag: "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV = equirectUv( direction );\n\tvec4 texColor = texture2D( tEquirect, sampleUV );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
                    equirect_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}",
                    linedashed_frag: "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",
                    linedashed_vert: "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",
                    meshbasic_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\treflectedLight.indirectDiffuse += lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
                    meshbasic_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_ENVMAP\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}",
                    meshlambert_frag: "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n\t#else\n\t\treflectedLight.indirectDiffuse += vIndirectFront;\n\t#endif\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
                    meshlambert_vert: "#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
                    meshmatcap_frag: "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t\tmatcapColor = matcapTexelToLinear( matcapColor );\n\t#else\n\t\tvec4 matcapColor = vec4( 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
                    meshmatcap_vert: "#define MATCAP\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#ifndef FLAT_SHADED\n\t\tvNormal = normalize( transformedNormal );\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}",
                    meshtoon_frag: "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
                    meshtoon_vert: "#define TOON\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
                    meshphong_frag: "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
                    meshphong_vert: "#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
                    meshphysical_frag: "#define STANDARD\n#ifdef PHYSICAL\n\t#define REFLECTIVITY\n\t#define CLEARCOAT\n\t#define TRANSMISSION\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef TRANSMISSION\n\tuniform float transmission;\n#endif\n#ifdef REFLECTIVITY\n\tuniform float reflectivity;\n#endif\n#ifdef CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheen;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <transmissionmap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#ifdef TRANSMISSION\n\t\tfloat totalTransmission = transmission;\n\t#endif\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <transmissionmap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#ifdef TRANSMISSION\n\t\tdiffuseColor.a *= mix( saturate( 1. - totalTransmission + linearToRelativeLuminance( reflectedLight.directSpecular + reflectedLight.indirectSpecular ) ), 1.0, metalness );\n\t#endif\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
                    meshphysical_vert: "#define STANDARD\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
                    normal_frag: "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}",
                    normal_vert: "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}",
                    points_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",
                    points_vert: "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}",
                    shadow_frag: "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
                    shadow_vert: "#include <common>\n#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
                    sprite_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
                    sprite_vert: "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}"
                },
                sc = {
                    common: {
                        diffuse: {
                            value: new Qa(15658734)
                        },
                        opacity: {
                            value: 1
                        },
                        map: {
                            value: null
                        },
                        uvTransform: {
                            value: new xo
                        },
                        uv2Transform: {
                            value: new xo
                        },
                        alphaMap: {
                            value: null
                        }
                    },
                    specularmap: {
                        specularMap: {
                            value: null
                        }
                    },
                    envmap: {
                        envMap: {
                            value: null
                        },
                        flipEnvMap: {
                            value: -1
                        },
                        reflectivity: {
                            value: 1
                        },
                        refractionRatio: {
                            value: .98
                        },
                        maxMipLevel: {
                            value: 0
                        }
                    },
                    aomap: {
                        aoMap: {
                            value: null
                        },
                        aoMapIntensity: {
                            value: 1
                        }
                    },
                    lightmap: {
                        lightMap: {
                            value: null
                        },
                        lightMapIntensity: {
                            value: 1
                        }
                    },
                    emissivemap: {
                        emissiveMap: {
                            value: null
                        }
                    },
                    bumpmap: {
                        bumpMap: {
                            value: null
                        },
                        bumpScale: {
                            value: 1
                        }
                    },
                    normalmap: {
                        normalMap: {
                            value: null
                        },
                        normalScale: {
                            value: new yo(1, 1)
                        }
                    },
                    displacementmap: {
                        displacementMap: {
                            value: null
                        },
                        displacementScale: {
                            value: 1
                        },
                        displacementBias: {
                            value: 0
                        }
                    },
                    roughnessmap: {
                        roughnessMap: {
                            value: null
                        }
                    },
                    metalnessmap: {
                        metalnessMap: {
                            value: null
                        }
                    },
                    gradientmap: {
                        gradientMap: {
                            value: null
                        }
                    },
                    fog: {
                        fogDensity: {
                            value: 25e-5
                        },
                        fogNear: {
                            value: 1
                        },
                        fogFar: {
                            value: 2e3
                        },
                        fogColor: {
                            value: new Qa(16777215)
                        }
                    },
                    lights: {
                        ambientLightColor: {
                            value: []
                        },
                        lightProbe: {
                            value: []
                        },
                        directionalLights: {
                            value: [],
                            properties: {
                                direction: {},
                                color: {}
                            }
                        },
                        directionalLightShadows: {
                            value: [],
                            properties: {
                                shadowBias: {},
                                shadowNormalBias: {},
                                shadowRadius: {},
                                shadowMapSize: {}
                            }
                        },
                        directionalShadowMap: {
                            value: []
                        },
                        directionalShadowMatrix: {
                            value: []
                        },
                        spotLights: {
                            value: [],
                            properties: {
                                color: {},
                                position: {},
                                direction: {},
                                distance: {},
                                coneCos: {},
                                penumbraCos: {},
                                decay: {}
                            }
                        },
                        spotLightShadows: {
                            value: [],
                            properties: {
                                shadowBias: {},
                                shadowNormalBias: {},
                                shadowRadius: {},
                                shadowMapSize: {}
                            }
                        },
                        spotShadowMap: {
                            value: []
                        },
                        spotShadowMatrix: {
                            value: []
                        },
                        pointLights: {
                            value: [],
                            properties: {
                                color: {},
                                position: {},
                                decay: {},
                                distance: {}
                            }
                        },
                        pointLightShadows: {
                            value: [],
                            properties: {
                                shadowBias: {},
                                shadowNormalBias: {},
                                shadowRadius: {},
                                shadowMapSize: {},
                                shadowCameraNear: {},
                                shadowCameraFar: {}
                            }
                        },
                        pointShadowMap: {
                            value: []
                        },
                        pointShadowMatrix: {
                            value: []
                        },
                        hemisphereLights: {
                            value: [],
                            properties: {
                                direction: {},
                                skyColor: {},
                                groundColor: {}
                            }
                        },
                        rectAreaLights: {
                            value: [],
                            properties: {
                                color: {},
                                position: {},
                                width: {},
                                height: {}
                            }
                        },
                        ltc_1: {
                            value: null
                        },
                        ltc_2: {
                            value: null
                        }
                    },
                    points: {
                        diffuse: {
                            value: new Qa(15658734)
                        },
                        opacity: {
                            value: 1
                        },
                        size: {
                            value: 1
                        },
                        scale: {
                            value: 1
                        },
                        map: {
                            value: null
                        },
                        alphaMap: {
                            value: null
                        },
                        uvTransform: {
                            value: new xo
                        }
                    },
                    sprite: {
                        diffuse: {
                            value: new Qa(15658734)
                        },
                        opacity: {
                            value: 1
                        },
                        center: {
                            value: new yo(.5, .5)
                        },
                        rotation: {
                            value: 0
                        },
                        map: {
                            value: null
                        },
                        alphaMap: {
                            value: null
                        },
                        uvTransform: {
                            value: new xo
                        }
                    }
                },
                oc = {
                    basic: {
                        uniforms: Gl([sc.common, sc.specularmap, sc.envmap, sc.aomap, sc.lightmap, sc.fog]),
                        vertexShader: rc.meshbasic_vert,
                        fragmentShader: rc.meshbasic_frag
                    },
                    lambert: {
                        uniforms: Gl([sc.common, sc.specularmap, sc.envmap, sc.aomap, sc.lightmap, sc.emissivemap, sc.fog, sc.lights, {
                            emissive: {
                                value: new Qa(0)
                            }
                        }]),
                        vertexShader: rc.meshlambert_vert,
                        fragmentShader: rc.meshlambert_frag
                    },
                    phong: {
                        uniforms: Gl([sc.common, sc.specularmap, sc.envmap, sc.aomap, sc.lightmap, sc.emissivemap, sc.bumpmap, sc.normalmap, sc.displacementmap, sc.fog, sc.lights, {
                            emissive: {
                                value: new Qa(0)
                            },
                            specular: {
                                value: new Qa(1118481)
                            },
                            shininess: {
                                value: 30
                            }
                        }]),
                        vertexShader: rc.meshphong_vert,
                        fragmentShader: rc.meshphong_frag
                    },
                    standard: {
                        uniforms: Gl([sc.common, sc.envmap, sc.aomap, sc.lightmap, sc.emissivemap, sc.bumpmap, sc.normalmap, sc.displacementmap, sc.roughnessmap, sc.metalnessmap, sc.fog, sc.lights, {
                            emissive: {
                                value: new Qa(0)
                            },
                            roughness: {
                                value: 1
                            },
                            metalness: {
                                value: 0
                            },
                            envMapIntensity: {
                                value: 1
                            }
                        }]),
                        vertexShader: rc.meshphysical_vert,
                        fragmentShader: rc.meshphysical_frag
                    },
                    toon: {
                        uniforms: Gl([sc.common, sc.aomap, sc.lightmap, sc.emissivemap, sc.bumpmap, sc.normalmap, sc.displacementmap, sc.gradientmap, sc.fog, sc.lights, {
                            emissive: {
                                value: new Qa(0)
                            }
                        }]),
                        vertexShader: rc.meshtoon_vert,
                        fragmentShader: rc.meshtoon_frag
                    },
                    matcap: {
                        uniforms: Gl([sc.common, sc.bumpmap, sc.normalmap, sc.displacementmap, sc.fog, {
                            matcap: {
                                value: null
                            }
                        }]),
                        vertexShader: rc.meshmatcap_vert,
                        fragmentShader: rc.meshmatcap_frag
                    },
                    points: {
                        uniforms: Gl([sc.points, sc.fog]),
                        vertexShader: rc.points_vert,
                        fragmentShader: rc.points_frag
                    },
                    dashed: {
                        uniforms: Gl([sc.common, sc.fog, {
                            scale: {
                                value: 1
                            },
                            dashSize: {
                                value: 1
                            },
                            totalSize: {
                                value: 2
                            }
                        }]),
                        vertexShader: rc.linedashed_vert,
                        fragmentShader: rc.linedashed_frag
                    },
                    depth: {
                        uniforms: Gl([sc.common, sc.displacementmap]),
                        vertexShader: rc.depth_vert,
                        fragmentShader: rc.depth_frag
                    },
                    normal: {
                        uniforms: Gl([sc.common, sc.bumpmap, sc.normalmap, sc.displacementmap, {
                            opacity: {
                                value: 1
                            }
                        }]),
                        vertexShader: rc.normal_vert,
                        fragmentShader: rc.normal_frag
                    },
                    sprite: {
                        uniforms: Gl([sc.sprite, sc.fog]),
                        vertexShader: rc.sprite_vert,
                        fragmentShader: rc.sprite_frag
                    },
                    background: {
                        uniforms: {
                            uvTransform: {
                                value: new xo
                            },
                            t2D: {
                                value: null
                            }
                        },
                        vertexShader: rc.background_vert,
                        fragmentShader: rc.background_frag
                    },
                    cube: {
                        uniforms: Gl([sc.envmap, {
                            opacity: {
                                value: 1
                            }
                        }]),
                        vertexShader: rc.cube_vert,
                        fragmentShader: rc.cube_frag
                    },
                    equirect: {
                        uniforms: {
                            tEquirect: {
                                value: null
                            }
                        },
                        vertexShader: rc.equirect_vert,
                        fragmentShader: rc.equirect_frag
                    },
                    distanceRGBA: {
                        uniforms: Gl([sc.common, sc.displacementmap, {
                            referencePosition: {
                                value: new Ao
                            },
                            nearDistance: {
                                value: 1
                            },
                            farDistance: {
                                value: 1e3
                            }
                        }]),
                        vertexShader: rc.distanceRGBA_vert,
                        fragmentShader: rc.distanceRGBA_frag
                    },
                    shadow: {
                        uniforms: Gl([sc.lights, sc.fog, {
                            color: {
                                value: new Qa(0)
                            },
                            opacity: {
                                value: 1
                            }
                        }]),
                        vertexShader: rc.shadow_vert,
                        fragmentShader: rc.shadow_frag
                    }
                };

            function ac(t, e, n, i, r) {
                const s = new Qa(0);
                let o, a, l = 0,
                    c = null,
                    u = 0,
                    h = null;

                function d(t, e) {
                    n.buffers.color.setClear(t.r, t.g, t.b, e, r)
                }
                return {
                    getClearColor: function() {
                        return s
                    },
                    setClearColor: function(t, e = 1) {
                        s.set(t), l = e, d(s, l)
                    },
                    getClearAlpha: function() {
                        return l
                    },
                    setClearAlpha: function(t) {
                        l = t, d(s, l)
                    },
                    render: function(n, r, p, f) {
                        let m = !0 === r.isScene ? r.background : null;
                        m && m.isTexture && (m = e.get(m));
                        const g = t.xr,
                            v = g.getSession && g.getSession();
                        v && "additive" === v.environmentBlendMode && (m = null), null === m ? d(s, l) : m && m.isColor && (d(m, 1), f = !0), (t.autoClear || f) && t.clear(t.autoClearColor, t.autoClearDepth, t.autoClearStencil), m && (m.isCubeTexture || m.isWebGLCubeRenderTarget || m.mapping === Ps) ? (void 0 === a && (a = new zl(new Hl(1, 1, 1), new Vl({
                            name: "BackgroundCubeMaterial",
                            uniforms: Ul(oc.cube.uniforms),
                            vertexShader: oc.cube.vertexShader,
                            fragmentShader: oc.cube.fragmentShader,
                            side: 1,
                            depthTest: !1,
                            depthWrite: !1,
                            fog: !1
                        })), a.geometry.deleteAttribute("normal"), a.geometry.deleteAttribute("uv"), a.onBeforeRender = function(t, e, n) {
                            this.matrixWorld.copyPosition(n.matrixWorld)
                        }, Object.defineProperty(a.material, "envMap", {
                            get: function() {
                                return this.uniforms.envMap.value
                            }
                        }), i.update(a)), m.isWebGLCubeRenderTarget && (m = m.texture), a.material.uniforms.envMap.value = m, a.material.uniforms.flipEnvMap.value = m.isCubeTexture && m._needsFlipEnvMap ? -1 : 1, c === m && u === m.version && h === t.toneMapping || (a.material.needsUpdate = !0, c = m, u = m.version, h = t.toneMapping), n.unshift(a, a.geometry, a.material, 0, 0, null)) : m && m.isTexture && (void 0 === o && (o = new zl(new ic(2, 2), new Vl({
                            name: "BackgroundMaterial",
                            uniforms: Ul(oc.background.uniforms),
                            vertexShader: oc.background.vertexShader,
                            fragmentShader: oc.background.fragmentShader,
                            side: 0,
                            depthTest: !1,
                            depthWrite: !1,
                            fog: !1
                        })), o.geometry.deleteAttribute("normal"), Object.defineProperty(o.material, "map", {
                            get: function() {
                                return this.uniforms.t2D.value
                            }
                        }), i.update(o)), o.material.uniforms.t2D.value = m, !0 === m.matrixAutoUpdate && m.updateMatrix(), o.material.uniforms.uvTransform.value.copy(m.matrix), c === m && u === m.version && h === t.toneMapping || (o.material.needsUpdate = !0, c = m, u = m.version, h = t.toneMapping), n.unshift(o, o.geometry, o.material, 0, 0, null))
                    }
                }
            }

            function lc(t, e, n, i) {
                const r = t.getParameter(34921),
                    s = i.isWebGL2 ? null : e.get("OES_vertex_array_object"),
                    o = i.isWebGL2 || null !== s,
                    a = {},
                    l = d(null);
                let c = l;

                function u(e) {
                    return i.isWebGL2 ? t.bindVertexArray(e) : s.bindVertexArrayOES(e)
                }

                function h(e) {
                    return i.isWebGL2 ? t.deleteVertexArray(e) : s.deleteVertexArrayOES(e)
                }

                function d(t) {
                    const e = [],
                        n = [],
                        i = [];
                    for (let t = 0; t < r; t++) e[t] = 0, n[t] = 0, i[t] = 0;
                    return {
                        geometry: null,
                        program: null,
                        wireframe: !1,
                        newAttributes: e,
                        enabledAttributes: n,
                        attributeDivisors: i,
                        object: t,
                        attributes: {},
                        index: null
                    }
                }

                function p() {
                    const t = c.newAttributes;
                    for (let e = 0, n = t.length; e < n; e++) t[e] = 0
                }

                function f(t) {
                    m(t, 0)
                }

                function m(n, r) {
                    const s = c.newAttributes,
                        o = c.enabledAttributes,
                        a = c.attributeDivisors;
                    if (s[n] = 1, 0 === o[n] && (t.enableVertexAttribArray(n), o[n] = 1), a[n] !== r) {
                        (i.isWebGL2 ? t : e.get("ANGLE_instanced_arrays"))[i.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](n, r), a[n] = r
                    }
                }

                function g() {
                    const e = c.newAttributes,
                        n = c.enabledAttributes;
                    for (let i = 0, r = n.length; i < r; i++) n[i] !== e[i] && (t.disableVertexAttribArray(i), n[i] = 0)
                }

                function v(e, n, r, s, o, a) {
                    !0 !== i.isWebGL2 || 5124 !== r && 5125 !== r ? t.vertexAttribPointer(e, n, r, s, o, a) : t.vertexAttribIPointer(e, n, r, o, a)
                }

                function y() {
                    x(), c !== l && (c = l, u(c.object))
                }

                function x() {
                    l.geometry = null, l.program = null, l.wireframe = !1
                }
                return {
                    setup: function(r, l, h, y, x) {
                        let _ = !1;
                        if (o) {
                            const e = function(e, n, r) {
                                const o = !0 === r.wireframe;
                                let l = a[e.id];
                                void 0 === l && (l = {}, a[e.id] = l);
                                let c = l[n.id];
                                void 0 === c && (c = {}, l[n.id] = c);
                                let u = c[o];
                                void 0 === u && (u = d(i.isWebGL2 ? t.createVertexArray() : s.createVertexArrayOES()), c[o] = u);
                                return u
                            }(y, h, l);
                            c !== e && (c = e, u(c.object)), _ = function(t, e) {
                                const n = c.attributes,
                                    i = t.attributes;
                                let r = 0;
                                for (const t in i) {
                                    const e = n[t],
                                        s = i[t];
                                    if (void 0 === e) return !0;
                                    if (e.attribute !== s) return !0;
                                    if (e.data !== s.data) return !0;
                                    r++
                                }
                                return c.attributesNum !== r || c.index !== e
                            }(y, x), _ && function(t, e) {
                                const n = {},
                                    i = t.attributes;
                                let r = 0;
                                for (const t in i) {
                                    const e = i[t],
                                        s = {};
                                    s.attribute = e, e.data && (s.data = e.data), n[t] = s, r++
                                }
                                c.attributes = n, c.attributesNum = r, c.index = e
                            }(y, x)
                        } else {
                            const t = !0 === l.wireframe;
                            c.geometry === y.id && c.program === h.id && c.wireframe === t || (c.geometry = y.id, c.program = h.id, c.wireframe = t, _ = !0)
                        }!0 === r.isInstancedMesh && (_ = !0), null !== x && n.update(x, 34963), _ && (! function(r, s, o, a) {
                            if (!1 === i.isWebGL2 && (r.isInstancedMesh || a.isInstancedBufferGeometry) && null === e.get("ANGLE_instanced_arrays")) return;
                            p();
                            const l = a.attributes,
                                c = o.getAttributes(),
                                u = s.defaultAttributeValues;
                            for (const e in c) {
                                const i = c[e];
                                if (i >= 0) {
                                    const s = l[e];
                                    if (void 0 !== s) {
                                        const e = s.normalized,
                                            r = s.itemSize,
                                            o = n.get(s);
                                        if (void 0 === o) continue;
                                        const l = o.buffer,
                                            c = o.type,
                                            u = o.bytesPerElement;
                                        if (s.isInterleavedBufferAttribute) {
                                            const n = s.data,
                                                o = n.stride,
                                                h = s.offset;
                                            n && n.isInstancedInterleavedBuffer ? (m(i, n.meshPerAttribute), void 0 === a._maxInstanceCount && (a._maxInstanceCount = n.meshPerAttribute * n.count)) : f(i), t.bindBuffer(34962, l), v(i, r, c, e, o * u, h * u)
                                        } else s.isInstancedBufferAttribute ? (m(i, s.meshPerAttribute), void 0 === a._maxInstanceCount && (a._maxInstanceCount = s.meshPerAttribute * s.count)) : f(i), t.bindBuffer(34962, l), v(i, r, c, e, 0, 0)
                                    } else if ("instanceMatrix" === e) {
                                        const e = n.get(r.instanceMatrix);
                                        if (void 0 === e) continue;
                                        const s = e.buffer,
                                            o = e.type;
                                        m(i + 0, 1), m(i + 1, 1), m(i + 2, 1), m(i + 3, 1), t.bindBuffer(34962, s), t.vertexAttribPointer(i + 0, 4, o, !1, 64, 0), t.vertexAttribPointer(i + 1, 4, o, !1, 64, 16), t.vertexAttribPointer(i + 2, 4, o, !1, 64, 32), t.vertexAttribPointer(i + 3, 4, o, !1, 64, 48)
                                    } else if ("instanceColor" === e) {
                                        const e = n.get(r.instanceColor);
                                        if (void 0 === e) continue;
                                        const s = e.buffer,
                                            o = e.type;
                                        m(i, 1), t.bindBuffer(34962, s), t.vertexAttribPointer(i, 3, o, !1, 12, 0)
                                    } else if (void 0 !== u) {
                                        const n = u[e];
                                        if (void 0 !== n) switch (n.length) {
                                            case 2:
                                                t.vertexAttrib2fv(i, n);
                                                break;
                                            case 3:
                                                t.vertexAttrib3fv(i, n);
                                                break;
                                            case 4:
                                                t.vertexAttrib4fv(i, n);
                                                break;
                                            default:
                                                t.vertexAttrib1fv(i, n)
                                        }
                                    }
                                }
                            }
                            g()
                        }(r, l, h, y), null !== x && t.bindBuffer(34963, n.get(x).buffer))
                    },
                    reset: y,
                    resetDefaultState: x,
                    dispose: function() {
                        y();
                        for (const t in a) {
                            const e = a[t];
                            for (const t in e) {
                                const n = e[t];
                                for (const t in n) h(n[t].object), delete n[t];
                                delete e[t]
                            }
                            delete a[t]
                        }
                    },
                    releaseStatesOfGeometry: function(t) {
                        if (void 0 === a[t.id]) return;
                        const e = a[t.id];
                        for (const t in e) {
                            const n = e[t];
                            for (const t in n) h(n[t].object), delete n[t];
                            delete e[t]
                        }
                        delete a[t.id]
                    },
                    releaseStatesOfProgram: function(t) {
                        for (const e in a) {
                            const n = a[e];
                            if (void 0 === n[t.id]) continue;
                            const i = n[t.id];
                            for (const t in i) h(i[t].object), delete i[t];
                            delete n[t.id]
                        }
                    },
                    initAttributes: p,
                    enableAttribute: f,
                    disableUnusedAttributes: g
                }
            }

            function cc(t, e, n, i) {
                const r = i.isWebGL2;
                let s;
                this.setMode = function(t) {
                    s = t
                }, this.render = function(e, i) {
                    t.drawArrays(s, e, i), n.update(i, s, 1)
                }, this.renderInstances = function(i, o, a) {
                    if (0 === a) return;
                    let l, c;
                    if (r) l = t, c = "drawArraysInstanced";
                    else if (l = e.get("ANGLE_instanced_arrays"), c = "drawArraysInstancedANGLE", null === l) return void console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
                    l[c](s, i, o, a), n.update(o, s, a)
                }
            }

            function uc(t, e, n) {
                let i;

                function r(e) {
                    if ("highp" === e) {
                        if (t.getShaderPrecisionFormat(35633, 36338).precision > 0 && t.getShaderPrecisionFormat(35632, 36338).precision > 0) return "highp";
                        e = "mediump"
                    }
                    return "mediump" === e && t.getShaderPrecisionFormat(35633, 36337).precision > 0 && t.getShaderPrecisionFormat(35632, 36337).precision > 0 ? "mediump" : "lowp"
                }
                const s = "undefined" != typeof WebGL2RenderingContext && t instanceof WebGL2RenderingContext || "undefined" != typeof WebGL2ComputeRenderingContext && t instanceof WebGL2ComputeRenderingContext;
                let o = void 0 !== n.precision ? n.precision : "highp";
                const a = r(o);
                a !== o && (console.warn("THREE.WebGLRenderer:", o, "not supported, using", a, "instead."), o = a);
                const l = !0 === n.logarithmicDepthBuffer,
                    c = t.getParameter(34930),
                    u = t.getParameter(35660),
                    h = t.getParameter(3379),
                    d = t.getParameter(34076),
                    p = t.getParameter(34921),
                    f = t.getParameter(36347),
                    m = t.getParameter(36348),
                    g = t.getParameter(36349),
                    v = u > 0,
                    y = s || e.has("OES_texture_float");
                return {
                    isWebGL2: s,
                    getMaxAnisotropy: function() {
                        if (void 0 !== i) return i;
                        if (!0 === e.has("EXT_texture_filter_anisotropic")) {
                            const n = e.get("EXT_texture_filter_anisotropic");
                            i = t.getParameter(n.MAX_TEXTURE_MAX_ANISOTROPY_EXT)
                        } else i = 0;
                        return i
                    },
                    getMaxPrecision: r,
                    precision: o,
                    logarithmicDepthBuffer: l,
                    maxTextures: c,
                    maxVertexTextures: u,
                    maxTextureSize: h,
                    maxCubemapSize: d,
                    maxAttributes: p,
                    maxVertexUniforms: f,
                    maxVaryings: m,
                    maxFragmentUniforms: g,
                    vertexTextures: v,
                    floatFragmentTextures: y,
                    floatVertexTextures: v && y,
                    maxSamples: s ? t.getParameter(36183) : 0
                }
            }

            function hc(t) {
                const e = this;
                let n = null,
                    i = 0,
                    r = !1,
                    s = !1;
                const o = new Ra,
                    a = new xo,
                    l = {
                        value: null,
                        needsUpdate: !1
                    };

                function c() {
                    l.value !== n && (l.value = n, l.needsUpdate = i > 0), e.numPlanes = i, e.numIntersection = 0
                }

                function u(t, n, i, r) {
                    const s = null !== t ? t.length : 0;
                    let c = null;
                    if (0 !== s) {
                        if (c = l.value, !0 !== r || null === c) {
                            const e = i + 4 * s,
                                r = n.matrixWorldInverse;
                            a.getNormalMatrix(r), (null === c || c.length < e) && (c = new Float32Array(e));
                            for (let e = 0, n = i; e !== s; ++e, n += 4) o.copy(t[e]).applyMatrix4(r, a), o.normal.toArray(c, n), c[n + 3] = o.constant
                        }
                        l.value = c, l.needsUpdate = !0
                    }
                    return e.numPlanes = s, e.numIntersection = 0, c
                }
                this.uniform = l, this.numPlanes = 0, this.numIntersection = 0, this.init = function(t, e, s) {
                    const o = 0 !== t.length || e || 0 !== i || r;
                    return r = e, n = u(t, s, 0), i = t.length, o
                }, this.beginShadows = function() {
                    s = !0, u(null)
                }, this.endShadows = function() {
                    s = !1, c()
                }, this.setState = function(e, o, a) {
                    const h = e.clippingPlanes,
                        d = e.clipIntersection,
                        p = e.clipShadows,
                        f = t.get(e);
                    if (!r || null === h || 0 === h.length || s && !p) s ? u(null) : c();
                    else {
                        const t = s ? 0 : i,
                            e = 4 * t;
                        let r = f.clippingState || null;
                        l.value = r, r = u(h, o, e, a);
                        for (let t = 0; t !== e; ++t) r[t] = n[t];
                        f.clippingState = r, this.numIntersection = d ? this.numPlanes : 0, this.numPlanes += t
                    }
                }
            }

            function dc(t) {
                let e = new WeakMap;

                function n(t, e) {
                    return 303 === e ? t.mapping = Ls : 304 === e && (t.mapping = Rs), t
                }

                function i(t) {
                    const n = t.target;
                    n.removeEventListener("dispose", i);
                    const r = e.get(n);
                    void 0 !== r && (e.delete(n), r.dispose())
                }
                return {
                    get: function(r) {
                        if (r && r.isTexture) {
                            const s = r.mapping;
                            if (303 === s || 304 === s) {
                                if (e.has(r)) {
                                    return n(e.get(r).texture, r.mapping)
                                } {
                                    const s = r.image;
                                    if (s && s.height > 0) {
                                        const o = t.getRenderTarget(),
                                            a = new Jl(s.height / 2);
                                        return a.fromEquirectangularTexture(t, r), e.set(r, a), t.setRenderTarget(o), r.addEventListener("dispose", i), n(a.texture, r.mapping)
                                    }
                                    return null
                                }
                            }
                        }
                        return r
                    },
                    dispose: function() {
                        e = new WeakMap
                    }
                }
            }

            function pc(t) {
                const e = {};

                function n(n) {
                    if (void 0 !== e[n]) return e[n];
                    let i;
                    switch (n) {
                        case "WEBGL_depth_texture":
                            i = t.getExtension("WEBGL_depth_texture") || t.getExtension("MOZ_WEBGL_depth_texture") || t.getExtension("WEBKIT_WEBGL_depth_texture");
                            break;
                        case "EXT_texture_filter_anisotropic":
                            i = t.getExtension("EXT_texture_filter_anisotropic") || t.getExtension("MOZ_EXT_texture_filter_anisotropic") || t.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
                            break;
                        case "WEBGL_compressed_texture_s3tc":
                            i = t.getExtension("WEBGL_compressed_texture_s3tc") || t.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || t.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
                            break;
                        case "WEBGL_compressed_texture_pvrtc":
                            i = t.getExtension("WEBGL_compressed_texture_pvrtc") || t.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
                            break;
                        default:
                            i = t.getExtension(n)
                    }
                    return e[n] = i, i
                }
                return {
                    has: function(t) {
                        return null !== n(t)
                    },
                    init: function(t) {
                        t.isWebGL2 ? n("EXT_color_buffer_float") : (n("WEBGL_depth_texture"), n("OES_texture_float"), n("OES_texture_half_float"), n("OES_texture_half_float_linear"), n("OES_standard_derivatives"), n("OES_element_index_uint"), n("OES_vertex_array_object"), n("ANGLE_instanced_arrays")), n("OES_texture_float_linear"), n("EXT_color_buffer_half_float")
                    },
                    get: function(t) {
                        const e = n(t);
                        return null === e && console.warn("THREE.WebGLRenderer: " + t + " extension not supported."), e
                    }
                }
            }

            function fc(t, e, n, i) {
                const r = {},
                    s = new WeakMap;

                function o(t) {
                    const a = t.target;
                    null !== a.index && e.remove(a.index);
                    for (const t in a.attributes) e.remove(a.attributes[t]);
                    a.removeEventListener("dispose", o), delete r[a.id];
                    const l = s.get(a);
                    l && (e.remove(l), s.delete(a)), i.releaseStatesOfGeometry(a), !0 === a.isInstancedBufferGeometry && delete a._maxInstanceCount, n.memory.geometries--
                }

                function a(t) {
                    const n = [],
                        i = t.index,
                        r = t.attributes.position;
                    let o = 0;
                    if (null !== i) {
                        const t = i.array;
                        o = i.version;
                        for (let e = 0, i = t.length; e < i; e += 3) {
                            const i = t[e + 0],
                                r = t[e + 1],
                                s = t[e + 2];
                            n.push(i, r, r, s, s, i)
                        }
                    } else {
                        const t = r.array;
                        o = r.version;
                        for (let e = 0, i = t.length / 3 - 1; e < i; e += 3) {
                            const t = e + 0,
                                i = e + 1,
                                r = e + 2;
                            n.push(t, i, i, r, r, t)
                        }
                    }
                    const a = new(dl(n) > 65535 ? ll : ol)(n, 1);
                    a.version = o;
                    const l = s.get(t);
                    l && e.remove(l), s.set(t, a)
                }
                return {
                    get: function(t, e) {
                        return !0 === r[e.id] || (e.addEventListener("dispose", o), r[e.id] = !0, n.memory.geometries++), e
                    },
                    update: function(t) {
                        const n = t.attributes;
                        for (const t in n) e.update(n[t], 34962);
                        const i = t.morphAttributes;
                        for (const t in i) {
                            const n = i[t];
                            for (let t = 0, i = n.length; t < i; t++) e.update(n[t], 34962)
                        }
                    },
                    getWireframeAttribute: function(t) {
                        const e = s.get(t);
                        if (e) {
                            const n = t.index;
                            null !== n && e.version < n.version && a(t)
                        } else a(t);
                        return s.get(t)
                    }
                }
            }

            function mc(t, e, n, i) {
                const r = i.isWebGL2;
                let s, o, a;
                this.setMode = function(t) {
                    s = t
                }, this.setIndex = function(t) {
                    o = t.type, a = t.bytesPerElement
                }, this.render = function(e, i) {
                    t.drawElements(s, i, o, e * a), n.update(i, s, 1)
                }, this.renderInstances = function(i, l, c) {
                    if (0 === c) return;
                    let u, h;
                    if (r) u = t, h = "drawElementsInstanced";
                    else if (u = e.get("ANGLE_instanced_arrays"), h = "drawElementsInstancedANGLE", null === u) return void console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
                    u[h](s, l, o, i * a, c), n.update(l, s, c)
                }
            }

            function gc(t) {
                const e = {
                    frame: 0,
                    calls: 0,
                    triangles: 0,
                    points: 0,
                    lines: 0
                };
                return {
                    memory: {
                        geometries: 0,
                        textures: 0
                    },
                    render: e,
                    programs: null,
                    autoReset: !0,
                    reset: function() {
                        e.frame++, e.calls = 0, e.triangles = 0, e.points = 0, e.lines = 0
                    },
                    update: function(t, n, i) {
                        switch (e.calls++, n) {
                            case 4:
                                e.triangles += i * (t / 3);
                                break;
                            case 1:
                                e.lines += i * (t / 2);
                                break;
                            case 3:
                                e.lines += i * (t - 1);
                                break;
                            case 2:
                                e.lines += i * t;
                                break;
                            case 0:
                                e.points += i * t;
                                break;
                            default:
                                console.error("THREE.WebGLInfo: Unknown draw mode:", n)
                        }
                    }
                }
            }

            function vc(t, e) {
                return t[0] - e[0]
            }

            function yc(t, e) {
                return Math.abs(e[1]) - Math.abs(t[1])
            }

            function xc(t) {
                const e = {},
                    n = new Float32Array(8),
                    i = [];
                for (let t = 0; t < 8; t++) i[t] = [t, 0];
                return {
                    update: function(r, s, o, a) {
                        const l = r.morphTargetInfluences,
                            c = void 0 === l ? 0 : l.length;
                        let u = e[s.id];
                        if (void 0 === u) {
                            u = [];
                            for (let t = 0; t < c; t++) u[t] = [t, 0];
                            e[s.id] = u
                        }
                        for (let t = 0; t < c; t++) {
                            const e = u[t];
                            e[0] = t, e[1] = l[t]
                        }
                        u.sort(yc);
                        for (let t = 0; t < 8; t++) t < c && u[t][1] ? (i[t][0] = u[t][0], i[t][1] = u[t][1]) : (i[t][0] = Number.MAX_SAFE_INTEGER, i[t][1] = 0);
                        i.sort(vc);
                        const h = o.morphTargets && s.morphAttributes.position,
                            d = o.morphNormals && s.morphAttributes.normal;
                        let p = 0;
                        for (let t = 0; t < 8; t++) {
                            const e = i[t],
                                r = e[0],
                                o = e[1];
                            r !== Number.MAX_SAFE_INTEGER && o ? (h && s.getAttribute("morphTarget" + t) !== h[r] && s.setAttribute("morphTarget" + t, h[r]), d && s.getAttribute("morphNormal" + t) !== d[r] && s.setAttribute("morphNormal" + t, d[r]), n[t] = o, p += o) : (h && !0 === s.hasAttribute("morphTarget" + t) && s.deleteAttribute("morphTarget" + t), d && !0 === s.hasAttribute("morphNormal" + t) && s.deleteAttribute("morphNormal" + t), n[t] = 0)
                        }
                        const f = s.morphTargetsRelative ? 1 : 1 - p;
                        a.getUniforms().setValue(t, "morphTargetBaseInfluence", f), a.getUniforms().setValue(t, "morphTargetInfluences", n)
                    }
                }
            }

            function _c(t, e, n, i) {
                let r = new WeakMap;

                function s(t) {
                    const e = t.target;
                    e.removeEventListener("dispose", s), n.remove(e.instanceMatrix), null !== e.instanceColor && n.remove(e.instanceColor)
                }
                return {
                    update: function(t) {
                        const o = i.render.frame,
                            a = t.geometry,
                            l = e.get(t, a);
                        return r.get(l) !== o && (e.update(l), r.set(l, o)), t.isInstancedMesh && (!1 === t.hasEventListener("dispose", s) && t.addEventListener("dispose", s), n.update(t.instanceMatrix, 34962), null !== t.instanceColor && n.update(t.instanceColor, 34962)), l
                    },
                    dispose: function() {
                        r = new WeakMap
                    }
                }
            }
            oc.physical = {
                uniforms: Gl([oc.standard.uniforms, {
                    clearcoat: {
                        value: 0
                    },
                    clearcoatMap: {
                        value: null
                    },
                    clearcoatRoughness: {
                        value: 0
                    },
                    clearcoatRoughnessMap: {
                        value: null
                    },
                    clearcoatNormalScale: {
                        value: new yo(1, 1)
                    },
                    clearcoatNormalMap: {
                        value: null
                    },
                    sheen: {
                        value: new Qa(0)
                    },
                    transmission: {
                        value: 0
                    },
                    transmissionMap: {
                        value: null
                    }
                }]),
                vertexShader: rc.meshphysical_vert,
                fragmentShader: rc.meshphysical_frag
            };
            class bc extends Mo {
                constructor(t = null, e = 1, n = 1, i = 1) {
                    super(null), this.image = {
                        data: t,
                        width: e,
                        height: n,
                        depth: i
                    }, this.magFilter = Bs, this.minFilter = Bs, this.wrapR = Is, this.generateMipmaps = !1, this.flipY = !1, this.needsUpdate = !0
                }
            }
            bc.prototype.isDataTexture2DArray = !0;
            class wc extends Mo {
                constructor(t = null, e = 1, n = 1, i = 1) {
                    super(null), this.image = {
                        data: t,
                        width: e,
                        height: n,
                        depth: i
                    }, this.magFilter = Bs, this.minFilter = Bs, this.wrapR = Is, this.generateMipmaps = !1, this.flipY = !1, this.needsUpdate = !0
                }
            }
            wc.prototype.isDataTexture3D = !0;
            const Mc = new Mo,
                Sc = new bc,
                Ec = new wc,
                Dc = new Zl,
                Tc = [],
                Ac = [],
                Cc = new Float32Array(16),
                Lc = new Float32Array(9),
                Rc = new Float32Array(4);

            function Pc(t, e, n) {
                const i = t[0];
                if (i <= 0 || i > 0) return t;
                const r = e * n;
                let s = Tc[r];
                if (void 0 === s && (s = new Float32Array(r), Tc[r] = s), 0 !== e) {
                    i.toArray(s, 0);
                    for (let i = 1, r = 0; i !== e; ++i) r += n, t[i].toArray(s, r)
                }
                return s
            }

            function Fc(t, e) {
                if (t.length !== e.length) return !1;
                for (let n = 0, i = t.length; n < i; n++)
                    if (t[n] !== e[n]) return !1;
                return !0
            }

            function Oc(t, e) {
                for (let n = 0, i = e.length; n < i; n++) t[n] = e[n]
            }

            function Ic(t, e) {
                let n = Ac[e];
                void 0 === n && (n = new Int32Array(e), Ac[e] = n);
                for (let i = 0; i !== e; ++i) n[i] = t.allocateTextureUnit();
                return n
            }

            function Nc(t, e) {
                const n = this.cache;
                n[0] !== e && (t.uniform1f(this.addr, e), n[0] = e)
            }

            function Bc(t, e) {
                const n = this.cache;
                if (void 0 !== e.x) n[0] === e.x && n[1] === e.y || (t.uniform2f(this.addr, e.x, e.y), n[0] = e.x, n[1] = e.y);
                else {
                    if (Fc(n, e)) return;
                    t.uniform2fv(this.addr, e), Oc(n, e)
                }
            }

            function zc(t, e) {
                const n = this.cache;
                if (void 0 !== e.x) n[0] === e.x && n[1] === e.y && n[2] === e.z || (t.uniform3f(this.addr, e.x, e.y, e.z), n[0] = e.x, n[1] = e.y, n[2] = e.z);
                else if (void 0 !== e.r) n[0] === e.r && n[1] === e.g && n[2] === e.b || (t.uniform3f(this.addr, e.r, e.g, e.b), n[0] = e.r, n[1] = e.g, n[2] = e.b);
                else {
                    if (Fc(n, e)) return;
                    t.uniform3fv(this.addr, e), Oc(n, e)
                }
            }

            function kc(t, e) {
                const n = this.cache;
                if (void 0 !== e.x) n[0] === e.x && n[1] === e.y && n[2] === e.z && n[3] === e.w || (t.uniform4f(this.addr, e.x, e.y, e.z, e.w), n[0] = e.x, n[1] = e.y, n[2] = e.z, n[3] = e.w);
                else {
                    if (Fc(n, e)) return;
                    t.uniform4fv(this.addr, e), Oc(n, e)
                }
            }

            function Hc(t, e) {
                const n = this.cache,
                    i = e.elements;
                if (void 0 === i) {
                    if (Fc(n, e)) return;
                    t.uniformMatrix2fv(this.addr, !1, e), Oc(n, e)
                } else {
                    if (Fc(n, i)) return;
                    Rc.set(i), t.uniformMatrix2fv(this.addr, !1, Rc), Oc(n, i)
                }
            }

            function Uc(t, e) {
                const n = this.cache,
                    i = e.elements;
                if (void 0 === i) {
                    if (Fc(n, e)) return;
                    t.uniformMatrix3fv(this.addr, !1, e), Oc(n, e)
                } else {
                    if (Fc(n, i)) return;
                    Lc.set(i), t.uniformMatrix3fv(this.addr, !1, Lc), Oc(n, i)
                }
            }

            function Gc(t, e) {
                const n = this.cache,
                    i = e.elements;
                if (void 0 === i) {
                    if (Fc(n, e)) return;
                    t.uniformMatrix4fv(this.addr, !1, e), Oc(n, e)
                } else {
                    if (Fc(n, i)) return;
                    Cc.set(i), t.uniformMatrix4fv(this.addr, !1, Cc), Oc(n, i)
                }
            }

            function Wc(t, e, n) {
                const i = this.cache,
                    r = n.allocateTextureUnit();
                i[0] !== r && (t.uniform1i(this.addr, r), i[0] = r), n.safeSetTexture2D(e || Mc, r)
            }

            function Vc(t, e, n) {
                const i = this.cache,
                    r = n.allocateTextureUnit();
                i[0] !== r && (t.uniform1i(this.addr, r), i[0] = r), n.setTexture2DArray(e || Sc, r)
            }

            function jc(t, e, n) {
                const i = this.cache,
                    r = n.allocateTextureUnit();
                i[0] !== r && (t.uniform1i(this.addr, r), i[0] = r), n.setTexture3D(e || Ec, r)
            }

            function qc(t, e, n) {
                const i = this.cache,
                    r = n.allocateTextureUnit();
                i[0] !== r && (t.uniform1i(this.addr, r), i[0] = r), n.safeSetTextureCube(e || Dc, r)
            }

            function Xc(t, e) {
                const n = this.cache;
                n[0] !== e && (t.uniform1i(this.addr, e), n[0] = e)
            }

            function Yc(t, e) {
                const n = this.cache;
                Fc(n, e) || (t.uniform2iv(this.addr, e), Oc(n, e))
            }

            function Zc(t, e) {
                const n = this.cache;
                Fc(n, e) || (t.uniform3iv(this.addr, e), Oc(n, e))
            }

            function Jc(t, e) {
                const n = this.cache;
                Fc(n, e) || (t.uniform4iv(this.addr, e), Oc(n, e))
            }

            function Qc(t, e) {
                const n = this.cache;
                n[0] !== e && (t.uniform1ui(this.addr, e), n[0] = e)
            }

            function Kc(t, e) {
                t.uniform1fv(this.addr, e)
            }

            function $c(t, e) {
                t.uniform1iv(this.addr, e)
            }

            function tu(t, e) {
                t.uniform2iv(this.addr, e)
            }

            function eu(t, e) {
                t.uniform3iv(this.addr, e)
            }

            function nu(t, e) {
                t.uniform4iv(this.addr, e)
            }

            function iu(t, e) {
                const n = Pc(e, this.size, 2);
                t.uniform2fv(this.addr, n)
            }

            function ru(t, e) {
                const n = Pc(e, this.size, 3);
                t.uniform3fv(this.addr, n)
            }

            function su(t, e) {
                const n = Pc(e, this.size, 4);
                t.uniform4fv(this.addr, n)
            }

            function ou(t, e) {
                const n = Pc(e, this.size, 4);
                t.uniformMatrix2fv(this.addr, !1, n)
            }

            function au(t, e) {
                const n = Pc(e, this.size, 9);
                t.uniformMatrix3fv(this.addr, !1, n)
            }

            function lu(t, e) {
                const n = Pc(e, this.size, 16);
                t.uniformMatrix4fv(this.addr, !1, n)
            }

            function cu(t, e, n) {
                const i = e.length,
                    r = Ic(n, i);
                t.uniform1iv(this.addr, r);
                for (let t = 0; t !== i; ++t) n.safeSetTexture2D(e[t] || Mc, r[t])
            }

            function uu(t, e, n) {
                const i = e.length,
                    r = Ic(n, i);
                t.uniform1iv(this.addr, r);
                for (let t = 0; t !== i; ++t) n.safeSetTextureCube(e[t] || Dc, r[t])
            }

            function hu(t, e, n) {
                this.id = t, this.addr = n, this.cache = [], this.setValue = function(t) {
                    switch (t) {
                        case 5126:
                            return Nc;
                        case 35664:
                            return Bc;
                        case 35665:
                            return zc;
                        case 35666:
                            return kc;
                        case 35674:
                            return Hc;
                        case 35675:
                            return Uc;
                        case 35676:
                            return Gc;
                        case 5124:
                        case 35670:
                            return Xc;
                        case 35667:
                        case 35671:
                            return Yc;
                        case 35668:
                        case 35672:
                            return Zc;
                        case 35669:
                        case 35673:
                            return Jc;
                        case 5125:
                            return Qc;
                        case 35678:
                        case 36198:
                        case 36298:
                        case 36306:
                        case 35682:
                            return Wc;
                        case 35679:
                        case 36299:
                        case 36307:
                            return jc;
                        case 35680:
                        case 36300:
                        case 36308:
                        case 36293:
                            return qc;
                        case 36289:
                        case 36303:
                        case 36311:
                        case 36292:
                            return Vc
                    }
                }(e.type)
            }

            function du(t, e, n) {
                this.id = t, this.addr = n, this.cache = [], this.size = e.size, this.setValue = function(t) {
                    switch (t) {
                        case 5126:
                            return Kc;
                        case 35664:
                            return iu;
                        case 35665:
                            return ru;
                        case 35666:
                            return su;
                        case 35674:
                            return ou;
                        case 35675:
                            return au;
                        case 35676:
                            return lu;
                        case 5124:
                        case 35670:
                            return $c;
                        case 35667:
                        case 35671:
                            return tu;
                        case 35668:
                        case 35672:
                            return eu;
                        case 35669:
                        case 35673:
                            return nu;
                        case 35678:
                        case 36198:
                        case 36298:
                        case 36306:
                        case 35682:
                            return cu;
                        case 35680:
                        case 36300:
                        case 36308:
                        case 36293:
                            return uu
                    }
                }(e.type)
            }

            function pu(t) {
                this.id = t, this.seq = [], this.map = {}
            }
            du.prototype.updateCache = function(t) {
                const e = this.cache;
                t instanceof Float32Array && e.length !== t.length && (this.cache = new Float32Array(t.length)), Oc(e, t)
            }, pu.prototype.setValue = function(t, e, n) {
                const i = this.seq;
                for (let r = 0, s = i.length; r !== s; ++r) {
                    const s = i[r];
                    s.setValue(t, e[s.id], n)
                }
            };
            const fu = /(\w+)(\])?(\[|\.)?/g;

            function mu(t, e) {
                t.seq.push(e), t.map[e.id] = e
            }

            function gu(t, e, n) {
                const i = t.name,
                    r = i.length;
                for (fu.lastIndex = 0;;) {
                    const s = fu.exec(i),
                        o = fu.lastIndex;
                    let a = s[1];
                    const l = "]" === s[2],
                        c = s[3];
                    if (l && (a |= 0), void 0 === c || "[" === c && o + 2 === r) {
                        mu(n, void 0 === c ? new hu(a, t, e) : new du(a, t, e));
                        break
                    } {
                        let t = n.map[a];
                        void 0 === t && (t = new pu(a), mu(n, t)), n = t
                    }
                }
            }

            function vu(t, e) {
                this.seq = [], this.map = {};
                const n = t.getProgramParameter(e, 35718);
                for (let i = 0; i < n; ++i) {
                    const n = t.getActiveUniform(e, i);
                    gu(n, t.getUniformLocation(e, n.name), this)
                }
            }

            function yu(t, e, n) {
                const i = t.createShader(e);
                return t.shaderSource(i, n), t.compileShader(i), i
            }
            vu.prototype.setValue = function(t, e, n, i) {
                const r = this.map[e];
                void 0 !== r && r.setValue(t, n, i)
            }, vu.prototype.setOptional = function(t, e, n) {
                const i = e[n];
                void 0 !== i && this.setValue(t, n, i)
            }, vu.upload = function(t, e, n, i) {
                for (let r = 0, s = e.length; r !== s; ++r) {
                    const s = e[r],
                        o = n[s.id];
                    !1 !== o.needsUpdate && s.setValue(t, o.value, i)
                }
            }, vu.seqWithValue = function(t, e) {
                const n = [];
                for (let i = 0, r = t.length; i !== r; ++i) {
                    const r = t[i];
                    r.id in e && n.push(r)
                }
                return n
            };
            let xu = 0;

            function _u(t) {
                switch (t) {
                    case so:
                        return ["Linear", "( value )"];
                    case oo:
                        return ["sRGB", "( value )"];
                    case lo:
                        return ["RGBE", "( value )"];
                    case 3004:
                        return ["RGBM", "( value, 7.0 )"];
                    case 3005:
                        return ["RGBM", "( value, 16.0 )"];
                    case 3006:
                        return ["RGBD", "( value, 256.0 )"];
                    case ao:
                        return ["Gamma", "( value, float( GAMMA_FACTOR ) )"];
                    case 3003:
                        return ["LogLuv", "( value )"];
                    default:
                        return console.warn("THREE.WebGLProgram: Unsupported encoding:", t), ["Linear", "( value )"]
                }
            }

            function bu(t, e, n) {
                const i = t.getShaderParameter(e, 35713),
                    r = t.getShaderInfoLog(e).trim();
                if (i && "" === r) return "";
                return "THREE.WebGLShader: gl.getShaderInfoLog() " + n + "\n" + r + function(t) {
                    const e = t.split("\n");
                    for (let t = 0; t < e.length; t++) e[t] = t + 1 + ": " + e[t];
                    return e.join("\n")
                }(t.getShaderSource(e))
            }

            function wu(t, e) {
                const n = _u(e);
                return "vec4 " + t + "( vec4 value ) { return " + n[0] + "ToLinear" + n[1] + "; }"
            }

            function Mu(t, e) {
                const n = _u(e);
                return "vec4 " + t + "( vec4 value ) { return LinearTo" + n[0] + n[1] + "; }"
            }

            function Su(t, e) {
                let n;
                switch (e) {
                    case 1:
                        n = "Linear";
                        break;
                    case 2:
                        n = "Reinhard";
                        break;
                    case 3:
                        n = "OptimizedCineon";
                        break;
                    case 4:
                        n = "ACESFilmic";
                        break;
                    case 5:
                        n = "Custom";
                        break;
                    default:
                        console.warn("THREE.WebGLProgram: Unsupported toneMapping:", e), n = "Linear"
                }
                return "vec3 " + t + "( vec3 color ) { return " + n + "ToneMapping( color ); }"
            }

            function Eu(t) {
                return "" !== t
            }

            function Du(t, e) {
                return t.replace(/NUM_DIR_LIGHTS/g, e.numDirLights).replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, e.numPointLights).replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows)
            }

            function Tu(t, e) {
                return t.replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, e.numClippingPlanes - e.numClipIntersection)
            }
            const Au = /^[ \t]*#include +<([\w\d./]+)>/gm;

            function Cu(t) {
                return t.replace(Au, Lu)
            }

            function Lu(t, e) {
                const n = rc[e];
                if (void 0 === n) throw new Error("Can not resolve #include <" + e + ">");
                return Cu(n)
            }
            const Ru = /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g,
                Pu = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;

            function Fu(t) {
                return t.replace(Pu, Iu).replace(Ru, Ou)
            }

            function Ou(t, e, n, i) {
                return console.warn("WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead."), Iu(t, e, n, i)
            }

            function Iu(t, e, n, i) {
                let r = "";
                for (let t = parseInt(e); t < parseInt(n); t++) r += i.replace(/\[\s*i\s*\]/g, "[ " + t + " ]").replace(/UNROLLED_LOOP_INDEX/g, t);
                return r
            }

            function Nu(t) {
                let e = "precision " + t.precision + " float;\nprecision " + t.precision + " int;";
                return "highp" === t.precision ? e += "\n#define HIGH_PRECISION" : "mediump" === t.precision ? e += "\n#define MEDIUM_PRECISION" : "lowp" === t.precision && (e += "\n#define LOW_PRECISION"), e
            }

            function Bu(t, e, n, i) {
                const r = t.getContext(),
                    s = n.defines;
                let o = n.vertexShader,
                    a = n.fragmentShader;
                const l = function(t) {
                        let e = "SHADOWMAP_TYPE_BASIC";
                        return 1 === t.shadowMapType ? e = "SHADOWMAP_TYPE_PCF" : 2 === t.shadowMapType ? e = "SHADOWMAP_TYPE_PCF_SOFT" : 3 === t.shadowMapType && (e = "SHADOWMAP_TYPE_VSM"), e
                    }(n),
                    c = function(t) {
                        let e = "ENVMAP_TYPE_CUBE";
                        if (t.envMap) switch (t.envMapMode) {
                            case Ls:
                            case Rs:
                                e = "ENVMAP_TYPE_CUBE";
                                break;
                            case Ps:
                            case Fs:
                                e = "ENVMAP_TYPE_CUBE_UV"
                        }
                        return e
                    }(n),
                    u = function(t) {
                        let e = "ENVMAP_MODE_REFLECTION";
                        if (t.envMap) switch (t.envMapMode) {
                            case Rs:
                            case Fs:
                                e = "ENVMAP_MODE_REFRACTION"
                        }
                        return e
                    }(n),
                    h = function(t) {
                        let e = "ENVMAP_BLENDING_NONE";
                        if (t.envMap) switch (t.combine) {
                            case 0:
                                e = "ENVMAP_BLENDING_MULTIPLY";
                                break;
                            case 1:
                                e = "ENVMAP_BLENDING_MIX";
                                break;
                            case 2:
                                e = "ENVMAP_BLENDING_ADD"
                        }
                        return e
                    }(n),
                    d = t.gammaFactor > 0 ? t.gammaFactor : 1,
                    p = n.isWebGL2 ? "" : function(t) {
                        return [t.extensionDerivatives || t.envMapCubeUV || t.bumpMap || t.tangentSpaceNormalMap || t.clearcoatNormalMap || t.flatShading || "physical" === t.shaderID ? "#extension GL_OES_standard_derivatives : enable" : "", (t.extensionFragDepth || t.logarithmicDepthBuffer) && t.rendererExtensionFragDepth ? "#extension GL_EXT_frag_depth : enable" : "", t.extensionDrawBuffers && t.rendererExtensionDrawBuffers ? "#extension GL_EXT_draw_buffers : require" : "", (t.extensionShaderTextureLOD || t.envMap) && t.rendererExtensionShaderTextureLod ? "#extension GL_EXT_shader_texture_lod : enable" : ""].filter(Eu).join("\n")
                    }(n),
                    f = function(t) {
                        const e = [];
                        for (const n in t) {
                            const i = t[n];
                            !1 !== i && e.push("#define " + n + " " + i)
                        }
                        return e.join("\n")
                    }(s),
                    m = r.createProgram();
                let g, v, y = n.glslVersion ? "#version " + n.glslVersion + "\n" : "";
                n.isRawShaderMaterial ? (g = [f].filter(Eu).join("\n"), g.length > 0 && (g += "\n"), v = [p, f].filter(Eu).join("\n"), v.length > 0 && (v += "\n")) : (g = [Nu(n), "#define SHADER_NAME " + n.shaderName, f, n.instancing ? "#define USE_INSTANCING" : "", n.instancingColor ? "#define USE_INSTANCING_COLOR" : "", n.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "", "#define GAMMA_FACTOR " + d, "#define MAX_BONES " + n.maxBones, n.useFog && n.fog ? "#define USE_FOG" : "", n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "", n.map ? "#define USE_MAP" : "", n.envMap ? "#define USE_ENVMAP" : "", n.envMap ? "#define " + u : "", n.lightMap ? "#define USE_LIGHTMAP" : "", n.aoMap ? "#define USE_AOMAP" : "", n.emissiveMap ? "#define USE_EMISSIVEMAP" : "", n.bumpMap ? "#define USE_BUMPMAP" : "", n.normalMap ? "#define USE_NORMALMAP" : "", n.normalMap && n.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", n.normalMap && n.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", n.displacementMap && n.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "", n.specularMap ? "#define USE_SPECULARMAP" : "", n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", n.metalnessMap ? "#define USE_METALNESSMAP" : "", n.alphaMap ? "#define USE_ALPHAMAP" : "", n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", n.vertexTangents ? "#define USE_TANGENT" : "", n.vertexColors ? "#define USE_COLOR" : "", n.vertexUvs ? "#define USE_UV" : "", n.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", n.flatShading ? "#define FLAT_SHADED" : "", n.skinning ? "#define USE_SKINNING" : "", n.useVertexTexture ? "#define BONE_TEXTURE" : "", n.morphTargets ? "#define USE_MORPHTARGETS" : "", n.morphNormals && !1 === n.flatShading ? "#define USE_MORPHNORMALS" : "", n.doubleSided ? "#define DOUBLE_SIDED" : "", n.flipSided ? "#define FLIP_SIDED" : "", n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", n.shadowMapEnabled ? "#define " + l : "", n.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", n.logarithmicDepthBuffer && n.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", "#ifdef USE_INSTANCING", "\tattribute mat4 instanceMatrix;", "#endif", "#ifdef USE_INSTANCING_COLOR", "\tattribute vec3 instanceColor;", "#endif", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_TANGENT", "\tattribute vec4 tangent;", "#endif", "#ifdef USE_COLOR", "\tattribute vec3 color;", "#endif", "#ifdef USE_MORPHTARGETS", "\tattribute vec3 morphTarget0;", "\tattribute vec3 morphTarget1;", "\tattribute vec3 morphTarget2;", "\tattribute vec3 morphTarget3;", "\t#ifdef USE_MORPHNORMALS", "\t\tattribute vec3 morphNormal0;", "\t\tattribute vec3 morphNormal1;", "\t\tattribute vec3 morphNormal2;", "\t\tattribute vec3 morphNormal3;", "\t#else", "\t\tattribute vec3 morphTarget4;", "\t\tattribute vec3 morphTarget5;", "\t\tattribute vec3 morphTarget6;", "\t\tattribute vec3 morphTarget7;", "\t#endif", "#endif", "#ifdef USE_SKINNING", "\tattribute vec4 skinIndex;", "\tattribute vec4 skinWeight;", "#endif", "\n"].filter(Eu).join("\n"), v = [p, Nu(n), "#define SHADER_NAME " + n.shaderName, f, n.alphaTest ? "#define ALPHATEST " + n.alphaTest + (n.alphaTest % 1 ? "" : ".0") : "", "#define GAMMA_FACTOR " + d, n.useFog && n.fog ? "#define USE_FOG" : "", n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "", n.map ? "#define USE_MAP" : "", n.matcap ? "#define USE_MATCAP" : "", n.envMap ? "#define USE_ENVMAP" : "", n.envMap ? "#define " + c : "", n.envMap ? "#define " + u : "", n.envMap ? "#define " + h : "", n.lightMap ? "#define USE_LIGHTMAP" : "", n.aoMap ? "#define USE_AOMAP" : "", n.emissiveMap ? "#define USE_EMISSIVEMAP" : "", n.bumpMap ? "#define USE_BUMPMAP" : "", n.normalMap ? "#define USE_NORMALMAP" : "", n.normalMap && n.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", n.normalMap && n.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", n.specularMap ? "#define USE_SPECULARMAP" : "", n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", n.metalnessMap ? "#define USE_METALNESSMAP" : "", n.alphaMap ? "#define USE_ALPHAMAP" : "", n.sheen ? "#define USE_SHEEN" : "", n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", n.vertexTangents ? "#define USE_TANGENT" : "", n.vertexColors || n.instancingColor ? "#define USE_COLOR" : "", n.vertexUvs ? "#define USE_UV" : "", n.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", n.gradientMap ? "#define USE_GRADIENTMAP" : "", n.flatShading ? "#define FLAT_SHADED" : "", n.doubleSided ? "#define DOUBLE_SIDED" : "", n.flipSided ? "#define FLIP_SIDED" : "", n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", n.shadowMapEnabled ? "#define " + l : "", n.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", n.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "", n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", n.logarithmicDepthBuffer && n.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", (n.extensionShaderTextureLOD || n.envMap) && n.rendererExtensionShaderTextureLod ? "#define TEXTURE_LOD_EXT" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", 0 !== n.toneMapping ? "#define TONE_MAPPING" : "", 0 !== n.toneMapping ? rc.tonemapping_pars_fragment : "", 0 !== n.toneMapping ? Su("toneMapping", n.toneMapping) : "", n.dithering ? "#define DITHERING" : "", rc.encodings_pars_fragment, n.map ? wu("mapTexelToLinear", n.mapEncoding) : "", n.matcap ? wu("matcapTexelToLinear", n.matcapEncoding) : "", n.envMap ? wu("envMapTexelToLinear", n.envMapEncoding) : "", n.emissiveMap ? wu("emissiveMapTexelToLinear", n.emissiveMapEncoding) : "", n.lightMap ? wu("lightMapTexelToLinear", n.lightMapEncoding) : "", Mu("linearToOutputTexel", n.outputEncoding), n.depthPacking ? "#define DEPTH_PACKING " + n.depthPacking : "", "\n"].filter(Eu).join("\n")), o = Cu(o), o = Du(o, n), o = Tu(o, n), a = Cu(a), a = Du(a, n), a = Tu(a, n), o = Fu(o), a = Fu(a), n.isWebGL2 && !0 !== n.isRawShaderMaterial && (y = "#version 300 es\n", g = ["#define attribute in", "#define varying out", "#define texture2D texture"].join("\n") + "\n" + g, v = ["#define varying in", n.glslVersion === po ? "" : "out highp vec4 pc_fragColor;", n.glslVersion === po ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth", "#define texture2D texture", "#define textureCube texture", "#define texture2DProj textureProj", "#define texture2DLodEXT textureLod", "#define texture2DProjLodEXT textureProjLod", "#define textureCubeLodEXT textureLod", "#define texture2DGradEXT textureGrad", "#define texture2DProjGradEXT textureProjGrad", "#define textureCubeGradEXT textureGrad"].join("\n") + "\n" + v);
                const x = y + v + a,
                    _ = yu(r, 35633, y + g + o),
                    b = yu(r, 35632, x);
                if (r.attachShader(m, _), r.attachShader(m, b), void 0 !== n.index0AttributeName ? r.bindAttribLocation(m, 0, n.index0AttributeName) : !0 === n.morphTargets && r.bindAttribLocation(m, 0, "position"), r.linkProgram(m), t.debug.checkShaderErrors) {
                    const t = r.getProgramInfoLog(m).trim(),
                        e = r.getShaderInfoLog(_).trim(),
                        n = r.getShaderInfoLog(b).trim();
                    let i = !0,
                        s = !0;
                    if (!1 === r.getProgramParameter(m, 35714)) {
                        i = !1;
                        const e = bu(r, _, "vertex"),
                            n = bu(r, b, "fragment");
                        console.error("THREE.WebGLProgram: shader error: ", r.getError(), "35715", r.getProgramParameter(m, 35715), "gl.getProgramInfoLog", t, e, n)
                    } else "" !== t ? console.warn("THREE.WebGLProgram: gl.getProgramInfoLog()", t) : "" !== e && "" !== n || (s = !1);
                    s && (this.diagnostics = {
                        runnable: i,
                        programLog: t,
                        vertexShader: {
                            log: e,
                            prefix: g
                        },
                        fragmentShader: {
                            log: n,
                            prefix: v
                        }
                    })
                }
                let w, M;
                return r.deleteShader(_), r.deleteShader(b), this.getUniforms = function() {
                    return void 0 === w && (w = new vu(r, m)), w
                }, this.getAttributes = function() {
                    return void 0 === M && (M = function(t, e) {
                        const n = {},
                            i = t.getProgramParameter(e, 35721);
                        for (let r = 0; r < i; r++) {
                            const i = t.getActiveAttrib(e, r).name;
                            n[i] = t.getAttribLocation(e, i)
                        }
                        return n
                    }(r, m)), M
                }, this.destroy = function() {
                    i.releaseStatesOfProgram(this), r.deleteProgram(m), this.program = void 0
                }, this.name = n.shaderName, this.id = xu++, this.cacheKey = e, this.usedTimes = 1, this.program = m, this.vertexShader = _, this.fragmentShader = b, this
            }

            function zu(t, e, n, i, r, s) {
                const o = [],
                    a = i.isWebGL2,
                    l = i.logarithmicDepthBuffer,
                    c = i.floatVertexTextures,
                    u = i.maxVertexUniforms,
                    h = i.vertexTextures;
                let d = i.precision;
                const p = {
                        MeshDepthMaterial: "depth",
                        MeshDistanceMaterial: "distanceRGBA",
                        MeshNormalMaterial: "normal",
                        MeshBasicMaterial: "basic",
                        MeshLambertMaterial: "lambert",
                        MeshPhongMaterial: "phong",
                        MeshToonMaterial: "toon",
                        MeshStandardMaterial: "physical",
                        MeshPhysicalMaterial: "physical",
                        MeshMatcapMaterial: "matcap",
                        LineBasicMaterial: "basic",
                        LineDashedMaterial: "dashed",
                        PointsMaterial: "points",
                        ShadowMaterial: "shadow",
                        SpriteMaterial: "sprite"
                    },
                    f = ["precision", "isWebGL2", "supportsVertexTextures", "outputEncoding", "instancing", "instancingColor", "map", "mapEncoding", "matcap", "matcapEncoding", "envMap", "envMapMode", "envMapEncoding", "envMapCubeUV", "lightMap", "lightMapEncoding", "aoMap", "emissiveMap", "emissiveMapEncoding", "bumpMap", "normalMap", "objectSpaceNormalMap", "tangentSpaceNormalMap", "clearcoatMap", "clearcoatRoughnessMap", "clearcoatNormalMap", "displacementMap", "specularMap", "roughnessMap", "metalnessMap", "gradientMap", "alphaMap", "combine", "vertexColors", "vertexTangents", "vertexUvs", "uvsVertexOnly", "fog", "useFog", "fogExp2", "flatShading", "sizeAttenuation", "logarithmicDepthBuffer", "skinning", "maxBones", "useVertexTexture", "morphTargets", "morphNormals", "maxMorphTargets", "maxMorphNormals", "premultipliedAlpha", "numDirLights", "numPointLights", "numSpotLights", "numHemiLights", "numRectAreaLights", "numDirLightShadows", "numPointLightShadows", "numSpotLightShadows", "shadowMapEnabled", "shadowMapType", "toneMapping", "physicallyCorrectLights", "alphaTest", "doubleSided", "flipSided", "numClippingPlanes", "numClipIntersection", "depthPacking", "dithering", "sheen", "transmissionMap"];

                function m(t) {
                    let e;
                    return t && t.isTexture ? e = t.encoding : t && t.isWebGLRenderTarget ? (console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."), e = t.texture.encoding) : e = so, e
                }
                return {
                    getParameters: function(r, o, f, g, v) {
                        const y = g.fog,
                            x = r.isMeshStandardMaterial ? g.environment : null,
                            _ = e.get(r.envMap || x),
                            b = p[r.type],
                            w = v.isSkinnedMesh ? function(t) {
                                const e = t.skeleton.bones;
                                if (c) return 1024; {
                                    const t = u,
                                        n = Math.floor((t - 20) / 4),
                                        i = Math.min(n, e.length);
                                    return i < e.length ? (console.warn("THREE.WebGLRenderer: Skeleton has " + e.length + " bones. This GPU supports " + i + "."), 0) : i
                                }
                            }(v) : 0;
                        let M, S;
                        if (null !== r.precision && (d = i.getMaxPrecision(r.precision), d !== r.precision && console.warn("THREE.WebGLProgram.getParameters:", r.precision, "not supported, using", d, "instead.")), b) {
                            const t = oc[b];
                            M = t.vertexShader, S = t.fragmentShader
                        } else M = r.vertexShader, S = r.fragmentShader;
                        const E = t.getRenderTarget();
                        return {
                            isWebGL2: a,
                            shaderID: b,
                            shaderName: r.type,
                            vertexShader: M,
                            fragmentShader: S,
                            defines: r.defines,
                            isRawShaderMaterial: !0 === r.isRawShaderMaterial,
                            glslVersion: r.glslVersion,
                            precision: d,
                            instancing: !0 === v.isInstancedMesh,
                            instancingColor: !0 === v.isInstancedMesh && null !== v.instanceColor,
                            supportsVertexTextures: h,
                            outputEncoding: null !== E ? m(E.texture) : t.outputEncoding,
                            map: !!r.map,
                            mapEncoding: m(r.map),
                            matcap: !!r.matcap,
                            matcapEncoding: m(r.matcap),
                            envMap: !!_,
                            envMapMode: _ && _.mapping,
                            envMapEncoding: m(_),
                            envMapCubeUV: !!_ && (_.mapping === Ps || _.mapping === Fs),
                            lightMap: !!r.lightMap,
                            lightMapEncoding: m(r.lightMap),
                            aoMap: !!r.aoMap,
                            emissiveMap: !!r.emissiveMap,
                            emissiveMapEncoding: m(r.emissiveMap),
                            bumpMap: !!r.bumpMap,
                            normalMap: !!r.normalMap,
                            objectSpaceNormalMap: 1 === r.normalMapType,
                            tangentSpaceNormalMap: 0 === r.normalMapType,
                            clearcoatMap: !!r.clearcoatMap,
                            clearcoatRoughnessMap: !!r.clearcoatRoughnessMap,
                            clearcoatNormalMap: !!r.clearcoatNormalMap,
                            displacementMap: !!r.displacementMap,
                            roughnessMap: !!r.roughnessMap,
                            metalnessMap: !!r.metalnessMap,
                            specularMap: !!r.specularMap,
                            alphaMap: !!r.alphaMap,
                            gradientMap: !!r.gradientMap,
                            sheen: !!r.sheen,
                            transmissionMap: !!r.transmissionMap,
                            combine: r.combine,
                            vertexTangents: r.normalMap && r.vertexTangents,
                            vertexColors: r.vertexColors,
                            vertexUvs: !!(r.map || r.bumpMap || r.normalMap || r.specularMap || r.alphaMap || r.emissiveMap || r.roughnessMap || r.metalnessMap || r.clearcoatMap || r.clearcoatRoughnessMap || r.clearcoatNormalMap || r.displacementMap || r.transmissionMap),
                            uvsVertexOnly: !(r.map || r.bumpMap || r.normalMap || r.specularMap || r.alphaMap || r.emissiveMap || r.roughnessMap || r.metalnessMap || r.clearcoatNormalMap || r.transmissionMap || !r.displacementMap),
                            fog: !!y,
                            useFog: r.fog,
                            fogExp2: y && y.isFogExp2,
                            flatShading: !!r.flatShading,
                            sizeAttenuation: r.sizeAttenuation,
                            logarithmicDepthBuffer: l,
                            skinning: r.skinning && w > 0,
                            maxBones: w,
                            useVertexTexture: c,
                            morphTargets: r.morphTargets,
                            morphNormals: r.morphNormals,
                            maxMorphTargets: t.maxMorphTargets,
                            maxMorphNormals: t.maxMorphNormals,
                            numDirLights: o.directional.length,
                            numPointLights: o.point.length,
                            numSpotLights: o.spot.length,
                            numRectAreaLights: o.rectArea.length,
                            numHemiLights: o.hemi.length,
                            numDirLightShadows: o.directionalShadowMap.length,
                            numPointLightShadows: o.pointShadowMap.length,
                            numSpotLightShadows: o.spotShadowMap.length,
                            numClippingPlanes: s.numPlanes,
                            numClipIntersection: s.numIntersection,
                            dithering: r.dithering,
                            shadowMapEnabled: t.shadowMap.enabled && f.length > 0,
                            shadowMapType: t.shadowMap.type,
                            toneMapping: r.toneMapped ? t.toneMapping : 0,
                            physicallyCorrectLights: t.physicallyCorrectLights,
                            premultipliedAlpha: r.premultipliedAlpha,
                            alphaTest: r.alphaTest,
                            doubleSided: 2 === r.side,
                            flipSided: 1 === r.side,
                            depthPacking: void 0 !== r.depthPacking && r.depthPacking,
                            index0AttributeName: r.index0AttributeName,
                            extensionDerivatives: r.extensions && r.extensions.derivatives,
                            extensionFragDepth: r.extensions && r.extensions.fragDepth,
                            extensionDrawBuffers: r.extensions && r.extensions.drawBuffers,
                            extensionShaderTextureLOD: r.extensions && r.extensions.shaderTextureLOD,
                            rendererExtensionFragDepth: a || n.has("EXT_frag_depth"),
                            rendererExtensionDrawBuffers: a || n.has("WEBGL_draw_buffers"),
                            rendererExtensionShaderTextureLod: a || n.has("EXT_shader_texture_lod"),
                            customProgramCacheKey: r.customProgramCacheKey()
                        }
                    },
                    getProgramCacheKey: function(e) {
                        const n = [];
                        if (e.shaderID ? n.push(e.shaderID) : (n.push(e.fragmentShader), n.push(e.vertexShader)), void 0 !== e.defines)
                            for (const t in e.defines) n.push(t), n.push(e.defines[t]);
                        if (!1 === e.isRawShaderMaterial) {
                            for (let t = 0; t < f.length; t++) n.push(e[f[t]]);
                            n.push(t.outputEncoding), n.push(t.gammaFactor)
                        }
                        return n.push(e.customProgramCacheKey), n.join()
                    },
                    getUniforms: function(t) {
                        const e = p[t.type];
                        let n;
                        if (e) {
                            const t = oc[e];
                            n = Wl.clone(t.uniforms)
                        } else n = t.uniforms;
                        return n
                    },
                    acquireProgram: function(e, n) {
                        let i;
                        for (let t = 0, e = o.length; t < e; t++) {
                            const e = o[t];
                            if (e.cacheKey === n) {
                                i = e, ++i.usedTimes;
                                break
                            }
                        }
                        return void 0 === i && (i = new Bu(t, n, e, r), o.push(i)), i
                    },
                    releaseProgram: function(t) {
                        if (0 == --t.usedTimes) {
                            const e = o.indexOf(t);
                            o[e] = o[o.length - 1], o.pop(), t.destroy()
                        }
                    },
                    programs: o
                }
            }

            function ku() {
                let t = new WeakMap;
                return {
                    get: function(e) {
                        let n = t.get(e);
                        return void 0 === n && (n = {}, t.set(e, n)), n
                    },
                    remove: function(e) {
                        t.delete(e)
                    },
                    update: function(e, n, i) {
                        t.get(e)[n] = i
                    },
                    dispose: function() {
                        t = new WeakMap
                    }
                }
            }

            function Hu(t, e) {
                return t.groupOrder !== e.groupOrder ? t.groupOrder - e.groupOrder : t.renderOrder !== e.renderOrder ? t.renderOrder - e.renderOrder : t.program !== e.program ? t.program.id - e.program.id : t.material.id !== e.material.id ? t.material.id - e.material.id : t.z !== e.z ? t.z - e.z : t.id - e.id
            }

            function Uu(t, e) {
                return t.groupOrder !== e.groupOrder ? t.groupOrder - e.groupOrder : t.renderOrder !== e.renderOrder ? t.renderOrder - e.renderOrder : t.z !== e.z ? e.z - t.z : t.id - e.id
            }

            function Gu(t) {
                const e = [];
                let n = 0;
                const i = [],
                    r = [],
                    s = {
                        id: -1
                    };

                function o(i, r, o, a, l, c) {
                    let u = e[n];
                    const h = t.get(o);
                    return void 0 === u ? (u = {
                        id: i.id,
                        object: i,
                        geometry: r,
                        material: o,
                        program: h.program || s,
                        groupOrder: a,
                        renderOrder: i.renderOrder,
                        z: l,
                        group: c
                    }, e[n] = u) : (u.id = i.id, u.object = i, u.geometry = r, u.material = o, u.program = h.program || s, u.groupOrder = a, u.renderOrder = i.renderOrder, u.z = l, u.group = c), n++, u
                }
                return {
                    opaque: i,
                    transparent: r,
                    init: function() {
                        n = 0, i.length = 0, r.length = 0
                    },
                    push: function(t, e, n, s, a, l) {
                        const c = o(t, e, n, s, a, l);
                        (!0 === n.transparent ? r : i).push(c)
                    },
                    unshift: function(t, e, n, s, a, l) {
                        const c = o(t, e, n, s, a, l);
                        (!0 === n.transparent ? r : i).unshift(c)
                    },
                    finish: function() {
                        for (let t = n, i = e.length; t < i; t++) {
                            const n = e[t];
                            if (null === n.id) break;
                            n.id = null, n.object = null, n.geometry = null, n.material = null, n.program = null, n.group = null
                        }
                    },
                    sort: function(t, e) {
                        i.length > 1 && i.sort(t || Hu), r.length > 1 && r.sort(e || Uu)
                    }
                }
            }

            function Wu(t) {
                let e = new WeakMap;
                return {
                    get: function(n, i) {
                        let r;
                        return !1 === e.has(n) ? (r = new Gu(t), e.set(n, [r])) : i >= e.get(n).length ? (r = new Gu(t), e.get(n).push(r)) : r = e.get(n)[i], r
                    },
                    dispose: function() {
                        e = new WeakMap
                    }
                }
            }

            function Vu() {
                const t = {};
                return {
                    get: function(e) {
                        if (void 0 !== t[e.id]) return t[e.id];
                        let n;
                        switch (e.type) {
                            case "DirectionalLight":
                                n = {
                                    direction: new Ao,
                                    color: new Qa
                                };
                                break;
                            case "SpotLight":
                                n = {
                                    position: new Ao,
                                    direction: new Ao,
                                    color: new Qa,
                                    distance: 0,
                                    coneCos: 0,
                                    penumbraCos: 0,
                                    decay: 0
                                };
                                break;
                            case "PointLight":
                                n = {
                                    position: new Ao,
                                    color: new Qa,
                                    distance: 0,
                                    decay: 0
                                };
                                break;
                            case "HemisphereLight":
                                n = {
                                    direction: new Ao,
                                    skyColor: new Qa,
                                    groundColor: new Qa
                                };
                                break;
                            case "RectAreaLight":
                                n = {
                                    color: new Qa,
                                    position: new Ao,
                                    halfWidth: new Ao,
                                    halfHeight: new Ao
                                }
                        }
                        return t[e.id] = n, n
                    }
                }
            }
            let ju = 0;

            function qu(t, e) {
                return (e.castShadow ? 1 : 0) - (t.castShadow ? 1 : 0)
            }

            function Xu(t, e) {
                const n = new Vu,
                    i = function() {
                        const t = {};
                        return {
                            get: function(e) {
                                if (void 0 !== t[e.id]) return t[e.id];
                                let n;
                                switch (e.type) {
                                    case "DirectionalLight":
                                    case "SpotLight":
                                        n = {
                                            shadowBias: 0,
                                            shadowNormalBias: 0,
                                            shadowRadius: 1,
                                            shadowMapSize: new yo
                                        };
                                        break;
                                    case "PointLight":
                                        n = {
                                            shadowBias: 0,
                                            shadowNormalBias: 0,
                                            shadowRadius: 1,
                                            shadowMapSize: new yo,
                                            shadowCameraNear: 1,
                                            shadowCameraFar: 1e3
                                        }
                                }
                                return t[e.id] = n, n
                            }
                        }
                    }(),
                    r = {
                        version: 0,
                        hash: {
                            directionalLength: -1,
                            pointLength: -1,
                            spotLength: -1,
                            rectAreaLength: -1,
                            hemiLength: -1,
                            numDirectionalShadows: -1,
                            numPointShadows: -1,
                            numSpotShadows: -1
                        },
                        ambient: [0, 0, 0],
                        probe: [],
                        directional: [],
                        directionalShadow: [],
                        directionalShadowMap: [],
                        directionalShadowMatrix: [],
                        spot: [],
                        spotShadow: [],
                        spotShadowMap: [],
                        spotShadowMatrix: [],
                        rectArea: [],
                        rectAreaLTC1: null,
                        rectAreaLTC2: null,
                        point: [],
                        pointShadow: [],
                        pointShadowMap: [],
                        pointShadowMatrix: [],
                        hemi: []
                    };
                for (let t = 0; t < 9; t++) r.probe.push(new Ao);
                const s = new Ao,
                    o = new na,
                    a = new na;
                return {
                    setup: function(s) {
                        let o = 0,
                            a = 0,
                            l = 0;
                        for (let t = 0; t < 9; t++) r.probe[t].set(0, 0, 0);
                        let c = 0,
                            u = 0,
                            h = 0,
                            d = 0,
                            p = 0,
                            f = 0,
                            m = 0,
                            g = 0;
                        s.sort(qu);
                        for (let t = 0, e = s.length; t < e; t++) {
                            const e = s[t],
                                v = e.color,
                                y = e.intensity,
                                x = e.distance,
                                _ = e.shadow && e.shadow.map ? e.shadow.map.texture : null;
                            if (e.isAmbientLight) o += v.r * y, a += v.g * y, l += v.b * y;
                            else if (e.isLightProbe)
                                for (let t = 0; t < 9; t++) r.probe[t].addScaledVector(e.sh.coefficients[t], y);
                            else if (e.isDirectionalLight) {
                                const t = n.get(e);
                                if (t.color.copy(e.color).multiplyScalar(e.intensity), e.castShadow) {
                                    const t = e.shadow,
                                        n = i.get(e);
                                    n.shadowBias = t.bias, n.shadowNormalBias = t.normalBias, n.shadowRadius = t.radius, n.shadowMapSize = t.mapSize, r.directionalShadow[c] = n, r.directionalShadowMap[c] = _, r.directionalShadowMatrix[c] = e.shadow.matrix, f++
                                }
                                r.directional[c] = t, c++
                            } else if (e.isSpotLight) {
                                const t = n.get(e);
                                if (t.position.setFromMatrixPosition(e.matrixWorld), t.color.copy(v).multiplyScalar(y), t.distance = x, t.coneCos = Math.cos(e.angle), t.penumbraCos = Math.cos(e.angle * (1 - e.penumbra)), t.decay = e.decay, e.castShadow) {
                                    const t = e.shadow,
                                        n = i.get(e);
                                    n.shadowBias = t.bias, n.shadowNormalBias = t.normalBias, n.shadowRadius = t.radius, n.shadowMapSize = t.mapSize, r.spotShadow[h] = n, r.spotShadowMap[h] = _, r.spotShadowMatrix[h] = e.shadow.matrix, g++
                                }
                                r.spot[h] = t, h++
                            } else if (e.isRectAreaLight) {
                                const t = n.get(e);
                                t.color.copy(v).multiplyScalar(y), t.halfWidth.set(.5 * e.width, 0, 0), t.halfHeight.set(0, .5 * e.height, 0), r.rectArea[d] = t, d++
                            } else if (e.isPointLight) {
                                const t = n.get(e);
                                if (t.color.copy(e.color).multiplyScalar(e.intensity), t.distance = e.distance, t.decay = e.decay, e.castShadow) {
                                    const t = e.shadow,
                                        n = i.get(e);
                                    n.shadowBias = t.bias, n.shadowNormalBias = t.normalBias, n.shadowRadius = t.radius, n.shadowMapSize = t.mapSize, n.shadowCameraNear = t.camera.near, n.shadowCameraFar = t.camera.far, r.pointShadow[u] = n, r.pointShadowMap[u] = _, r.pointShadowMatrix[u] = e.shadow.matrix, m++
                                }
                                r.point[u] = t, u++
                            } else if (e.isHemisphereLight) {
                                const t = n.get(e);
                                t.skyColor.copy(e.color).multiplyScalar(y), t.groundColor.copy(e.groundColor).multiplyScalar(y), r.hemi[p] = t, p++
                            }
                        }
                        d > 0 && (e.isWebGL2 || !0 === t.has("OES_texture_float_linear") ? (r.rectAreaLTC1 = sc.LTC_FLOAT_1, r.rectAreaLTC2 = sc.LTC_FLOAT_2) : !0 === t.has("OES_texture_half_float_linear") ? (r.rectAreaLTC1 = sc.LTC_HALF_1, r.rectAreaLTC2 = sc.LTC_HALF_2) : console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")), r.ambient[0] = o, r.ambient[1] = a, r.ambient[2] = l;
                        const v = r.hash;
                        v.directionalLength === c && v.pointLength === u && v.spotLength === h && v.rectAreaLength === d && v.hemiLength === p && v.numDirectionalShadows === f && v.numPointShadows === m && v.numSpotShadows === g || (r.directional.length = c, r.spot.length = h, r.rectArea.length = d, r.point.length = u, r.hemi.length = p, r.directionalShadow.length = f, r.directionalShadowMap.length = f, r.pointShadow.length = m, r.pointShadowMap.length = m, r.spotShadow.length = g, r.spotShadowMap.length = g, r.directionalShadowMatrix.length = f, r.pointShadowMatrix.length = m, r.spotShadowMatrix.length = g, v.directionalLength = c, v.pointLength = u, v.spotLength = h, v.rectAreaLength = d, v.hemiLength = p, v.numDirectionalShadows = f, v.numPointShadows = m, v.numSpotShadows = g, r.version = ju++)
                    },
                    setupView: function(t, e) {
                        let n = 0,
                            i = 0,
                            l = 0,
                            c = 0,
                            u = 0;
                        const h = e.matrixWorldInverse;
                        for (let e = 0, d = t.length; e < d; e++) {
                            const d = t[e];
                            if (d.isDirectionalLight) {
                                const t = r.directional[n];
                                t.direction.setFromMatrixPosition(d.matrixWorld), s.setFromMatrixPosition(d.target.matrixWorld), t.direction.sub(s), t.direction.transformDirection(h), n++
                            } else if (d.isSpotLight) {
                                const t = r.spot[l];
                                t.position.setFromMatrixPosition(d.matrixWorld), t.position.applyMatrix4(h), t.direction.setFromMatrixPosition(d.matrixWorld), s.setFromMatrixPosition(d.target.matrixWorld), t.direction.sub(s), t.direction.transformDirection(h), l++
                            } else if (d.isRectAreaLight) {
                                const t = r.rectArea[c];
                                t.position.setFromMatrixPosition(d.matrixWorld), t.position.applyMatrix4(h), a.identity(), o.copy(d.matrixWorld), o.premultiply(h), a.extractRotation(o), t.halfWidth.set(.5 * d.width, 0, 0), t.halfHeight.set(0, .5 * d.height, 0), t.halfWidth.applyMatrix4(a), t.halfHeight.applyMatrix4(a), c++
                            } else if (d.isPointLight) {
                                const t = r.point[i];
                                t.position.setFromMatrixPosition(d.matrixWorld), t.position.applyMatrix4(h), i++
                            } else if (d.isHemisphereLight) {
                                const t = r.hemi[u];
                                t.direction.setFromMatrixPosition(d.matrixWorld), t.direction.transformDirection(h), t.direction.normalize(), u++
                            }
                        }
                    },
                    state: r
                }
            }

            function Yu(t, e) {
                const n = new Xu(t, e),
                    i = [],
                    r = [];
                return {
                    init: function() {
                        i.length = 0, r.length = 0
                    },
                    state: {
                        lightsArray: i,
                        shadowsArray: r,
                        lights: n
                    },
                    setupLights: function() {
                        n.setup(i)
                    },
                    setupLightsView: function(t) {
                        n.setupView(i, t)
                    },
                    pushLight: function(t) {
                        i.push(t)
                    },
                    pushShadow: function(t) {
                        r.push(t)
                    }
                }
            }

            function Zu(t, e) {
                let n = new WeakMap;
                return {
                    get: function(i, r = 0) {
                        let s;
                        return !1 === n.has(i) ? (s = new Yu(t, e), n.set(i, [s])) : r >= n.get(i).length ? (s = new Yu(t, e), n.get(i).push(s)) : s = n.get(i)[r], s
                    },
                    dispose: function() {
                        n = new WeakMap
                    }
                }
            }
            class Ju extends Va {
                constructor(t) {
                    super(), this.type = "MeshDepthMaterial", this.depthPacking = 3200, this.skinning = !1, this.morphTargets = !1, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.setValues(t)
                }
                copy(t) {
                    return super.copy(t), this.depthPacking = t.depthPacking, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.map = t.map, this.alphaMap = t.alphaMap, this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this
                }
            }
            Ju.prototype.isMeshDepthMaterial = !0;
            class Qu extends Va {
                constructor(t) {
                    super(), this.type = "MeshDistanceMaterial", this.referencePosition = new Ao, this.nearDistance = 1, this.farDistance = 1e3, this.skinning = !1, this.morphTargets = !1, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.fog = !1, this.setValues(t)
                }
                copy(t) {
                    return super.copy(t), this.referencePosition.copy(t.referencePosition), this.nearDistance = t.nearDistance, this.farDistance = t.farDistance, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.map = t.map, this.alphaMap = t.alphaMap, this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this
                }
            }
            Qu.prototype.isMeshDistanceMaterial = !0;

            function Ku(t, e, n) {
                let i = new tc;
                const r = new yo,
                    s = new yo,
                    o = new Eo,
                    a = [],
                    l = [],
                    c = {},
                    u = {
                        0: 1,
                        1: 0,
                        2: 2
                    },
                    h = new Vl({
                        defines: {
                            SAMPLE_RATE: 2 / 8,
                            HALF_SAMPLE_RATE: 1 / 8
                        },
                        uniforms: {
                            shadow_pass: {
                                value: null
                            },
                            resolution: {
                                value: new yo
                            },
                            radius: {
                                value: 4
                            }
                        },
                        vertexShader: "void main() {\n\tgl_Position = vec4( position, 1.0 );\n}",
                        fragmentShader: "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n\tfloat mean = 0.0;\n\tfloat squared_mean = 0.0;\n\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy ) / resolution ) );\n\tfor ( float i = -1.0; i < 1.0 ; i += SAMPLE_RATE) {\n\t\t#ifdef HORIZONTAL_PASS\n\t\t\tvec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( i, 0.0 ) * radius ) / resolution ) );\n\t\t\tmean += distribution.x;\n\t\t\tsquared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n\t\t#else\n\t\t\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, i ) * radius ) / resolution ) );\n\t\t\tmean += depth;\n\t\t\tsquared_mean += depth * depth;\n\t\t#endif\n\t}\n\tmean = mean * HALF_SAMPLE_RATE;\n\tsquared_mean = squared_mean * HALF_SAMPLE_RATE;\n\tfloat std_dev = sqrt( squared_mean - mean * mean );\n\tgl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}"
                    }),
                    d = h.clone();
                d.defines.HORIZONTAL_PASS = 1;
                const p = new _l;
                p.setAttribute("position", new el(new Float32Array([-1, -1, .5, 3, -1, .5, -1, 3, .5]), 3));
                const f = new zl(p, h),
                    m = this;

                function g(n, i) {
                    const r = e.update(f);
                    h.uniforms.shadow_pass.value = n.map.texture, h.uniforms.resolution.value = n.mapSize, h.uniforms.radius.value = n.radius, t.setRenderTarget(n.mapPass), t.clear(), t.renderBufferDirect(i, null, r, h, f, null), d.uniforms.shadow_pass.value = n.mapPass.texture, d.uniforms.resolution.value = n.mapSize, d.uniforms.radius.value = n.radius, t.setRenderTarget(n.map), t.clear(), t.renderBufferDirect(i, null, r, d, f, null)
                }

                function v(t, e, n) {
                    const i = t << 0 | e << 1 | n << 2;
                    let r = a[i];
                    return void 0 === r && (r = new Ju({
                        depthPacking: 3201,
                        morphTargets: t,
                        skinning: e
                    }), a[i] = r), r
                }

                function y(t, e, n) {
                    const i = t << 0 | e << 1 | n << 2;
                    let r = l[i];
                    return void 0 === r && (r = new Qu({
                        morphTargets: t,
                        skinning: e
                    }), l[i] = r), r
                }

                function x(e, n, i, r, s, o, a) {
                    let l = null,
                        h = v,
                        d = e.customDepthMaterial;
                    if (!0 === r.isPointLight && (h = y, d = e.customDistanceMaterial), void 0 === d) {
                        let t = !1;
                        !0 === i.morphTargets && (t = n.morphAttributes && n.morphAttributes.position && n.morphAttributes.position.length > 0);
                        let r = !1;
                        !0 === e.isSkinnedMesh && (!0 === i.skinning ? r = !0 : console.warn("THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:", e));
                        l = h(t, r, !0 === e.isInstancedMesh)
                    } else l = d;
                    if (t.localClippingEnabled && !0 === i.clipShadows && 0 !== i.clippingPlanes.length) {
                        const t = l.uuid,
                            e = i.uuid;
                        let n = c[t];
                        void 0 === n && (n = {}, c[t] = n);
                        let r = n[e];
                        void 0 === r && (r = l.clone(), n[e] = r), l = r
                    }
                    return l.visible = i.visible, l.wireframe = i.wireframe, l.side = 3 === a ? null !== i.shadowSide ? i.shadowSide : i.side : null !== i.shadowSide ? i.shadowSide : u[i.side], l.clipShadows = i.clipShadows, l.clippingPlanes = i.clippingPlanes, l.clipIntersection = i.clipIntersection, l.wireframeLinewidth = i.wireframeLinewidth, l.linewidth = i.linewidth, !0 === r.isPointLight && !0 === l.isMeshDistanceMaterial && (l.referencePosition.setFromMatrixPosition(r.matrixWorld), l.nearDistance = s, l.farDistance = o), l
                }

                function _(n, r, s, o, a) {
                    if (!1 === n.visible) return;
                    if (n.layers.test(r.layers) && (n.isMesh || n.isLine || n.isPoints) && (n.castShadow || n.receiveShadow && 3 === a) && (!n.frustumCulled || i.intersectsObject(n))) {
                        n.modelViewMatrix.multiplyMatrices(s.matrixWorldInverse, n.matrixWorld);
                        const i = e.update(n),
                            r = n.material;
                        if (Array.isArray(r)) {
                            const e = i.groups;
                            for (let l = 0, c = e.length; l < c; l++) {
                                const c = e[l],
                                    u = r[c.materialIndex];
                                if (u && u.visible) {
                                    const e = x(n, i, u, o, s.near, s.far, a);
                                    t.renderBufferDirect(s, null, i, e, n, c)
                                }
                            }
                        } else if (r.visible) {
                            const e = x(n, i, r, o, s.near, s.far, a);
                            t.renderBufferDirect(s, null, i, e, n, null)
                        }
                    }
                    const l = n.children;
                    for (let t = 0, e = l.length; t < e; t++) _(l[t], r, s, o, a)
                }
                this.enabled = !1, this.autoUpdate = !0, this.needsUpdate = !1, this.type = 1, this.render = function(e, a, l) {
                    if (!1 === m.enabled) return;
                    if (!1 === m.autoUpdate && !1 === m.needsUpdate) return;
                    if (0 === e.length) return;
                    const c = t.getRenderTarget(),
                        u = t.getActiveCubeFace(),
                        h = t.getActiveMipmapLevel(),
                        d = t.state;
                    d.setBlending(0), d.buffers.color.setClear(1, 1, 1, 1), d.buffers.depth.setTest(!0), d.setScissorTest(!1);
                    for (let c = 0, u = e.length; c < u; c++) {
                        const u = e[c],
                            h = u.shadow;
                        if (void 0 === h) {
                            console.warn("THREE.WebGLShadowMap:", u, "has no shadow.");
                            continue
                        }
                        if (!1 === h.autoUpdate && !1 === h.needsUpdate) continue;
                        r.copy(h.mapSize);
                        const p = h.getFrameExtents();
                        if (r.multiply(p), s.copy(h.mapSize), (r.x > n || r.y > n) && (r.x > n && (s.x = Math.floor(n / p.x), r.x = s.x * p.x, h.mapSize.x = s.x), r.y > n && (s.y = Math.floor(n / p.y), r.y = s.y * p.y, h.mapSize.y = s.y)), null === h.map && !h.isPointLightShadow && 3 === this.type) {
                            const t = {
                                minFilter: Hs,
                                magFilter: Hs,
                                format: Zs
                            };
                            h.map = new Do(r.x, r.y, t), h.map.texture.name = u.name + ".shadowMap", h.mapPass = new Do(r.x, r.y, t), h.camera.updateProjectionMatrix()
                        }
                        if (null === h.map) {
                            const t = {
                                minFilter: Bs,
                                magFilter: Bs,
                                format: Zs
                            };
                            h.map = new Do(r.x, r.y, t), h.map.texture.name = u.name + ".shadowMap", h.camera.updateProjectionMatrix()
                        }
                        t.setRenderTarget(h.map), t.clear();
                        const f = h.getViewportCount();
                        for (let t = 0; t < f; t++) {
                            const e = h.getViewport(t);
                            o.set(s.x * e.x, s.y * e.y, s.x * e.z, s.y * e.w), d.viewport(o), h.updateMatrices(u, t), i = h.getFrustum(), _(a, l, h.camera, u, this.type)
                        }
                        h.isPointLightShadow || 3 !== this.type || g(h, l), h.needsUpdate = !1
                    }
                    m.needsUpdate = !1, t.setRenderTarget(c, u, h)
                }
            }

            function $u(t, e, n) {
                const i = n.isWebGL2;
                const r = new function() {
                        let e = !1;
                        const n = new Eo;
                        let i = null;
                        const r = new Eo(0, 0, 0, 0);
                        return {
                            setMask: function(n) {
                                i === n || e || (t.colorMask(n, n, n, n), i = n)
                            },
                            setLocked: function(t) {
                                e = t
                            },
                            setClear: function(e, i, s, o, a) {
                                !0 === a && (e *= o, i *= o, s *= o), n.set(e, i, s, o), !1 === r.equals(n) && (t.clearColor(e, i, s, o), r.copy(n))
                            },
                            reset: function() {
                                e = !1, i = null, r.set(-1, 0, 0, 0)
                            }
                        }
                    },
                    s = new function() {
                        let e = !1,
                            n = null,
                            i = null,
                            r = null;
                        return {
                            setTest: function(t) {
                                t ? F(2929) : O(2929)
                            },
                            setMask: function(i) {
                                n === i || e || (t.depthMask(i), n = i)
                            },
                            setFunc: function(e) {
                                if (i !== e) {
                                    if (e) switch (e) {
                                        case 0:
                                            t.depthFunc(512);
                                            break;
                                        case 1:
                                            t.depthFunc(519);
                                            break;
                                        case 2:
                                            t.depthFunc(513);
                                            break;
                                        case 3:
                                            t.depthFunc(515);
                                            break;
                                        case 4:
                                            t.depthFunc(514);
                                            break;
                                        case 5:
                                            t.depthFunc(518);
                                            break;
                                        case 6:
                                            t.depthFunc(516);
                                            break;
                                        case 7:
                                            t.depthFunc(517);
                                            break;
                                        default:
                                            t.depthFunc(515)
                                    } else t.depthFunc(515);
                                    i = e
                                }
                            },
                            setLocked: function(t) {
                                e = t
                            },
                            setClear: function(e) {
                                r !== e && (t.clearDepth(e), r = e)
                            },
                            reset: function() {
                                e = !1, n = null, i = null, r = null
                            }
                        }
                    },
                    o = new function() {
                        let e = !1,
                            n = null,
                            i = null,
                            r = null,
                            s = null,
                            o = null,
                            a = null,
                            l = null,
                            c = null;
                        return {
                            setTest: function(t) {
                                e || (t ? F(2960) : O(2960))
                            },
                            setMask: function(i) {
                                n === i || e || (t.stencilMask(i), n = i)
                            },
                            setFunc: function(e, n, o) {
                                i === e && r === n && s === o || (t.stencilFunc(e, n, o), i = e, r = n, s = o)
                            },
                            setOp: function(e, n, i) {
                                o === e && a === n && l === i || (t.stencilOp(e, n, i), o = e, a = n, l = i)
                            },
                            setLocked: function(t) {
                                e = t
                            },
                            setClear: function(e) {
                                c !== e && (t.clearStencil(e), c = e)
                            },
                            reset: function() {
                                e = !1, n = null, i = null, r = null, s = null, o = null, a = null, l = null, c = null
                            }
                        }
                    };
                let a = {},
                    l = null,
                    c = !1,
                    u = null,
                    h = null,
                    d = null,
                    p = null,
                    f = null,
                    m = null,
                    g = null,
                    v = !1,
                    y = null,
                    x = null,
                    _ = null,
                    b = null,
                    w = null;
                const M = t.getParameter(35661);
                let S = !1,
                    E = 0;
                const D = t.getParameter(7938); - 1 !== D.indexOf("WebGL") ? (E = parseFloat(/^WebGL (\d)/.exec(D)[1]), S = E >= 1) : -1 !== D.indexOf("OpenGL ES") && (E = parseFloat(/^OpenGL ES (\d)/.exec(D)[1]), S = E >= 2);
                let T = null,
                    A = {};
                const C = new Eo,
                    L = new Eo;

                function R(e, n, i) {
                    const r = new Uint8Array(4),
                        s = t.createTexture();
                    t.bindTexture(e, s), t.texParameteri(e, 10241, 9728), t.texParameteri(e, 10240, 9728);
                    for (let e = 0; e < i; e++) t.texImage2D(n + e, 0, 6408, 1, 1, 0, 6408, 5121, r);
                    return s
                }
                const P = {};

                function F(e) {
                    !0 !== a[e] && (t.enable(e), a[e] = !0)
                }

                function O(e) {
                    !1 !== a[e] && (t.disable(e), a[e] = !1)
                }
                P[3553] = R(3553, 3553, 1), P[34067] = R(34067, 34069, 6), r.setClear(0, 0, 0, 1), s.setClear(1), o.setClear(0), F(2929), s.setFunc(3), z(!1), k(1), F(2884), B(0);
                const I = {
                    [Cs]: 32774,
                    101: 32778,
                    102: 32779
                };
                if (i) I[103] = 32775, I[104] = 32776;
                else {
                    const t = e.get("EXT_blend_minmax");
                    null !== t && (I[103] = t.MIN_EXT, I[104] = t.MAX_EXT)
                }
                const N = {
                    200: 0,
                    201: 1,
                    202: 768,
                    204: 770,
                    210: 776,
                    208: 774,
                    206: 772,
                    203: 769,
                    205: 771,
                    209: 775,
                    207: 773
                };

                function B(e, n, i, r, s, o, a, l) {
                    if (0 !== e) {
                        if (!1 === c && (F(3042), c = !0), 5 === e) s = s || n, o = o || i, a = a || r, n === h && s === f || (t.blendEquationSeparate(I[n], I[s]), h = n, f = s), i === d && r === p && o === m && a === g || (t.blendFuncSeparate(N[i], N[r], N[o], N[a]), d = i, p = r, m = o, g = a), u = e, v = null;
                        else if (e !== u || l !== v) {
                            if (h === Cs && f === Cs || (t.blendEquation(32774), h = Cs, f = Cs), l) switch (e) {
                                case 1:
                                    t.blendFuncSeparate(1, 771, 1, 771);
                                    break;
                                case 2:
                                    t.blendFunc(1, 1);
                                    break;
                                case 3:
                                    t.blendFuncSeparate(0, 0, 769, 771);
                                    break;
                                case 4:
                                    t.blendFuncSeparate(0, 768, 0, 770);
                                    break;
                                default:
                                    console.error("THREE.WebGLState: Invalid blending: ", e)
                            } else switch (e) {
                                case 1:
                                    t.blendFuncSeparate(770, 771, 1, 771);
                                    break;
                                case 2:
                                    t.blendFunc(770, 1);
                                    break;
                                case 3:
                                    t.blendFunc(0, 769);
                                    break;
                                case 4:
                                    t.blendFunc(0, 768);
                                    break;
                                default:
                                    console.error("THREE.WebGLState: Invalid blending: ", e)
                            }
                            d = null, p = null, m = null, g = null, u = e, v = l
                        }
                    } else !0 === c && (O(3042), c = !1)
                }

                function z(e) {
                    y !== e && (e ? t.frontFace(2304) : t.frontFace(2305), y = e)
                }

                function k(e) {
                    0 !== e ? (F(2884), e !== x && (1 === e ? t.cullFace(1029) : 2 === e ? t.cullFace(1028) : t.cullFace(1032))) : O(2884), x = e
                }

                function H(e, n, i) {
                    e ? (F(32823), b === n && w === i || (t.polygonOffset(n, i), b = n, w = i)) : O(32823)
                }

                function U(e) {
                    void 0 === e && (e = 33984 + M - 1), T !== e && (t.activeTexture(e), T = e)
                }
                return {
                    buffers: {
                        color: r,
                        depth: s,
                        stencil: o
                    },
                    enable: F,
                    disable: O,
                    useProgram: function(e) {
                        return l !== e && (t.useProgram(e), l = e, !0)
                    },
                    setBlending: B,
                    setMaterial: function(t, e) {
                        2 === t.side ? O(2884) : F(2884);
                        let n = 1 === t.side;
                        e && (n = !n), z(n), 1 === t.blending && !1 === t.transparent ? B(0) : B(t.blending, t.blendEquation, t.blendSrc, t.blendDst, t.blendEquationAlpha, t.blendSrcAlpha, t.blendDstAlpha, t.premultipliedAlpha), s.setFunc(t.depthFunc), s.setTest(t.depthTest), s.setMask(t.depthWrite), r.setMask(t.colorWrite);
                        const i = t.stencilWrite;
                        o.setTest(i), i && (o.setMask(t.stencilWriteMask), o.setFunc(t.stencilFunc, t.stencilRef, t.stencilFuncMask), o.setOp(t.stencilFail, t.stencilZFail, t.stencilZPass)), H(t.polygonOffset, t.polygonOffsetFactor, t.polygonOffsetUnits)
                    },
                    setFlipSided: z,
                    setCullFace: k,
                    setLineWidth: function(e) {
                        e !== _ && (S && t.lineWidth(e), _ = e)
                    },
                    setPolygonOffset: H,
                    setScissorTest: function(t) {
                        t ? F(3089) : O(3089)
                    },
                    activeTexture: U,
                    bindTexture: function(e, n) {
                        null === T && U();
                        let i = A[T];
                        void 0 === i && (i = {
                            type: void 0,
                            texture: void 0
                        }, A[T] = i), i.type === e && i.texture === n || (t.bindTexture(e, n || P[e]), i.type = e, i.texture = n)
                    },
                    unbindTexture: function() {
                        const e = A[T];
                        void 0 !== e && void 0 !== e.type && (t.bindTexture(e.type, null), e.type = void 0, e.texture = void 0)
                    },
                    compressedTexImage2D: function() {
                        try {
                            t.compressedTexImage2D.apply(t, arguments)
                        } catch (t) {
                            console.error("THREE.WebGLState:", t)
                        }
                    },
                    texImage2D: function() {
                        try {
                            t.texImage2D.apply(t, arguments)
                        } catch (t) {
                            console.error("THREE.WebGLState:", t)
                        }
                    },
                    texImage3D: function() {
                        try {
                            t.texImage3D.apply(t, arguments)
                        } catch (t) {
                            console.error("THREE.WebGLState:", t)
                        }
                    },
                    scissor: function(e) {
                        !1 === C.equals(e) && (t.scissor(e.x, e.y, e.z, e.w), C.copy(e))
                    },
                    viewport: function(e) {
                        !1 === L.equals(e) && (t.viewport(e.x, e.y, e.z, e.w), L.copy(e))
                    },
                    reset: function() {
                        t.disable(3042), t.disable(2884), t.disable(2929), t.disable(32823), t.disable(3089), t.disable(2960), t.blendEquation(32774), t.blendFunc(1, 0), t.blendFuncSeparate(1, 0, 1, 0), t.colorMask(!0, !0, !0, !0), t.clearColor(0, 0, 0, 0), t.depthMask(!0), t.depthFunc(513), t.clearDepth(1), t.stencilMask(4294967295), t.stencilFunc(519, 0, 4294967295), t.stencilOp(7680, 7680, 7680), t.clearStencil(0), t.cullFace(1029), t.frontFace(2305), t.polygonOffset(0, 0), t.activeTexture(33984), t.useProgram(null), t.lineWidth(1), t.scissor(0, 0, t.canvas.width, t.canvas.height), t.viewport(0, 0, t.canvas.width, t.canvas.height), a = {}, T = null, A = {}, l = null, c = !1, u = null, h = null, d = null, p = null, f = null, m = null, g = null, v = !1, y = null, x = null, _ = null, b = null, w = null, r.reset(), s.reset(), o.reset()
                    }
                }
            }

            function th(t, e, n, i, r, s, o) {
                const a = r.isWebGL2,
                    l = r.maxTextures,
                    c = r.maxCubemapSize,
                    u = r.maxTextureSize,
                    h = r.maxSamples,
                    d = new WeakMap;
                let p, f = !1;
                try {
                    f = "undefined" != typeof OffscreenCanvas && null !== new OffscreenCanvas(1, 1).getContext("2d")
                } catch (t) {}

                function m(t, e) {
                    return f ? new OffscreenCanvas(t, e) : document.createElementNS("http://www.w3.org/1999/xhtml", "canvas")
                }

                function g(t, e, n, i) {
                    let r = 1;
                    if ((t.width > i || t.height > i) && (r = i / Math.max(t.width, t.height)), r < 1 || !0 === e) {
                        if ("undefined" != typeof HTMLImageElement && t instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && t instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && t instanceof ImageBitmap) {
                            const i = e ? vo.floorPowerOfTwo : Math.floor,
                                s = i(r * t.width),
                                o = i(r * t.height);
                            void 0 === p && (p = m(s, o));
                            const a = n ? m(s, o) : p;
                            a.width = s, a.height = o;
                            return a.getContext("2d").drawImage(t, 0, 0, s, o), console.warn("THREE.WebGLRenderer: Texture has been resized from (" + t.width + "x" + t.height + ") to (" + s + "x" + o + ")."), a
                        }
                        return "data" in t && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + t.width + "x" + t.height + ")."), t
                    }
                    return t
                }

                function v(t) {
                    return vo.isPowerOfTwo(t.width) && vo.isPowerOfTwo(t.height)
                }

                function y(t, e) {
                    return t.generateMipmaps && e && t.minFilter !== Bs && t.minFilter !== Hs
                }

                function x(e, n, r, s) {
                    t.generateMipmap(e);
                    i.get(n).__maxMipLevel = Math.log2(Math.max(r, s))
                }

                function _(n, i, r) {
                    if (!1 === a) return i;
                    if (null !== n) {
                        if (void 0 !== t[n]) return t[n];
                        console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + n + "'")
                    }
                    let s = i;
                    return 6403 === i && (5126 === r && (s = 33326), 5131 === r && (s = 33325), 5121 === r && (s = 33321)), 6407 === i && (5126 === r && (s = 34837), 5131 === r && (s = 34843), 5121 === r && (s = 32849)), 6408 === i && (5126 === r && (s = 34836), 5131 === r && (s = 34842), 5121 === r && (s = 32856)), 33325 !== s && 33326 !== s && 34842 !== s && 34836 !== s || e.get("EXT_color_buffer_float"), s
                }

                function b(t) {
                    return t === Bs || t === zs || t === ks ? 9728 : 9729
                }

                function w(e) {
                    const n = e.target;
                    n.removeEventListener("dispose", w),
                        function(e) {
                            const n = i.get(e);
                            if (void 0 === n.__webglInit) return;
                            t.deleteTexture(n.__webglTexture), i.remove(e)
                        }(n), n.isVideoTexture && d.delete(n), o.memory.textures--
                }

                function M(e) {
                    const n = e.target;
                    n.removeEventListener("dispose", M),
                        function(e) {
                            const n = e.texture,
                                r = i.get(e),
                                s = i.get(n);
                            if (!e) return;
                            void 0 !== s.__webglTexture && t.deleteTexture(s.__webglTexture);
                            e.depthTexture && e.depthTexture.dispose();
                            if (e.isWebGLCubeRenderTarget)
                                for (let e = 0; e < 6; e++) t.deleteFramebuffer(r.__webglFramebuffer[e]), r.__webglDepthbuffer && t.deleteRenderbuffer(r.__webglDepthbuffer[e]);
                            else t.deleteFramebuffer(r.__webglFramebuffer), r.__webglDepthbuffer && t.deleteRenderbuffer(r.__webglDepthbuffer), r.__webglMultisampledFramebuffer && t.deleteFramebuffer(r.__webglMultisampledFramebuffer), r.__webglColorRenderbuffer && t.deleteRenderbuffer(r.__webglColorRenderbuffer), r.__webglDepthRenderbuffer && t.deleteRenderbuffer(r.__webglDepthRenderbuffer);
                            i.remove(n), i.remove(e)
                        }(n), o.memory.textures--
                }
                let S = 0;

                function E(t, e) {
                    const r = i.get(t);
                    if (t.isVideoTexture && function(t) {
                            const e = o.render.frame;
                            d.get(t) !== e && (d.set(t, e), t.update())
                        }(t), t.version > 0 && r.__version !== t.version) {
                        const n = t.image;
                        if (void 0 === n) console.warn("THREE.WebGLRenderer: Texture marked for update but image is undefined");
                        else {
                            if (!1 !== n.complete) return void R(r, t, e);
                            console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete")
                        }
                    }
                    n.activeTexture(33984 + e), n.bindTexture(3553, r.__webglTexture)
                }

                function D(e, r) {
                    const o = i.get(e);
                    e.version > 0 && o.__version !== e.version ? function(e, i, r) {
                        if (6 !== i.image.length) return;
                        L(e, i), n.activeTexture(33984 + r), n.bindTexture(34067, e.__webglTexture), t.pixelStorei(37440, i.flipY), t.pixelStorei(37441, i.premultiplyAlpha), t.pixelStorei(3317, i.unpackAlignment), t.pixelStorei(37443, 0);
                        const o = i && (i.isCompressedTexture || i.image[0].isCompressedTexture),
                            l = i.image[0] && i.image[0].isDataTexture,
                            u = [];
                        for (let t = 0; t < 6; t++) u[t] = o || l ? l ? i.image[t].image : i.image[t] : g(i.image[t], !1, !0, c);
                        const h = u[0],
                            d = v(h) || a,
                            p = s.convert(i.format),
                            f = s.convert(i.type),
                            m = _(i.internalFormat, p, f);
                        let b;
                        if (C(34067, i, d), o) {
                            for (let t = 0; t < 6; t++) {
                                b = u[t].mipmaps;
                                for (let e = 0; e < b.length; e++) {
                                    const r = b[e];
                                    i.format !== Zs && i.format !== Ys ? null !== p ? n.compressedTexImage2D(34069 + t, e, m, r.width, r.height, 0, r.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : n.texImage2D(34069 + t, e, m, r.width, r.height, 0, p, f, r.data)
                                }
                            }
                            e.__maxMipLevel = b.length - 1
                        } else {
                            b = i.mipmaps;
                            for (let t = 0; t < 6; t++)
                                if (l) {
                                    n.texImage2D(34069 + t, 0, m, u[t].width, u[t].height, 0, p, f, u[t].data);
                                    for (let e = 0; e < b.length; e++) {
                                        const i = b[e].image[t].image;
                                        n.texImage2D(34069 + t, e + 1, m, i.width, i.height, 0, p, f, i.data)
                                    }
                                } else {
                                    n.texImage2D(34069 + t, 0, m, p, f, u[t]);
                                    for (let e = 0; e < b.length; e++) {
                                        const i = b[e];
                                        n.texImage2D(34069 + t, e + 1, m, p, f, i.image[t])
                                    }
                                }
                            e.__maxMipLevel = b.length
                        }
                        y(i, d) && x(34067, i, h.width, h.height);
                        e.__version = i.version, i.onUpdate && i.onUpdate(i)
                    }(o, e, r) : (n.activeTexture(33984 + r), n.bindTexture(34067, o.__webglTexture))
                }
                const T = {
                        [Os]: 10497,
                        [Is]: 33071,
                        [Ns]: 33648
                    },
                    A = {
                        [Bs]: 9728,
                        [zs]: 9984,
                        [ks]: 9986,
                        [Hs]: 9729,
                        1007: 9985,
                        [Us]: 9987
                    };

                function C(n, s, o) {
                    if (o ? (t.texParameteri(n, 10242, T[s.wrapS]), t.texParameteri(n, 10243, T[s.wrapT]), 32879 !== n && 35866 !== n || t.texParameteri(n, 32882, T[s.wrapR]), t.texParameteri(n, 10240, A[s.magFilter]), t.texParameteri(n, 10241, A[s.minFilter])) : (t.texParameteri(n, 10242, 33071), t.texParameteri(n, 10243, 33071), 32879 !== n && 35866 !== n || t.texParameteri(n, 32882, 33071), s.wrapS === Is && s.wrapT === Is || console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."), t.texParameteri(n, 10240, b(s.magFilter)), t.texParameteri(n, 10241, b(s.minFilter)), s.minFilter !== Bs && s.minFilter !== Hs && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")), !0 === e.has("EXT_texture_filter_anisotropic")) {
                        const o = e.get("EXT_texture_filter_anisotropic");
                        if (s.type === js && !1 === e.has("OES_texture_float_linear")) return;
                        if (!1 === a && s.type === qs && !1 === e.has("OES_texture_half_float_linear")) return;
                        (s.anisotropy > 1 || i.get(s).__currentAnisotropy) && (t.texParameterf(n, o.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(s.anisotropy, r.getMaxAnisotropy())), i.get(s).__currentAnisotropy = s.anisotropy)
                    }
                }

                function L(e, n) {
                    void 0 === e.__webglInit && (e.__webglInit = !0, n.addEventListener("dispose", w), e.__webglTexture = t.createTexture(), o.memory.textures++)
                }

                function R(e, i, r) {
                    let o = 3553;
                    i.isDataTexture2DArray && (o = 35866), i.isDataTexture3D && (o = 32879), L(e, i), n.activeTexture(33984 + r), n.bindTexture(o, e.__webglTexture), t.pixelStorei(37440, i.flipY), t.pixelStorei(37441, i.premultiplyAlpha), t.pixelStorei(3317, i.unpackAlignment), t.pixelStorei(37443, 0);
                    const l = function(t) {
                            return !a && (t.wrapS !== Is || t.wrapT !== Is || t.minFilter !== Bs && t.minFilter !== Hs)
                        }(i) && !1 === v(i.image),
                        c = g(i.image, l, !1, u),
                        h = v(c) || a,
                        d = s.convert(i.format);
                    let p, f = s.convert(i.type),
                        m = _(i.internalFormat, d, f);
                    C(o, i, h);
                    const b = i.mipmaps;
                    if (i.isDepthTexture) m = 6402, a ? m = i.type === js ? 36012 : i.type === Vs ? 33190 : i.type === Xs ? 35056 : 33189 : i.type === js && console.error("WebGLRenderer: Floating point depth texture requires WebGL2."), i.format === Js && 6402 === m && i.type !== Ws && i.type !== Vs && (console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."), i.type = Ws, f = s.convert(i.type)), i.format === Qs && 6402 === m && (m = 34041, i.type !== Xs && (console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."), i.type = Xs, f = s.convert(i.type))), n.texImage2D(3553, 0, m, c.width, c.height, 0, d, f, null);
                    else if (i.isDataTexture)
                        if (b.length > 0 && h) {
                            for (let t = 0, e = b.length; t < e; t++) p = b[t], n.texImage2D(3553, t, m, p.width, p.height, 0, d, f, p.data);
                            i.generateMipmaps = !1, e.__maxMipLevel = b.length - 1
                        } else n.texImage2D(3553, 0, m, c.width, c.height, 0, d, f, c.data), e.__maxMipLevel = 0;
                    else if (i.isCompressedTexture) {
                        for (let t = 0, e = b.length; t < e; t++) p = b[t], i.format !== Zs && i.format !== Ys ? null !== d ? n.compressedTexImage2D(3553, t, m, p.width, p.height, 0, p.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : n.texImage2D(3553, t, m, p.width, p.height, 0, d, f, p.data);
                        e.__maxMipLevel = b.length - 1
                    } else if (i.isDataTexture2DArray) n.texImage3D(35866, 0, m, c.width, c.height, c.depth, 0, d, f, c.data), e.__maxMipLevel = 0;
                    else if (i.isDataTexture3D) n.texImage3D(32879, 0, m, c.width, c.height, c.depth, 0, d, f, c.data), e.__maxMipLevel = 0;
                    else if (b.length > 0 && h) {
                        for (let t = 0, e = b.length; t < e; t++) p = b[t], n.texImage2D(3553, t, m, d, f, p);
                        i.generateMipmaps = !1, e.__maxMipLevel = b.length - 1
                    } else n.texImage2D(3553, 0, m, d, f, c), e.__maxMipLevel = 0;
                    y(i, h) && x(o, i, c.width, c.height), e.__version = i.version, i.onUpdate && i.onUpdate(i)
                }

                function P(e, r, o, a) {
                    const l = r.texture,
                        c = s.convert(l.format),
                        u = s.convert(l.type),
                        h = _(l.internalFormat, c, u);
                    32879 === a || 35866 === a ? n.texImage3D(a, 0, h, r.width, r.height, r.depth, 0, c, u, null) : n.texImage2D(a, 0, h, r.width, r.height, 0, c, u, null), t.bindFramebuffer(36160, e), t.framebufferTexture2D(36160, o, a, i.get(l).__webglTexture, 0), t.bindFramebuffer(36160, null)
                }

                function F(e, n, i) {
                    if (t.bindRenderbuffer(36161, e), n.depthBuffer && !n.stencilBuffer) {
                        let r = 33189;
                        if (i) {
                            const e = n.depthTexture;
                            e && e.isDepthTexture && (e.type === js ? r = 36012 : e.type === Vs && (r = 33190));
                            const i = I(n);
                            t.renderbufferStorageMultisample(36161, i, r, n.width, n.height)
                        } else t.renderbufferStorage(36161, r, n.width, n.height);
                        t.framebufferRenderbuffer(36160, 36096, 36161, e)
                    } else if (n.depthBuffer && n.stencilBuffer) {
                        if (i) {
                            const e = I(n);
                            t.renderbufferStorageMultisample(36161, e, 35056, n.width, n.height)
                        } else t.renderbufferStorage(36161, 34041, n.width, n.height);
                        t.framebufferRenderbuffer(36160, 33306, 36161, e)
                    } else {
                        const e = n.texture,
                            r = s.convert(e.format),
                            o = s.convert(e.type),
                            a = _(e.internalFormat, r, o);
                        if (i) {
                            const e = I(n);
                            t.renderbufferStorageMultisample(36161, e, a, n.width, n.height)
                        } else t.renderbufferStorage(36161, a, n.width, n.height)
                    }
                    t.bindRenderbuffer(36161, null)
                }

                function O(e) {
                    const n = i.get(e),
                        r = !0 === e.isWebGLCubeRenderTarget;
                    if (e.depthTexture) {
                        if (r) throw new Error("target.depthTexture not supported in Cube render targets");
                        ! function(e, n) {
                            if (n && n.isWebGLCubeRenderTarget) throw new Error("Depth Texture with cube render targets is not supported");
                            if (t.bindFramebuffer(36160, e), !n.depthTexture || !n.depthTexture.isDepthTexture) throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
                            i.get(n.depthTexture).__webglTexture && n.depthTexture.image.width === n.width && n.depthTexture.image.height === n.height || (n.depthTexture.image.width = n.width, n.depthTexture.image.height = n.height, n.depthTexture.needsUpdate = !0), E(n.depthTexture, 0);
                            const r = i.get(n.depthTexture).__webglTexture;
                            if (n.depthTexture.format === Js) t.framebufferTexture2D(36160, 36096, 3553, r, 0);
                            else {
                                if (n.depthTexture.format !== Qs) throw new Error("Unknown depthTexture format");
                                t.framebufferTexture2D(36160, 33306, 3553, r, 0)
                            }
                        }(n.__webglFramebuffer, e)
                    } else if (r) {
                        n.__webglDepthbuffer = [];
                        for (let i = 0; i < 6; i++) t.bindFramebuffer(36160, n.__webglFramebuffer[i]), n.__webglDepthbuffer[i] = t.createRenderbuffer(), F(n.__webglDepthbuffer[i], e, !1)
                    } else t.bindFramebuffer(36160, n.__webglFramebuffer), n.__webglDepthbuffer = t.createRenderbuffer(), F(n.__webglDepthbuffer, e, !1);
                    t.bindFramebuffer(36160, null)
                }

                function I(t) {
                    return a && t.isWebGLMultisampleRenderTarget ? Math.min(h, t.samples) : 0
                }
                let N = !1,
                    B = !1;
                this.allocateTextureUnit = function() {
                    const t = S;
                    return t >= l && console.warn("THREE.WebGLTextures: Trying to use " + t + " texture units while this GPU supports only " + l), S += 1, t
                }, this.resetTextureUnits = function() {
                    S = 0
                }, this.setTexture2D = E, this.setTexture2DArray = function(t, e) {
                    const r = i.get(t);
                    t.version > 0 && r.__version !== t.version ? R(r, t, e) : (n.activeTexture(33984 + e), n.bindTexture(35866, r.__webglTexture))
                }, this.setTexture3D = function(t, e) {
                    const r = i.get(t);
                    t.version > 0 && r.__version !== t.version ? R(r, t, e) : (n.activeTexture(33984 + e), n.bindTexture(32879, r.__webglTexture))
                }, this.setTextureCube = D, this.setupRenderTarget = function(e) {
                    const r = e.texture,
                        l = i.get(e),
                        c = i.get(r);
                    e.addEventListener("dispose", M), c.__webglTexture = t.createTexture(), o.memory.textures++;
                    const u = !0 === e.isWebGLCubeRenderTarget,
                        h = !0 === e.isWebGLMultisampleRenderTarget,
                        d = r.isDataTexture3D || r.isDataTexture2DArray,
                        p = v(e) || a;
                    if (!a || r.format !== Ys || r.type !== js && r.type !== qs || (r.format = Zs, console.warn("THREE.WebGLRenderer: Rendering to textures with RGB format is not supported. Using RGBA format instead.")), u) {
                        l.__webglFramebuffer = [];
                        for (let e = 0; e < 6; e++) l.__webglFramebuffer[e] = t.createFramebuffer()
                    } else if (l.__webglFramebuffer = t.createFramebuffer(), h)
                        if (a) {
                            l.__webglMultisampledFramebuffer = t.createFramebuffer(), l.__webglColorRenderbuffer = t.createRenderbuffer(), t.bindRenderbuffer(36161, l.__webglColorRenderbuffer);
                            const n = s.convert(r.format),
                                i = s.convert(r.type),
                                o = _(r.internalFormat, n, i),
                                a = I(e);
                            t.renderbufferStorageMultisample(36161, a, o, e.width, e.height), t.bindFramebuffer(36160, l.__webglMultisampledFramebuffer), t.framebufferRenderbuffer(36160, 36064, 36161, l.__webglColorRenderbuffer), t.bindRenderbuffer(36161, null), e.depthBuffer && (l.__webglDepthRenderbuffer = t.createRenderbuffer(), F(l.__webglDepthRenderbuffer, e, !0)), t.bindFramebuffer(36160, null)
                        } else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.");
                    if (u) {
                        n.bindTexture(34067, c.__webglTexture), C(34067, r, p);
                        for (let t = 0; t < 6; t++) P(l.__webglFramebuffer[t], e, 36064, 34069 + t);
                        y(r, p) && x(34067, r, e.width, e.height), n.bindTexture(34067, null)
                    } else {
                        let t = 3553;
                        if (d)
                            if (a) {
                                t = r.isDataTexture3D ? 32879 : 35866
                            } else console.warn("THREE.DataTexture3D and THREE.DataTexture2DArray only supported with WebGL2.");
                        n.bindTexture(t, c.__webglTexture), C(t, r, p), P(l.__webglFramebuffer, e, 36064, t), y(r, p) && x(3553, r, e.width, e.height), n.bindTexture(3553, null)
                    }
                    e.depthBuffer && O(e)
                }, this.updateRenderTargetMipmap = function(t) {
                    const e = t.texture;
                    if (y(e, v(t) || a)) {
                        const r = t.isWebGLCubeRenderTarget ? 34067 : 3553,
                            s = i.get(e).__webglTexture;
                        n.bindTexture(r, s), x(r, e, t.width, t.height), n.bindTexture(r, null)
                    }
                }, this.updateMultisampleRenderTarget = function(e) {
                    if (e.isWebGLMultisampleRenderTarget)
                        if (a) {
                            const n = i.get(e);
                            t.bindFramebuffer(36008, n.__webglMultisampledFramebuffer), t.bindFramebuffer(36009, n.__webglFramebuffer);
                            const r = e.width,
                                s = e.height;
                            let o = 16384;
                            e.depthBuffer && (o |= 256), e.stencilBuffer && (o |= 1024), t.blitFramebuffer(0, 0, r, s, 0, 0, r, s, o, 9728), t.bindFramebuffer(36160, n.__webglMultisampledFramebuffer)
                        } else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.")
                }, this.safeSetTexture2D = function(t, e) {
                    t && t.isWebGLRenderTarget && (!1 === N && (console.warn("THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead."), N = !0), t = t.texture), E(t, e)
                }, this.safeSetTextureCube = function(t, e) {
                    t && t.isWebGLCubeRenderTarget && (!1 === B && (console.warn("THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead."), B = !0), t = t.texture), D(t, e)
                }
            }

            function eh(t, e, n) {
                const i = n.isWebGL2;
                return {
                    convert: function(t) {
                        let n;
                        if (t === Gs) return 5121;
                        if (1017 === t) return 32819;
                        if (1018 === t) return 32820;
                        if (1019 === t) return 33635;
                        if (1010 === t) return 5120;
                        if (1011 === t) return 5122;
                        if (t === Ws) return 5123;
                        if (1013 === t) return 5124;
                        if (t === Vs) return 5125;
                        if (t === js) return 5126;
                        if (t === qs) return i ? 5131 : (n = e.get("OES_texture_half_float"), null !== n ? n.HALF_FLOAT_OES : null);
                        if (1021 === t) return 6406;
                        if (t === Ys) return 6407;
                        if (t === Zs) return 6408;
                        if (1024 === t) return 6409;
                        if (1025 === t) return 6410;
                        if (t === Js) return 6402;
                        if (t === Qs) return 34041;
                        if (1028 === t) return 6403;
                        if (1029 === t) return 36244;
                        if (1030 === t) return 33319;
                        if (1031 === t) return 33320;
                        if (1032 === t) return 36248;
                        if (1033 === t) return 36249;
                        if (33776 === t || 33777 === t || 33778 === t || 33779 === t) {
                            if (n = e.get("WEBGL_compressed_texture_s3tc"), null === n) return null;
                            if (33776 === t) return n.COMPRESSED_RGB_S3TC_DXT1_EXT;
                            if (33777 === t) return n.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                            if (33778 === t) return n.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                            if (33779 === t) return n.COMPRESSED_RGBA_S3TC_DXT5_EXT
                        }
                        if (35840 === t || 35841 === t || 35842 === t || 35843 === t) {
                            if (n = e.get("WEBGL_compressed_texture_pvrtc"), null === n) return null;
                            if (35840 === t) return n.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
                            if (35841 === t) return n.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                            if (35842 === t) return n.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
                            if (35843 === t) return n.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
                        }
                        if (36196 === t) return n = e.get("WEBGL_compressed_texture_etc1"), null !== n ? n.COMPRESSED_RGB_ETC1_WEBGL : null;
                        if ((37492 === t || 37496 === t) && (n = e.get("WEBGL_compressed_texture_etc"), null !== n)) {
                            if (37492 === t) return n.COMPRESSED_RGB8_ETC2;
                            if (37496 === t) return n.COMPRESSED_RGBA8_ETC2_EAC
                        }
                        return 37808 === t || 37809 === t || 37810 === t || 37811 === t || 37812 === t || 37813 === t || 37814 === t || 37815 === t || 37816 === t || 37817 === t || 37818 === t || 37819 === t || 37820 === t || 37821 === t || 37840 === t || 37841 === t || 37842 === t || 37843 === t || 37844 === t || 37845 === t || 37846 === t || 37847 === t || 37848 === t || 37849 === t || 37850 === t || 37851 === t || 37852 === t || 37853 === t ? (n = e.get("WEBGL_compressed_texture_astc"), null !== n ? t : null) : 36492 === t ? (n = e.get("EXT_texture_compression_bptc"), null !== n ? t : null) : t === Xs ? i ? 34042 : (n = e.get("WEBGL_depth_texture"), null !== n ? n.UNSIGNED_INT_24_8_WEBGL : null) : void 0
                    }
                }
            }

            function nh(t = []) {
                ql.call(this), this.cameras = t
            }
            nh.prototype = Object.assign(Object.create(ql.prototype), {
                constructor: nh,
                isArrayCamera: !0
            });
            class ih extends Ta {
                constructor() {
                    super(), this.type = "Group"
                }
            }

            function rh() {
                this._targetRay = null, this._grip = null, this._hand = null
            }

            function sh(t, e) {
                const n = this;
                let i = null,
                    r = 1,
                    s = null,
                    o = "local-floor",
                    a = null;
                const l = [],
                    c = new Map,
                    u = new ql;
                u.layers.enable(1), u.viewport = new Eo;
                const h = new ql;
                h.layers.enable(2), h.viewport = new Eo;
                const d = [u, h],
                    p = new nh;
                p.layers.enable(1), p.layers.enable(2);
                let f = null,
                    m = null;

                function g(t) {
                    const e = c.get(t.inputSource);
                    e && e.dispatchEvent({
                        type: t.type,
                        data: t.inputSource
                    })
                }

                function v() {
                    c.forEach((function(t, e) {
                        t.disconnect(e)
                    })), c.clear(), f = null, m = null, t.setFramebuffer(null), t.setRenderTarget(t.getRenderTarget()), M.stop(), n.isPresenting = !1, n.dispatchEvent({
                        type: "sessionend"
                    })
                }

                function y(t) {
                    const e = i.inputSources;
                    for (let t = 0; t < l.length; t++) c.set(e[t], l[t]);
                    for (let e = 0; e < t.removed.length; e++) {
                        const n = t.removed[e],
                            i = c.get(n);
                        i && (i.dispatchEvent({
                            type: "disconnected",
                            data: n
                        }), c.delete(n))
                    }
                    for (let e = 0; e < t.added.length; e++) {
                        const n = t.added[e],
                            i = c.get(n);
                        i && i.dispatchEvent({
                            type: "connected",
                            data: n
                        })
                    }
                }
                this.enabled = !1, this.isPresenting = !1, this.getController = function(t) {
                    let e = l[t];
                    return void 0 === e && (e = new rh, l[t] = e), e.getTargetRaySpace()
                }, this.getControllerGrip = function(t) {
                    let e = l[t];
                    return void 0 === e && (e = new rh, l[t] = e), e.getGripSpace()
                }, this.getHand = function(t) {
                    let e = l[t];
                    return void 0 === e && (e = new rh, l[t] = e), e.getHandSpace()
                }, this.setFramebufferScaleFactor = function(t) {
                    r = t, !0 === n.isPresenting && console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.")
                }, this.setReferenceSpaceType = function(t) {
                    o = t, !0 === n.isPresenting && console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.")
                }, this.getReferenceSpace = function() {
                    return s
                }, this.getSession = function() {
                    return i
                }, this.setSession = async function(t) {
                    if (i = t, null !== i) {
                        i.addEventListener("select", g), i.addEventListener("selectstart", g), i.addEventListener("selectend", g), i.addEventListener("squeeze", g), i.addEventListener("squeezestart", g), i.addEventListener("squeezeend", g), i.addEventListener("end", v), i.addEventListener("inputsourceschange", y);
                        const t = e.getContextAttributes();
                        !0 !== t.xrCompatible && await e.makeXRCompatible();
                        const a = {
                                antialias: t.antialias,
                                alpha: t.alpha,
                                depth: t.depth,
                                stencil: t.stencil,
                                framebufferScaleFactor: r
                            },
                            l = new XRWebGLLayer(i, e, a);
                        i.updateRenderState({
                            baseLayer: l
                        }), s = await i.requestReferenceSpace(o), M.setContext(i), M.start(), n.isPresenting = !0, n.dispatchEvent({
                            type: "sessionstart"
                        })
                    }
                };
                const x = new Ao,
                    _ = new Ao;

                function b(t, e) {
                    null === e ? t.matrixWorld.copy(t.matrix) : t.matrixWorld.multiplyMatrices(e.matrixWorld, t.matrix), t.matrixWorldInverse.copy(t.matrixWorld).invert()
                }
                this.getCamera = function(t) {
                    p.near = h.near = u.near = t.near, p.far = h.far = u.far = t.far, f === p.near && m === p.far || (i.updateRenderState({
                        depthNear: p.near,
                        depthFar: p.far
                    }), f = p.near, m = p.far);
                    const e = t.parent,
                        n = p.cameras;
                    b(p, e);
                    for (let t = 0; t < n.length; t++) b(n[t], e);
                    t.matrixWorld.copy(p.matrixWorld), t.matrix.copy(p.matrix), t.matrix.decompose(t.position, t.quaternion, t.scale);
                    const r = t.children;
                    for (let t = 0, e = r.length; t < e; t++) r[t].updateMatrixWorld(!0);
                    return 2 === n.length ? function(t, e, n) {
                        x.setFromMatrixPosition(e.matrixWorld), _.setFromMatrixPosition(n.matrixWorld);
                        const i = x.distanceTo(_),
                            r = e.projectionMatrix.elements,
                            s = n.projectionMatrix.elements,
                            o = r[14] / (r[10] - 1),
                            a = r[14] / (r[10] + 1),
                            l = (r[9] + 1) / r[5],
                            c = (r[9] - 1) / r[5],
                            u = (r[8] - 1) / r[0],
                            h = (s[8] + 1) / s[0],
                            d = o * u,
                            p = o * h,
                            f = i / (-u + h),
                            m = f * -u;
                        e.matrixWorld.decompose(t.position, t.quaternion, t.scale), t.translateX(m), t.translateZ(f), t.matrixWorld.compose(t.position, t.quaternion, t.scale), t.matrixWorldInverse.copy(t.matrixWorld).invert();
                        const g = o + f,
                            v = a + f,
                            y = d - m,
                            b = p + (i - m),
                            w = l * a / v * g,
                            M = c * a / v * g;
                        t.projectionMatrix.makePerspective(y, b, w, M, g, v)
                    }(p, u, h) : p.projectionMatrix.copy(u.projectionMatrix), p
                };
                let w = null;
                const M = new ec;
                M.setAnimationLoop((function(e, n) {
                    if (a = n.getViewerPose(s), null !== a) {
                        const e = a.views,
                            n = i.renderState.baseLayer;
                        t.setFramebuffer(n.framebuffer);
                        let r = !1;
                        e.length !== p.cameras.length && (p.cameras.length = 0, r = !0);
                        for (let t = 0; t < e.length; t++) {
                            const i = e[t],
                                s = n.getViewport(i),
                                o = d[t];
                            o.matrix.fromArray(i.transform.matrix), o.projectionMatrix.fromArray(i.projectionMatrix), o.viewport.set(s.x, s.y, s.width, s.height), 0 === t && p.matrix.copy(o.matrix), !0 === r && p.cameras.push(o)
                        }
                    }
                    const r = i.inputSources;
                    for (let t = 0; t < l.length; t++) {
                        const e = l[t],
                            i = r[t];
                        e.update(i, n, s)
                    }
                    w && w(e, n)
                })), this.setAnimationLoop = function(t) {
                    w = t
                }, this.dispose = function() {}
            }

            function oh(t) {
                function e(e, n) {
                    e.opacity.value = n.opacity, n.color && e.diffuse.value.copy(n.color), n.emissive && e.emissive.value.copy(n.emissive).multiplyScalar(n.emissiveIntensity), n.map && (e.map.value = n.map), n.alphaMap && (e.alphaMap.value = n.alphaMap), n.specularMap && (e.specularMap.value = n.specularMap);
                    const i = t.get(n).envMap;
                    if (i) {
                        e.envMap.value = i, e.flipEnvMap.value = i.isCubeTexture && i._needsFlipEnvMap ? -1 : 1, e.reflectivity.value = n.reflectivity, e.refractionRatio.value = n.refractionRatio;
                        const r = t.get(i).__maxMipLevel;
                        void 0 !== r && (e.maxMipLevel.value = r)
                    }
                    let r, s;
                    n.lightMap && (e.lightMap.value = n.lightMap, e.lightMapIntensity.value = n.lightMapIntensity), n.aoMap && (e.aoMap.value = n.aoMap, e.aoMapIntensity.value = n.aoMapIntensity), n.map ? r = n.map : n.specularMap ? r = n.specularMap : n.displacementMap ? r = n.displacementMap : n.normalMap ? r = n.normalMap : n.bumpMap ? r = n.bumpMap : n.roughnessMap ? r = n.roughnessMap : n.metalnessMap ? r = n.metalnessMap : n.alphaMap ? r = n.alphaMap : n.emissiveMap ? r = n.emissiveMap : n.clearcoatMap ? r = n.clearcoatMap : n.clearcoatNormalMap ? r = n.clearcoatNormalMap : n.clearcoatRoughnessMap && (r = n.clearcoatRoughnessMap), void 0 !== r && (r.isWebGLRenderTarget && (r = r.texture), !0 === r.matrixAutoUpdate && r.updateMatrix(), e.uvTransform.value.copy(r.matrix)), n.aoMap ? s = n.aoMap : n.lightMap && (s = n.lightMap), void 0 !== s && (s.isWebGLRenderTarget && (s = s.texture), !0 === s.matrixAutoUpdate && s.updateMatrix(), e.uv2Transform.value.copy(s.matrix))
                }

                function n(e, n) {
                    e.roughness.value = n.roughness, e.metalness.value = n.metalness, n.roughnessMap && (e.roughnessMap.value = n.roughnessMap), n.metalnessMap && (e.metalnessMap.value = n.metalnessMap), n.emissiveMap && (e.emissiveMap.value = n.emissiveMap), n.bumpMap && (e.bumpMap.value = n.bumpMap, e.bumpScale.value = n.bumpScale, 1 === n.side && (e.bumpScale.value *= -1)), n.normalMap && (e.normalMap.value = n.normalMap, e.normalScale.value.copy(n.normalScale), 1 === n.side && e.normalScale.value.negate()), n.displacementMap && (e.displacementMap.value = n.displacementMap, e.displacementScale.value = n.displacementScale, e.displacementBias.value = n.displacementBias);
                    t.get(n).envMap && (e.envMapIntensity.value = n.envMapIntensity)
                }
                return {
                    refreshFogUniforms: function(t, e) {
                        t.fogColor.value.copy(e.color), e.isFog ? (t.fogNear.value = e.near, t.fogFar.value = e.far) : e.isFogExp2 && (t.fogDensity.value = e.density)
                    },
                    refreshMaterialUniforms: function(t, i, r, s) {
                        i.isMeshBasicMaterial ? e(t, i) : i.isMeshLambertMaterial ? (e(t, i), function(t, e) {
                            e.emissiveMap && (t.emissiveMap.value = e.emissiveMap)
                        }(t, i)) : i.isMeshToonMaterial ? (e(t, i), function(t, e) {
                            e.gradientMap && (t.gradientMap.value = e.gradientMap);
                            e.emissiveMap && (t.emissiveMap.value = e.emissiveMap);
                            e.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale, 1 === e.side && (t.bumpScale.value *= -1));
                            e.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value.copy(e.normalScale), 1 === e.side && t.normalScale.value.negate());
                            e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias)
                        }(t, i)) : i.isMeshPhongMaterial ? (e(t, i), function(t, e) {
                            t.specular.value.copy(e.specular), t.shininess.value = Math.max(e.shininess, 1e-4), e.emissiveMap && (t.emissiveMap.value = e.emissiveMap);
                            e.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale, 1 === e.side && (t.bumpScale.value *= -1));
                            e.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value.copy(e.normalScale), 1 === e.side && t.normalScale.value.negate());
                            e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias)
                        }(t, i)) : i.isMeshStandardMaterial ? (e(t, i), i.isMeshPhysicalMaterial ? function(t, e) {
                            n(t, e), t.reflectivity.value = e.reflectivity, t.clearcoat.value = e.clearcoat, t.clearcoatRoughness.value = e.clearcoatRoughness, e.sheen && t.sheen.value.copy(e.sheen);
                            e.clearcoatMap && (t.clearcoatMap.value = e.clearcoatMap);
                            e.clearcoatRoughnessMap && (t.clearcoatRoughnessMap.value = e.clearcoatRoughnessMap);
                            e.clearcoatNormalMap && (t.clearcoatNormalScale.value.copy(e.clearcoatNormalScale), t.clearcoatNormalMap.value = e.clearcoatNormalMap, 1 === e.side && t.clearcoatNormalScale.value.negate());
                            t.transmission.value = e.transmission, e.transmissionMap && (t.transmissionMap.value = e.transmissionMap)
                        }(t, i) : n(t, i)) : i.isMeshMatcapMaterial ? (e(t, i), function(t, e) {
                            e.matcap && (t.matcap.value = e.matcap);
                            e.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale, 1 === e.side && (t.bumpScale.value *= -1));
                            e.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value.copy(e.normalScale), 1 === e.side && t.normalScale.value.negate());
                            e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias)
                        }(t, i)) : i.isMeshDepthMaterial ? (e(t, i), function(t, e) {
                            e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias)
                        }(t, i)) : i.isMeshDistanceMaterial ? (e(t, i), function(t, e) {
                            e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias);
                            t.referencePosition.value.copy(e.referencePosition), t.nearDistance.value = e.nearDistance, t.farDistance.value = e.farDistance
                        }(t, i)) : i.isMeshNormalMaterial ? (e(t, i), function(t, e) {
                            e.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale, 1 === e.side && (t.bumpScale.value *= -1));
                            e.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value.copy(e.normalScale), 1 === e.side && t.normalScale.value.negate());
                            e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias)
                        }(t, i)) : i.isLineBasicMaterial ? (function(t, e) {
                            t.diffuse.value.copy(e.color), t.opacity.value = e.opacity
                        }(t, i), i.isLineDashedMaterial && function(t, e) {
                            t.dashSize.value = e.dashSize, t.totalSize.value = e.dashSize + e.gapSize, t.scale.value = e.scale
                        }(t, i)) : i.isPointsMaterial ? function(t, e, n, i) {
                            t.diffuse.value.copy(e.color), t.opacity.value = e.opacity, t.size.value = e.size * n, t.scale.value = .5 * i, e.map && (t.map.value = e.map);
                            e.alphaMap && (t.alphaMap.value = e.alphaMap);
                            let r;
                            e.map ? r = e.map : e.alphaMap && (r = e.alphaMap);
                            void 0 !== r && (!0 === r.matrixAutoUpdate && r.updateMatrix(), t.uvTransform.value.copy(r.matrix))
                        }(t, i, r, s) : i.isSpriteMaterial ? function(t, e) {
                            t.diffuse.value.copy(e.color), t.opacity.value = e.opacity, t.rotation.value = e.rotation, e.map && (t.map.value = e.map);
                            e.alphaMap && (t.alphaMap.value = e.alphaMap);
                            let n;
                            e.map ? n = e.map : e.alphaMap && (n = e.alphaMap);
                            void 0 !== n && (!0 === n.matrixAutoUpdate && n.updateMatrix(), t.uvTransform.value.copy(n.matrix))
                        }(t, i) : i.isShadowMaterial ? (t.color.value.copy(i.color), t.opacity.value = i.opacity) : i.isShaderMaterial && (i.uniformsNeedUpdate = !1)
                    }
                }
            }

            function ah(t) {
                const e = void 0 !== (t = t || {}).canvas ? t.canvas : function() {
                        const t = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
                        return t.style.display = "block", t
                    }(),
                    n = void 0 !== t.context ? t.context : null,
                    i = void 0 !== t.alpha && t.alpha,
                    r = void 0 === t.depth || t.depth,
                    s = void 0 === t.stencil || t.stencil,
                    o = void 0 !== t.antialias && t.antialias,
                    a = void 0 === t.premultipliedAlpha || t.premultipliedAlpha,
                    l = void 0 !== t.preserveDrawingBuffer && t.preserveDrawingBuffer,
                    c = void 0 !== t.powerPreference ? t.powerPreference : "default",
                    u = void 0 !== t.failIfMajorPerformanceCaveat && t.failIfMajorPerformanceCaveat;
                let h = null,
                    d = null;
                const p = [],
                    f = [];
                this.domElement = e, this.debug = {
                    checkShaderErrors: !0
                }, this.autoClear = !0, this.autoClearColor = !0, this.autoClearDepth = !0, this.autoClearStencil = !0, this.sortObjects = !0, this.clippingPlanes = [], this.localClippingEnabled = !1, this.gammaFactor = 2, this.outputEncoding = so, this.physicallyCorrectLights = !1, this.toneMapping = 0, this.toneMappingExposure = 1, this.maxMorphTargets = 8, this.maxMorphNormals = 4;
                const m = this;
                let g = !1,
                    v = null,
                    y = 0,
                    x = 0,
                    _ = null,
                    b = null,
                    w = -1,
                    M = null;
                const S = new Eo,
                    E = new Eo;
                let D = null,
                    T = e.width,
                    A = e.height,
                    C = 1,
                    L = null,
                    R = null;
                const P = new Eo(0, 0, T, A),
                    F = new Eo(0, 0, T, A);
                let O = !1;
                const I = new tc;
                let N = !1,
                    B = !1;
                const z = new na,
                    k = new Ao,
                    H = {
                        background: null,
                        fog: null,
                        environment: null,
                        overrideMaterial: null,
                        isScene: !0
                    };

                function U() {
                    return null === _ ? C : 1
                }
                let G, W, V, j, q, X, Y, Z, J, Q, K, $, tt, et, nt, it, rt, st, ot, at, lt, ct = n;

                function ut(t, n) {
                    for (let i = 0; i < t.length; i++) {
                        const r = t[i],
                            s = e.getContext(r, n);
                        if (null !== s) return s
                    }
                    return null
                }
                try {
                    const t = {
                        alpha: i,
                        depth: r,
                        stencil: s,
                        antialias: o,
                        premultipliedAlpha: a,
                        preserveDrawingBuffer: l,
                        powerPreference: c,
                        failIfMajorPerformanceCaveat: u
                    };
                    if (e.addEventListener("webglcontextlost", ft, !1), e.addEventListener("webglcontextrestored", mt, !1), null === ct) {
                        const e = ["webgl2", "webgl", "experimental-webgl"];
                        if (!0 === m.isWebGL1Renderer && e.shift(), ct = ut(e, t), null === ct) throw ut(e) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.")
                    }
                    void 0 === ct.getShaderPrecisionFormat && (ct.getShaderPrecisionFormat = function() {
                        return {
                            rangeMin: 1,
                            rangeMax: 1,
                            precision: 1
                        }
                    })
                } catch (t) {
                    throw console.error("THREE.WebGLRenderer: " + t.message), t
                }

                function ht() {
                    G = new pc(ct), W = new uc(ct, G, t), G.init(W), at = new eh(ct, G, W), V = new $u(ct, G, W), V.scissor(E.copy(F).multiplyScalar(C).floor()), V.viewport(S.copy(P).multiplyScalar(C).floor()), j = new gc(ct), q = new ku, X = new th(ct, G, V, q, W, at, j), Y = new dc(m), Z = new nc(ct, W), lt = new lc(ct, G, Z, W), J = new fc(ct, Z, j, lt), Q = new _c(ct, J, Z, j), rt = new xc(ct), nt = new hc(q), K = new zu(m, Y, G, W, lt, nt), $ = new oh(q), tt = new Wu(q), et = new Zu(G, W), it = new ac(m, Y, V, Q, a), st = new cc(ct, G, j, W), ot = new mc(ct, G, j, W), j.programs = K.programs, m.capabilities = W, m.extensions = G, m.properties = q, m.renderLists = tt, m.state = V, m.info = j
                }
                ht();
                const dt = new sh(m, ct);
                this.xr = dt;
                const pt = new Ku(m, Q, W.maxTextureSize);

                function ft(t) {
                    t.preventDefault(), console.log("THREE.WebGLRenderer: Context Lost."), g = !0
                }

                function mt() {
                    console.log("THREE.WebGLRenderer: Context Restored."), g = !1, ht()
                }

                function gt(t) {
                    const e = t.target;
                    e.removeEventListener("dispose", gt),
                        function(t) {
                            vt(t), q.remove(t)
                        }(e)
                }

                function vt(t) {
                    const e = q.get(t).program;
                    void 0 !== e && K.releaseProgram(e)
                }
                this.shadowMap = pt, this.getContext = function() {
                    return ct
                }, this.getContextAttributes = function() {
                    return ct.getContextAttributes()
                }, this.forceContextLoss = function() {
                    const t = G.get("WEBGL_lose_context");
                    t && t.loseContext()
                }, this.forceContextRestore = function() {
                    const t = G.get("WEBGL_lose_context");
                    t && t.restoreContext()
                }, this.getPixelRatio = function() {
                    return C
                }, this.setPixelRatio = function(t) {
                    void 0 !== t && (C = t, this.setSize(T, A, !1))
                }, this.getSize = function(t) {
                    return void 0 === t && (console.warn("WebGLRenderer: .getsize() now requires a Vector2 as an argument"), t = new yo), t.set(T, A)
                }, this.setSize = function(t, n, i) {
                    dt.isPresenting ? console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.") : (T = t, A = n, e.width = Math.floor(t * C), e.height = Math.floor(n * C), !1 !== i && (e.style.width = t + "px", e.style.height = n + "px"), this.setViewport(0, 0, t, n))
                }, this.getDrawingBufferSize = function(t) {
                    return void 0 === t && (console.warn("WebGLRenderer: .getdrawingBufferSize() now requires a Vector2 as an argument"), t = new yo), t.set(T * C, A * C).floor()
                }, this.setDrawingBufferSize = function(t, n, i) {
                    T = t, A = n, C = i, e.width = Math.floor(t * i), e.height = Math.floor(n * i), this.setViewport(0, 0, t, n)
                }, this.getCurrentViewport = function(t) {
                    return void 0 === t && (console.warn("WebGLRenderer: .getCurrentViewport() now requires a Vector4 as an argument"), t = new Eo), t.copy(S)
                }, this.getViewport = function(t) {
                    return t.copy(P)
                }, this.setViewport = function(t, e, n, i) {
                    t.isVector4 ? P.set(t.x, t.y, t.z, t.w) : P.set(t, e, n, i), V.viewport(S.copy(P).multiplyScalar(C).floor())
                }, this.getScissor = function(t) {
                    return t.copy(F)
                }, this.setScissor = function(t, e, n, i) {
                    t.isVector4 ? F.set(t.x, t.y, t.z, t.w) : F.set(t, e, n, i), V.scissor(E.copy(F).multiplyScalar(C).floor())
                }, this.getScissorTest = function() {
                    return O
                }, this.setScissorTest = function(t) {
                    V.setScissorTest(O = t)
                }, this.setOpaqueSort = function(t) {
                    L = t
                }, this.setTransparentSort = function(t) {
                    R = t
                }, this.getClearColor = function(t) {
                    return void 0 === t && (console.warn("WebGLRenderer: .getClearColor() now requires a Color as an argument"), t = new Qa), t.copy(it.getClearColor())
                }, this.setClearColor = function() {
                    it.setClearColor.apply(it, arguments)
                }, this.getClearAlpha = function() {
                    return it.getClearAlpha()
                }, this.setClearAlpha = function() {
                    it.setClearAlpha.apply(it, arguments)
                }, this.clear = function(t, e, n) {
                    let i = 0;
                    (void 0 === t || t) && (i |= 16384), (void 0 === e || e) && (i |= 256), (void 0 === n || n) && (i |= 1024), ct.clear(i)
                }, this.clearColor = function() {
                    this.clear(!0, !1, !1)
                }, this.clearDepth = function() {
                    this.clear(!1, !0, !1)
                }, this.clearStencil = function() {
                    this.clear(!1, !1, !0)
                }, this.dispose = function() {
                    e.removeEventListener("webglcontextlost", ft, !1), e.removeEventListener("webglcontextrestored", mt, !1), tt.dispose(), et.dispose(), q.dispose(), Y.dispose(), Q.dispose(), lt.dispose(), dt.dispose(), xt.stop()
                }, this.renderBufferImmediate = function(t, e) {
                    lt.initAttributes();
                    const n = q.get(t);
                    t.hasPositions && !n.position && (n.position = ct.createBuffer()), t.hasNormals && !n.normal && (n.normal = ct.createBuffer()), t.hasUvs && !n.uv && (n.uv = ct.createBuffer()), t.hasColors && !n.color && (n.color = ct.createBuffer());
                    const i = e.getAttributes();
                    t.hasPositions && (ct.bindBuffer(34962, n.position), ct.bufferData(34962, t.positionArray, 35048), lt.enableAttribute(i.position), ct.vertexAttribPointer(i.position, 3, 5126, !1, 0, 0)), t.hasNormals && (ct.bindBuffer(34962, n.normal), ct.bufferData(34962, t.normalArray, 35048), lt.enableAttribute(i.normal), ct.vertexAttribPointer(i.normal, 3, 5126, !1, 0, 0)), t.hasUvs && (ct.bindBuffer(34962, n.uv), ct.bufferData(34962, t.uvArray, 35048), lt.enableAttribute(i.uv), ct.vertexAttribPointer(i.uv, 2, 5126, !1, 0, 0)), t.hasColors && (ct.bindBuffer(34962, n.color), ct.bufferData(34962, t.colorArray, 35048), lt.enableAttribute(i.color), ct.vertexAttribPointer(i.color, 3, 5126, !1, 0, 0)), lt.disableUnusedAttributes(), ct.drawArrays(4, 0, t.count), t.count = 0
                }, this.renderBufferDirect = function(t, e, n, i, r, s) {
                    null === e && (e = H);
                    const o = r.isMesh && r.matrixWorld.determinant() < 0,
                        a = St(t, e, i, r);
                    V.setMaterial(i, o);
                    let l = n.index;
                    const c = n.attributes.position;
                    if (null === l) {
                        if (void 0 === c || 0 === c.count) return
                    } else if (0 === l.count) return;
                    let u, h = 1;
                    !0 === i.wireframe && (l = J.getWireframeAttribute(n), h = 2), (i.morphTargets || i.morphNormals) && rt.update(r, n, i, a), lt.setup(r, i, a, n, l);
                    let d = st;
                    null !== l && (u = Z.get(l), d = ot, d.setIndex(u));
                    const p = null !== l ? l.count : c.count,
                        f = n.drawRange.start * h,
                        m = n.drawRange.count * h,
                        g = null !== s ? s.start * h : 0,
                        v = null !== s ? s.count * h : 1 / 0,
                        y = Math.max(f, g),
                        x = Math.min(p, f + m, g + v) - 1,
                        _ = Math.max(0, x - y + 1);
                    if (0 !== _) {
                        if (r.isMesh) !0 === i.wireframe ? (V.setLineWidth(i.wireframeLinewidth * U()), d.setMode(1)) : d.setMode(4);
                        else if (r.isLine) {
                            let t = i.linewidth;
                            void 0 === t && (t = 1), V.setLineWidth(t * U()), r.isLineSegments ? d.setMode(1) : r.isLineLoop ? d.setMode(2) : d.setMode(3)
                        } else r.isPoints ? d.setMode(0) : r.isSprite && d.setMode(4);
                        if (r.isInstancedMesh) d.renderInstances(y, _, r.count);
                        else if (n.isInstancedBufferGeometry) {
                            const t = Math.min(n.instanceCount, n._maxInstanceCount);
                            d.renderInstances(y, _, t)
                        } else d.render(y, _)
                    }
                }, this.compile = function(t, e) {
                    d = et.get(t), d.init(), t.traverseVisible((function(t) {
                        t.isLight && t.layers.test(e.layers) && (d.pushLight(t), t.castShadow && d.pushShadow(t))
                    })), d.setupLights();
                    const n = new WeakMap;
                    t.traverse((function(e) {
                        const i = e.material;
                        if (i)
                            if (Array.isArray(i))
                                for (let r = 0; r < i.length; r++) {
                                    const s = i[r];
                                    !1 === n.has(s) && (Mt(s, t, e), n.set(s))
                                } else !1 === n.has(i) && (Mt(i, t, e), n.set(i))
                    }))
                };
                let yt = null;
                const xt = new ec;

                function _t(t, e, n, i) {
                    if (!1 === t.visible) return;
                    if (t.layers.test(e.layers))
                        if (t.isGroup) n = t.renderOrder;
                        else if (t.isLOD) !0 === t.autoUpdate && t.update(e);
                    else if (t.isLight) d.pushLight(t), t.castShadow && d.pushShadow(t);
                    else if (t.isSprite) {
                        if (!t.frustumCulled || I.intersectsSprite(t)) {
                            i && k.setFromMatrixPosition(t.matrixWorld).applyMatrix4(z);
                            const e = Q.update(t),
                                r = t.material;
                            r.visible && h.push(t, e, r, n, k.z, null)
                        }
                    } else if (t.isImmediateRenderObject) i && k.setFromMatrixPosition(t.matrixWorld).applyMatrix4(z), h.push(t, null, t.material, n, k.z, null);
                    else if ((t.isMesh || t.isLine || t.isPoints) && (t.isSkinnedMesh && t.skeleton.frame !== j.render.frame && (t.skeleton.update(), t.skeleton.frame = j.render.frame), !t.frustumCulled || I.intersectsObject(t))) {
                        i && k.setFromMatrixPosition(t.matrixWorld).applyMatrix4(z);
                        const e = Q.update(t),
                            r = t.material;
                        if (Array.isArray(r)) {
                            const i = e.groups;
                            for (let s = 0, o = i.length; s < o; s++) {
                                const o = i[s],
                                    a = r[o.materialIndex];
                                a && a.visible && h.push(t, e, a, n, k.z, o)
                            }
                        } else r.visible && h.push(t, e, r, n, k.z, null)
                    }
                    const r = t.children;
                    for (let t = 0, s = r.length; t < s; t++) _t(r[t], e, n, i)
                }

                function bt(t, e, n) {
                    const i = !0 === e.isScene ? e.overrideMaterial : null;
                    for (let r = 0, s = t.length; r < s; r++) {
                        const s = t[r],
                            o = s.object,
                            a = s.geometry,
                            l = null === i ? s.material : i,
                            c = s.group;
                        if (n.isArrayCamera) {
                            const t = n.cameras;
                            for (let n = 0, i = t.length; n < i; n++) {
                                const i = t[n];
                                o.layers.test(i.layers) && (V.viewport(S.copy(i.viewport)), d.setupLightsView(i), wt(o, e, i, a, l, c))
                            }
                        } else wt(o, e, n, a, l, c)
                    }
                }

                function wt(t, e, n, i, r, s) {
                    if (t.onBeforeRender(m, e, n, i, r, s), t.modelViewMatrix.multiplyMatrices(n.matrixWorldInverse, t.matrixWorld), t.normalMatrix.getNormalMatrix(t.modelViewMatrix), t.isImmediateRenderObject) {
                        const i = St(n, e, r, t);
                        V.setMaterial(r), lt.reset(),
                            function(t, e) {
                                t.render((function(t) {
                                    m.renderBufferImmediate(t, e)
                                }))
                            }(t, i)
                    } else m.renderBufferDirect(n, e, i, r, t, s);
                    t.onAfterRender(m, e, n, i, r, s)
                }

                function Mt(t, e, n) {
                    !0 !== e.isScene && (e = H);
                    const i = q.get(t),
                        r = d.state.lights,
                        s = d.state.shadowsArray,
                        o = r.state.version,
                        a = K.getParameters(t, r.state, s, e, n),
                        l = K.getProgramCacheKey(a);
                    let c = i.program,
                        u = !0;
                    if (i.environment = t.isMeshStandardMaterial ? e.environment : null, i.fog = e.fog, i.envMap = Y.get(t.envMap || i.environment), void 0 === c) t.addEventListener("dispose", gt);
                    else if (c.cacheKey !== l) vt(t);
                    else if (i.lightsStateVersion !== o) u = !1;
                    else {
                        if (void 0 !== a.shaderID) return;
                        u = !1
                    }
                    u && (a.uniforms = K.getUniforms(t), t.onBeforeCompile(a, m), c = K.acquireProgram(a, l), i.program = c, i.uniforms = a.uniforms, i.outputEncoding = a.outputEncoding);
                    const h = i.uniforms;
                    (t.isShaderMaterial || t.isRawShaderMaterial) && !0 !== t.clipping || (i.numClippingPlanes = nt.numPlanes, i.numIntersection = nt.numIntersection, h.clippingPlanes = nt.uniform), i.needsLights = function(t) {
                        return t.isMeshLambertMaterial || t.isMeshToonMaterial || t.isMeshPhongMaterial || t.isMeshStandardMaterial || t.isShadowMaterial || t.isShaderMaterial && !0 === t.lights
                    }(t), i.lightsStateVersion = o, i.needsLights && (h.ambientLightColor.value = r.state.ambient, h.lightProbe.value = r.state.probe, h.directionalLights.value = r.state.directional, h.directionalLightShadows.value = r.state.directionalShadow, h.spotLights.value = r.state.spot, h.spotLightShadows.value = r.state.spotShadow, h.rectAreaLights.value = r.state.rectArea, h.ltc_1.value = r.state.rectAreaLTC1, h.ltc_2.value = r.state.rectAreaLTC2, h.pointLights.value = r.state.point, h.pointLightShadows.value = r.state.pointShadow, h.hemisphereLights.value = r.state.hemi, h.directionalShadowMap.value = r.state.directionalShadowMap, h.directionalShadowMatrix.value = r.state.directionalShadowMatrix, h.spotShadowMap.value = r.state.spotShadowMap, h.spotShadowMatrix.value = r.state.spotShadowMatrix, h.pointShadowMap.value = r.state.pointShadowMap, h.pointShadowMatrix.value = r.state.pointShadowMatrix);
                    const p = i.program.getUniforms(),
                        f = vu.seqWithValue(p.seq, h);
                    i.uniformsList = f
                }

                function St(t, e, n, i) {
                    !0 !== e.isScene && (e = H), X.resetTextureUnits();
                    const r = e.fog,
                        s = n.isMeshStandardMaterial ? e.environment : null,
                        o = null === _ ? m.outputEncoding : _.texture.encoding,
                        a = Y.get(n.envMap || s),
                        l = q.get(n),
                        c = d.state.lights;
                    if (!0 === N && (!0 === B || t !== M)) {
                        const e = t === M && n.id === w;
                        nt.setState(n, t, e)
                    }
                    n.version === l.__version ? n.fog && l.fog !== r || l.environment !== s || l.needsLights && l.lightsStateVersion !== c.state.version ? Mt(n, e, i) : void 0 === l.numClippingPlanes || l.numClippingPlanes === nt.numPlanes && l.numIntersection === nt.numIntersection ? (l.outputEncoding !== o || l.envMap !== a) && Mt(n, e, i) : Mt(n, e, i) : (Mt(n, e, i), l.__version = n.version);
                    let u = !1,
                        h = !1,
                        p = !1;
                    const f = l.program,
                        g = f.getUniforms(),
                        v = l.uniforms;
                    if (V.useProgram(f.program) && (u = !0, h = !0, p = !0), n.id !== w && (w = n.id, h = !0), u || M !== t) {
                        if (g.setValue(ct, "projectionMatrix", t.projectionMatrix), W.logarithmicDepthBuffer && g.setValue(ct, "logDepthBufFC", 2 / (Math.log(t.far + 1) / Math.LN2)), M !== t && (M = t, h = !0, p = !0), n.isShaderMaterial || n.isMeshPhongMaterial || n.isMeshToonMaterial || n.isMeshStandardMaterial || n.envMap) {
                            const e = g.map.cameraPosition;
                            void 0 !== e && e.setValue(ct, k.setFromMatrixPosition(t.matrixWorld))
                        }(n.isMeshPhongMaterial || n.isMeshToonMaterial || n.isMeshLambertMaterial || n.isMeshBasicMaterial || n.isMeshStandardMaterial || n.isShaderMaterial) && g.setValue(ct, "isOrthographic", !0 === t.isOrthographicCamera), (n.isMeshPhongMaterial || n.isMeshToonMaterial || n.isMeshLambertMaterial || n.isMeshBasicMaterial || n.isMeshStandardMaterial || n.isShaderMaterial || n.isShadowMaterial || n.skinning) && g.setValue(ct, "viewMatrix", t.matrixWorldInverse)
                    }
                    if (n.skinning) {
                        g.setOptional(ct, i, "bindMatrix"), g.setOptional(ct, i, "bindMatrixInverse");
                        const t = i.skeleton;
                        if (t) {
                            const e = t.bones;
                            if (W.floatVertexTextures) {
                                if (null === t.boneTexture) {
                                    let n = Math.sqrt(4 * e.length);
                                    n = vo.ceilPowerOfTwo(n), n = Math.max(n, 4);
                                    const i = new Float32Array(n * n * 4);
                                    i.set(t.boneMatrices);
                                    const r = new Ql(i, n, n, Zs, js);
                                    t.boneMatrices = i, t.boneTexture = r, t.boneTextureSize = n
                                }
                                g.setValue(ct, "boneTexture", t.boneTexture, X), g.setValue(ct, "boneTextureSize", t.boneTextureSize)
                            } else g.setOptional(ct, t, "boneMatrices")
                        }
                    }
                    var y, x;
                    return (h || l.receiveShadow !== i.receiveShadow) && (l.receiveShadow = i.receiveShadow, g.setValue(ct, "receiveShadow", i.receiveShadow)), h && (g.setValue(ct, "toneMappingExposure", m.toneMappingExposure), l.needsLights && (x = p, (y = v).ambientLightColor.needsUpdate = x, y.lightProbe.needsUpdate = x, y.directionalLights.needsUpdate = x, y.directionalLightShadows.needsUpdate = x, y.pointLights.needsUpdate = x, y.pointLightShadows.needsUpdate = x, y.spotLights.needsUpdate = x, y.spotLightShadows.needsUpdate = x, y.rectAreaLights.needsUpdate = x, y.hemisphereLights.needsUpdate = x), r && n.fog && $.refreshFogUniforms(v, r), $.refreshMaterialUniforms(v, n, C, A), vu.upload(ct, l.uniformsList, v, X)), n.isShaderMaterial && !0 === n.uniformsNeedUpdate && (vu.upload(ct, l.uniformsList, v, X), n.uniformsNeedUpdate = !1), n.isSpriteMaterial && g.setValue(ct, "center", i.center), g.setValue(ct, "modelViewMatrix", i.modelViewMatrix), g.setValue(ct, "normalMatrix", i.normalMatrix), g.setValue(ct, "modelMatrix", i.matrixWorld), f
                }
                xt.setAnimationLoop((function(t) {
                    dt.isPresenting || yt && yt(t)
                })), "undefined" != typeof window && xt.setContext(window), this.setAnimationLoop = function(t) {
                    yt = t, dt.setAnimationLoop(t), null === t ? xt.stop() : xt.start()
                }, this.render = function(t, e) {
                    let n, i;
                    if (void 0 !== arguments[2] && (console.warn("THREE.WebGLRenderer.render(): the renderTarget argument has been removed. Use .setRenderTarget() instead."), n = arguments[2]), void 0 !== arguments[3] && (console.warn("THREE.WebGLRenderer.render(): the forceClear argument has been removed. Use .clear() instead."), i = arguments[3]), void 0 !== e && !0 !== e.isCamera) return void console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
                    if (!0 === g) return;
                    lt.resetDefaultState(), w = -1, M = null, !0 === t.autoUpdate && t.updateMatrixWorld(), null === e.parent && e.updateMatrixWorld(), !0 === dt.enabled && !0 === dt.isPresenting && (e = dt.getCamera(e)), !0 === t.isScene && t.onBeforeRender(m, t, e, n || _), d = et.get(t, f.length), d.init(), f.push(d), z.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse), I.setFromProjectionMatrix(z), B = this.localClippingEnabled, N = nt.init(this.clippingPlanes, B, e), h = tt.get(t, p.length), h.init(), p.push(h), _t(t, e, 0, m.sortObjects), h.finish(), !0 === m.sortObjects && h.sort(L, R), !0 === N && nt.beginShadows();
                    const r = d.state.shadowsArray;
                    pt.render(r, t, e), d.setupLights(), d.setupLightsView(e), !0 === N && nt.endShadows(), !0 === this.info.autoReset && this.info.reset(), void 0 !== n && this.setRenderTarget(n), it.render(h, t, e, i);
                    const s = h.opaque,
                        o = h.transparent;
                    s.length > 0 && bt(s, t, e), o.length > 0 && bt(o, t, e), !0 === t.isScene && t.onAfterRender(m, t, e), null !== _ && (X.updateRenderTargetMipmap(_), X.updateMultisampleRenderTarget(_)), V.buffers.depth.setTest(!0), V.buffers.depth.setMask(!0), V.buffers.color.setMask(!0), V.setPolygonOffset(!1), f.pop(), d = f.length > 0 ? f[f.length - 1] : null, p.pop(), h = p.length > 0 ? p[p.length - 1] : null
                }, this.setFramebuffer = function(t) {
                    v !== t && null === _ && ct.bindFramebuffer(36160, t), v = t
                }, this.getActiveCubeFace = function() {
                    return y
                }, this.getActiveMipmapLevel = function() {
                    return x
                }, this.getRenderTarget = function() {
                    return _
                }, this.setRenderTarget = function(t, e = 0, n = 0) {
                    _ = t, y = e, x = n, t && void 0 === q.get(t).__webglFramebuffer && X.setupRenderTarget(t);
                    let i = v,
                        r = !1,
                        s = !1;
                    if (t) {
                        const n = t.texture;
                        (n.isDataTexture3D || n.isDataTexture2DArray) && (s = !0);
                        const o = q.get(t).__webglFramebuffer;
                        t.isWebGLCubeRenderTarget ? (i = o[e], r = !0) : i = t.isWebGLMultisampleRenderTarget ? q.get(t).__webglMultisampledFramebuffer : o, S.copy(t.viewport), E.copy(t.scissor), D = t.scissorTest
                    } else S.copy(P).multiplyScalar(C).floor(), E.copy(F).multiplyScalar(C).floor(), D = O;
                    if (b !== i && (ct.bindFramebuffer(36160, i), b = i), V.viewport(S), V.scissor(E), V.setScissorTest(D), r) {
                        const i = q.get(t.texture);
                        ct.framebufferTexture2D(36160, 36064, 34069 + e, i.__webglTexture, n)
                    } else if (s) {
                        const i = q.get(t.texture),
                            r = e || 0;
                        ct.framebufferTextureLayer(36160, 36064, i.__webglTexture, n || 0, r)
                    }
                }, this.readRenderTargetPixels = function(t, e, n, i, r, s, o) {
                    if (!t || !t.isWebGLRenderTarget) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
                    let a = q.get(t).__webglFramebuffer;
                    if (t.isWebGLCubeRenderTarget && void 0 !== o && (a = a[o]), a) {
                        let o = !1;
                        a !== b && (ct.bindFramebuffer(36160, a), o = !0);
                        try {
                            const a = t.texture,
                                l = a.format,
                                c = a.type;
                            if (l !== Zs && at.convert(l) !== ct.getParameter(35739)) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
                            const u = c === qs && (G.has("EXT_color_buffer_half_float") || W.isWebGL2 && G.has("EXT_color_buffer_float"));
                            if (!(c === Gs || at.convert(c) === ct.getParameter(35738) || c === js && (W.isWebGL2 || G.has("OES_texture_float") || G.has("WEBGL_color_buffer_float")) || u)) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
                            36053 === ct.checkFramebufferStatus(36160) ? e >= 0 && e <= t.width - i && n >= 0 && n <= t.height - r && ct.readPixels(e, n, i, r, at.convert(l), at.convert(c), s) : console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.")
                        } finally {
                            o && ct.bindFramebuffer(36160, b)
                        }
                    }
                }, this.copyFramebufferToTexture = function(t, e, n = 0) {
                    const i = Math.pow(2, -n),
                        r = Math.floor(e.image.width * i),
                        s = Math.floor(e.image.height * i),
                        o = at.convert(e.format);
                    X.setTexture2D(e, 0), ct.copyTexImage2D(3553, n, o, t.x, t.y, r, s, 0), V.unbindTexture()
                }, this.copyTextureToTexture = function(t, e, n, i = 0) {
                    const r = e.image.width,
                        s = e.image.height,
                        o = at.convert(n.format),
                        a = at.convert(n.type);
                    X.setTexture2D(n, 0), ct.pixelStorei(37440, n.flipY), ct.pixelStorei(37441, n.premultiplyAlpha), ct.pixelStorei(3317, n.unpackAlignment), e.isDataTexture ? ct.texSubImage2D(3553, i, t.x, t.y, r, s, o, a, e.image.data) : e.isCompressedTexture ? ct.compressedTexSubImage2D(3553, i, t.x, t.y, e.mipmaps[0].width, e.mipmaps[0].height, o, e.mipmaps[0].data) : ct.texSubImage2D(3553, i, t.x, t.y, o, a, e.image), 0 === i && n.generateMipmaps && ct.generateMipmap(3553), V.unbindTexture()
                }, this.copyTextureToTexture3D = function(t, e, n, i, r = 0) {
                    if (m.isWebGL1Renderer) return void console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.");
                    const {
                        width: s,
                        height: o,
                        data: a
                    } = n.image, l = at.convert(i.format), c = at.convert(i.type);
                    let u;
                    if (i.isDataTexture3D) X.setTexture3D(i, 0), u = 32879;
                    else {
                        if (!i.isDataTexture2DArray) return void console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");
                        X.setTexture2DArray(i, 0), u = 35866
                    }
                    ct.pixelStorei(37440, i.flipY), ct.pixelStorei(37441, i.premultiplyAlpha), ct.pixelStorei(3317, i.unpackAlignment);
                    const h = ct.getParameter(3314),
                        d = ct.getParameter(32878),
                        p = ct.getParameter(3316),
                        f = ct.getParameter(3315),
                        g = ct.getParameter(32877);
                    ct.pixelStorei(3314, s), ct.pixelStorei(32878, o), ct.pixelStorei(3316, t.min.x), ct.pixelStorei(3315, t.min.y), ct.pixelStorei(32877, t.min.z), ct.texSubImage3D(u, r, e.x, e.y, e.z, t.max.x - t.min.x + 1, t.max.y - t.min.y + 1, t.max.z - t.min.z + 1, l, c, a), ct.pixelStorei(3314, h), ct.pixelStorei(32878, d), ct.pixelStorei(3316, p), ct.pixelStorei(3315, f), ct.pixelStorei(32877, g), 0 === r && i.generateMipmaps && ct.generateMipmap(u), V.unbindTexture()
                }, this.initTexture = function(t) {
                    X.setTexture2D(t, 0), V.unbindTexture()
                }, this.resetState = function() {
                    V.reset(), lt.reset()
                }, "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {
                    detail: this
                }))
            }
            ih.prototype.isGroup = !0, Object.assign(rh.prototype, {
                constructor: rh,
                getHandSpace: function() {
                    return null === this._hand && (this._hand = new ih, this._hand.matrixAutoUpdate = !1, this._hand.visible = !1, this._hand.joints = {}, this._hand.inputState = {
                        pinching: !1
                    }), this._hand
                },
                getTargetRaySpace: function() {
                    return null === this._targetRay && (this._targetRay = new ih, this._targetRay.matrixAutoUpdate = !1, this._targetRay.visible = !1), this._targetRay
                },
                getGripSpace: function() {
                    return null === this._grip && (this._grip = new ih, this._grip.matrixAutoUpdate = !1, this._grip.visible = !1), this._grip
                },
                dispatchEvent: function(t) {
                    return null !== this._targetRay && this._targetRay.dispatchEvent(t), null !== this._grip && this._grip.dispatchEvent(t), null !== this._hand && this._hand.dispatchEvent(t), this
                },
                disconnect: function(t) {
                    return this.dispatchEvent({
                        type: "disconnected",
                        data: t
                    }), null !== this._targetRay && (this._targetRay.visible = !1), null !== this._grip && (this._grip.visible = !1), null !== this._hand && (this._hand.visible = !1), this
                },
                update: function(t, e, n) {
                    let i = null,
                        r = null,
                        s = null;
                    const o = this._targetRay,
                        a = this._grip,
                        l = this._hand;
                    if (t && "visible-blurred" !== e.session.visibilityState)
                        if (l && t.hand) {
                            s = !0;
                            for (const i of t.hand.values()) {
                                const t = e.getJointPose(i, n);
                                if (void 0 === l.joints[i.jointName]) {
                                    const t = new ih;
                                    t.matrixAutoUpdate = !1, t.visible = !1, l.joints[i.jointName] = t, l.add(t)
                                }
                                const r = l.joints[i.jointName];
                                null !== t && (r.matrix.fromArray(t.transform.matrix), r.matrix.decompose(r.position, r.rotation, r.scale), r.jointRadius = t.radius), r.visible = null !== t
                            }
                            const i = l.joints["index-finger-tip"],
                                r = l.joints["thumb-tip"],
                                o = i.position.distanceTo(r.position),
                                a = .02,
                                c = .005;
                            l.inputState.pinching && o > a + c ? (l.inputState.pinching = !1, this.dispatchEvent({
                                type: "pinchend",
                                handedness: t.handedness,
                                target: this
                            })) : !l.inputState.pinching && o <= a - c && (l.inputState.pinching = !0, this.dispatchEvent({
                                type: "pinchstart",
                                handedness: t.handedness,
                                target: this
                            }))
                        } else null !== o && (i = e.getPose(t.targetRaySpace, n), null !== i && (o.matrix.fromArray(i.transform.matrix), o.matrix.decompose(o.position, o.rotation, o.scale))), null !== a && t.gripSpace && (r = e.getPose(t.gripSpace, n), null !== r && (a.matrix.fromArray(r.transform.matrix), a.matrix.decompose(a.position, a.rotation, a.scale)));
                    return null !== o && (o.visible = null !== i), null !== a && (a.visible = null !== r), null !== l && (l.visible = null !== s), this
                }
            }), Object.assign(sh.prototype, fo.prototype);
            (class extends ah {}).prototype.isWebGL1Renderer = !0;
            class lh {
                constructor(t, e) {
                    this.name = "", this.color = new Qa(t), this.density = void 0 !== e ? e : 25e-5
                }
                clone() {
                    return new lh(this.color, this.density)
                }
                toJSON() {
                    return {
                        type: "FogExp2",
                        color: this.color.getHex(),
                        density: this.density
                    }
                }
            }
            lh.prototype.isFogExp2 = !0;
            class ch {
                constructor(t, e, n) {
                    this.name = "", this.color = new Qa(t), this.near = void 0 !== e ? e : 1, this.far = void 0 !== n ? n : 1e3
                }
                clone() {
                    return new ch(this.color, this.near, this.far)
                }
                toJSON() {
                    return {
                        type: "Fog",
                        color: this.color.getHex(),
                        near: this.near,
                        far: this.far
                    }
                }
            }
            ch.prototype.isFog = !0;
            class uh extends Ta {
                constructor() {
                    super(), this.type = "Scene", this.background = null, this.environment = null, this.fog = null, this.overrideMaterial = null, this.autoUpdate = !0, "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {
                        detail: this
                    }))
                }
                copy(t, e) {
                    return super.copy(t, e), null !== t.background && (this.background = t.background.clone()), null !== t.environment && (this.environment = t.environment.clone()), null !== t.fog && (this.fog = t.fog.clone()), null !== t.overrideMaterial && (this.overrideMaterial = t.overrideMaterial.clone()), this.autoUpdate = t.autoUpdate, this.matrixAutoUpdate = t.matrixAutoUpdate, this
                }
                toJSON(t) {
                    const e = super.toJSON(t);
                    return null !== this.background && (e.object.background = this.background.toJSON(t)), null !== this.environment && (e.object.environment = this.environment.toJSON(t)), null !== this.fog && (e.object.fog = this.fog.toJSON()), e
                }
            }

            function hh(t, e) {
                this.array = t, this.stride = e, this.count = void 0 !== t ? t.length / e : 0, this.usage = uo, this.updateRange = {
                    offset: 0,
                    count: -1
                }, this.version = 0, this.uuid = vo.generateUUID()
            }
            uh.prototype.isScene = !0, Object.defineProperty(hh.prototype, "needsUpdate", {
                set: function(t) {
                    !0 === t && this.version++
                }
            }), Object.assign(hh.prototype, {
                isInterleavedBuffer: !0,
                onUploadCallback: function() {},
                setUsage: function(t) {
                    return this.usage = t, this
                },
                copy: function(t) {
                    return this.array = new t.array.constructor(t.array), this.count = t.count, this.stride = t.stride, this.usage = t.usage, this
                },
                copyAt: function(t, e, n) {
                    t *= this.stride, n *= e.stride;
                    for (let i = 0, r = this.stride; i < r; i++) this.array[t + i] = e.array[n + i];
                    return this
                },
                set: function(t, e = 0) {
                    return this.array.set(t, e), this
                },
                clone: function(t) {
                    void 0 === t.arrayBuffers && (t.arrayBuffers = {}), void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = vo.generateUUID()), void 0 === t.arrayBuffers[this.array.buffer._uuid] && (t.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
                    const e = new hh(new this.array.constructor(t.arrayBuffers[this.array.buffer._uuid]), this.stride);
                    return e.setUsage(this.usage), e
                },
                onUpload: function(t) {
                    return this.onUploadCallback = t, this
                },
                toJSON: function(t) {
                    return void 0 === t.arrayBuffers && (t.arrayBuffers = {}), void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = vo.generateUUID()), void 0 === t.arrayBuffers[this.array.buffer._uuid] && (t.arrayBuffers[this.array.buffer._uuid] = Array.prototype.slice.call(new Uint32Array(this.array.buffer))), {
                        uuid: this.uuid,
                        buffer: this.array.buffer._uuid,
                        type: this.array.constructor.name,
                        stride: this.stride
                    }
                }
            });
            const dh = new Ao;

            function ph(t, e, n, i) {
                this.name = "", this.data = t, this.itemSize = e, this.offset = n, this.normalized = !0 === i
            }
            Object.defineProperties(ph.prototype, {
                count: {
                    get: function() {
                        return this.data.count
                    }
                },
                array: {
                    get: function() {
                        return this.data.array
                    }
                },
                needsUpdate: {
                    set: function(t) {
                        this.data.needsUpdate = t
                    }
                }
            }), Object.assign(ph.prototype, {
                isInterleavedBufferAttribute: !0,
                applyMatrix4: function(t) {
                    for (let e = 0, n = this.data.count; e < n; e++) dh.x = this.getX(e), dh.y = this.getY(e), dh.z = this.getZ(e), dh.applyMatrix4(t), this.setXYZ(e, dh.x, dh.y, dh.z);
                    return this
                },
                setX: function(t, e) {
                    return this.data.array[t * this.data.stride + this.offset] = e, this
                },
                setY: function(t, e) {
                    return this.data.array[t * this.data.stride + this.offset + 1] = e, this
                },
                setZ: function(t, e) {
                    return this.data.array[t * this.data.stride + this.offset + 2] = e, this
                },
                setW: function(t, e) {
                    return this.data.array[t * this.data.stride + this.offset + 3] = e, this
                },
                getX: function(t) {
                    return this.data.array[t * this.data.stride + this.offset]
                },
                getY: function(t) {
                    return this.data.array[t * this.data.stride + this.offset + 1]
                },
                getZ: function(t) {
                    return this.data.array[t * this.data.stride + this.offset + 2]
                },
                getW: function(t) {
                    return this.data.array[t * this.data.stride + this.offset + 3]
                },
                setXY: function(t, e, n) {
                    return t = t * this.data.stride + this.offset, this.data.array[t + 0] = e, this.data.array[t + 1] = n, this
                },
                setXYZ: function(t, e, n, i) {
                    return t = t * this.data.stride + this.offset, this.data.array[t + 0] = e, this.data.array[t + 1] = n, this.data.array[t + 2] = i, this
                },
                setXYZW: function(t, e, n, i, r) {
                    return t = t * this.data.stride + this.offset, this.data.array[t + 0] = e, this.data.array[t + 1] = n, this.data.array[t + 2] = i, this.data.array[t + 3] = r, this
                },
                clone: function(t) {
                    if (void 0 === t) {
                        console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data.");
                        const t = [];
                        for (let e = 0; e < this.count; e++) {
                            const n = e * this.data.stride + this.offset;
                            for (let e = 0; e < this.itemSize; e++) t.push(this.data.array[n + e])
                        }
                        return new el(new this.array.constructor(t), this.itemSize, this.normalized)
                    }
                    return void 0 === t.interleavedBuffers && (t.interleavedBuffers = {}), void 0 === t.interleavedBuffers[this.data.uuid] && (t.interleavedBuffers[this.data.uuid] = this.data.clone(t)), new ph(t.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized)
                },
                toJSON: function(t) {
                    if (void 0 === t) {
                        console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data.");
                        const t = [];
                        for (let e = 0; e < this.count; e++) {
                            const n = e * this.data.stride + this.offset;
                            for (let e = 0; e < this.itemSize; e++) t.push(this.data.array[n + e])
                        }
                        return {
                            itemSize: this.itemSize,
                            type: this.array.constructor.name,
                            array: t,
                            normalized: this.normalized
                        }
                    }
                    return void 0 === t.interleavedBuffers && (t.interleavedBuffers = {}), void 0 === t.interleavedBuffers[this.data.uuid] && (t.interleavedBuffers[this.data.uuid] = this.data.toJSON(t)), {
                        isInterleavedBufferAttribute: !0,
                        itemSize: this.itemSize,
                        data: this.data.uuid,
                        offset: this.offset,
                        normalized: this.normalized
                    }
                }
            });
            class fh extends Va {
                constructor(t) {
                    super(), this.type = "SpriteMaterial", this.color = new Qa(16777215), this.map = null, this.alphaMap = null, this.rotation = 0, this.sizeAttenuation = !0, this.transparent = !0, this.setValues(t)
                }
                copy(t) {
                    return super.copy(t), this.color.copy(t.color), this.map = t.map, this.alphaMap = t.alphaMap, this.rotation = t.rotation, this.sizeAttenuation = t.sizeAttenuation, this
                }
            }
            let mh;
            fh.prototype.isSpriteMaterial = !0;
            const gh = new Ao,
                vh = new Ao,
                yh = new Ao,
                xh = new yo,
                _h = new yo,
                bh = new na,
                wh = new Ao,
                Mh = new Ao,
                Sh = new Ao,
                Eh = new yo,
                Dh = new yo,
                Th = new yo;
            class Ah extends Ta {
                constructor(t) {
                    if (super(), this.type = "Sprite", void 0 === mh) {
                        mh = new _l;
                        const t = new hh(new Float32Array([-.5, -.5, 0, 0, 0, .5, -.5, 0, 1, 0, .5, .5, 0, 1, 1, -.5, .5, 0, 0, 1]), 5);
                        mh.setIndex([0, 1, 2, 0, 2, 3]), mh.setAttribute("position", new ph(t, 3, 0, !1)), mh.setAttribute("uv", new ph(t, 2, 3, !1))
                    }
                    this.geometry = mh, this.material = void 0 !== t ? t : new fh, this.center = new yo(.5, .5)
                }
                raycast(t, e) {
                    null === t.camera && console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'), vh.setFromMatrixScale(this.matrixWorld), bh.copy(t.camera.matrixWorld), this.modelViewMatrix.multiplyMatrices(t.camera.matrixWorldInverse, this.matrixWorld), yh.setFromMatrixPosition(this.modelViewMatrix), t.camera.isPerspectiveCamera && !1 === this.material.sizeAttenuation && vh.multiplyScalar(-yh.z);
                    const n = this.material.rotation;
                    let i, r;
                    0 !== n && (r = Math.cos(n), i = Math.sin(n));
                    const s = this.center;
                    Ch(wh.set(-.5, -.5, 0), yh, s, vh, i, r), Ch(Mh.set(.5, -.5, 0), yh, s, vh, i, r), Ch(Sh.set(.5, .5, 0), yh, s, vh, i, r), Eh.set(0, 0), Dh.set(1, 0), Th.set(1, 1);
                    let o = t.ray.intersectTriangle(wh, Mh, Sh, !1, gh);
                    if (null === o && (Ch(Mh.set(-.5, .5, 0), yh, s, vh, i, r), Dh.set(0, 1), o = t.ray.intersectTriangle(wh, Sh, Mh, !1, gh), null === o)) return;
                    const a = t.ray.origin.distanceTo(gh);
                    a < t.near || a > t.far || e.push({
                        distance: a,
                        point: gh.clone(),
                        uv: Ga.getUV(gh, wh, Mh, Sh, Eh, Dh, Th, new yo),
                        face: null,
                        object: this
                    })
                }
                copy(t) {
                    return super.copy(t), void 0 !== t.center && this.center.copy(t.center), this.material = t.material, this
                }
            }

            function Ch(t, e, n, i, r, s) {
                xh.subVectors(t, n).addScalar(.5).multiply(i), void 0 !== r ? (_h.x = s * xh.x - r * xh.y, _h.y = r * xh.x + s * xh.y) : _h.copy(xh), t.copy(e), t.x += _h.x, t.y += _h.y, t.applyMatrix4(bh)
            }
            Ah.prototype.isSprite = !0;
            const Lh = new Ao,
                Rh = new Ao;
            class Ph extends Ta {
                constructor() {
                    super(), this._currentLevel = 0, this.type = "LOD", Object.defineProperties(this, {
                        levels: {
                            enumerable: !0,
                            value: []
                        },
                        isLOD: {
                            value: !0
                        }
                    }), this.autoUpdate = !0
                }
                copy(t) {
                    super.copy(t, !1);
                    const e = t.levels;
                    for (let t = 0, n = e.length; t < n; t++) {
                        const n = e[t];
                        this.addLevel(n.object.clone(), n.distance)
                    }
                    return this.autoUpdate = t.autoUpdate, this
                }
                addLevel(t, e = 0) {
                    e = Math.abs(e);
                    const n = this.levels;
                    let i;
                    for (i = 0; i < n.length && !(e < n[i].distance); i++);
                    return n.splice(i, 0, {
                        distance: e,
                        object: t
                    }), this.add(t), this
                }
                getCurrentLevel() {
                    return this._currentLevel
                }
                getObjectForDistance(t) {
                    const e = this.levels;
                    if (e.length > 0) {
                        let n, i;
                        for (n = 1, i = e.length; n < i && !(t < e[n].distance); n++);
                        return e[n - 1].object
                    }
                    return null
                }
                raycast(t, e) {
                    if (this.levels.length > 0) {
                        Lh.setFromMatrixPosition(this.matrixWorld);
                        const n = t.ray.origin.distanceTo(Lh);
                        this.getObjectForDistance(n).raycast(t, e)
                    }
                }
                update(t) {
                    const e = this.levels;
                    if (e.length > 1) {
                        Lh.setFromMatrixPosition(t.matrixWorld), Rh.setFromMatrixPosition(this.matrixWorld);
                        const n = Lh.distanceTo(Rh) / t.zoom;
                        let i, r;
                        for (e[0].object.visible = !0, i = 1, r = e.length; i < r && n >= e[i].distance; i++) e[i - 1].object.visible = !1, e[i].object.visible = !0;
                        for (this._currentLevel = i - 1; i < r; i++) e[i].object.visible = !1
                    }
                }
                toJSON(t) {
                    const e = super.toJSON(t);
                    !1 === this.autoUpdate && (e.object.autoUpdate = !1), e.object.levels = [];
                    const n = this.levels;
                    for (let t = 0, i = n.length; t < i; t++) {
                        const i = n[t];
                        e.object.levels.push({
                            object: i.object.uuid,
                            distance: i.distance
                        })
                    }
                    return e
                }
            }
            const Fh = new Ao,
                Oh = new Eo,
                Ih = new Eo,
                Nh = new Ao,
                Bh = new na;

            function zh(t, e) {
                zl.call(this, t, e), this.type = "SkinnedMesh", this.bindMode = "attached", this.bindMatrix = new na, this.bindMatrixInverse = new na
            }

            function kh() {
                Ta.call(this), this.type = "Bone"
            }
            zh.prototype = Object.assign(Object.create(zl.prototype), {
                constructor: zh,
                isSkinnedMesh: !0,
                copy: function(t) {
                    return zl.prototype.copy.call(this, t), this.bindMode = t.bindMode, this.bindMatrix.copy(t.bindMatrix), this.bindMatrixInverse.copy(t.bindMatrixInverse), this.skeleton = t.skeleton, this
                },
                bind: function(t, e) {
                    this.skeleton = t, void 0 === e && (this.updateMatrixWorld(!0), this.skeleton.calculateInverses(), e = this.matrixWorld), this.bindMatrix.copy(e), this.bindMatrixInverse.copy(e).invert()
                },
                pose: function() {
                    this.skeleton.pose()
                },
                normalizeSkinWeights: function() {
                    const t = new Eo,
                        e = this.geometry.attributes.skinWeight;
                    for (let n = 0, i = e.count; n < i; n++) {
                        t.x = e.getX(n), t.y = e.getY(n), t.z = e.getZ(n), t.w = e.getW(n);
                        const i = 1 / t.manhattanLength();
                        i !== 1 / 0 ? t.multiplyScalar(i) : t.set(1, 0, 0, 0), e.setXYZW(n, t.x, t.y, t.z, t.w)
                    }
                },
                updateMatrixWorld: function(t) {
                    zl.prototype.updateMatrixWorld.call(this, t), "attached" === this.bindMode ? this.bindMatrixInverse.copy(this.matrixWorld).invert() : "detached" === this.bindMode ? this.bindMatrixInverse.copy(this.bindMatrix).invert() : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode)
                },
                boneTransform: function(t, e) {
                    const n = this.skeleton,
                        i = this.geometry;
                    Oh.fromBufferAttribute(i.attributes.skinIndex, t), Ih.fromBufferAttribute(i.attributes.skinWeight, t), Fh.fromBufferAttribute(i.attributes.position, t).applyMatrix4(this.bindMatrix), e.set(0, 0, 0);
                    for (let t = 0; t < 4; t++) {
                        const i = Ih.getComponent(t);
                        if (0 !== i) {
                            const r = Oh.getComponent(t);
                            Bh.multiplyMatrices(n.bones[r].matrixWorld, n.boneInverses[r]), e.addScaledVector(Nh.copy(Fh).applyMatrix4(Bh), i)
                        }
                    }
                    return e.applyMatrix4(this.bindMatrixInverse)
                }
            }), kh.prototype = Object.assign(Object.create(Ta.prototype), {
                constructor: kh,
                isBone: !0
            });
            const Hh = new na,
                Uh = new na;
            class Gh {
                constructor(t = [], e = []) {
                    this.uuid = vo.generateUUID(), this.bones = t.slice(0), this.boneInverses = e, this.boneMatrices = null, this.boneTexture = null, this.boneTextureSize = 0, this.frame = -1, this.init()
                }
                init() {
                    const t = this.bones,
                        e = this.boneInverses;
                    if (this.boneMatrices = new Float32Array(16 * t.length), 0 === e.length) this.calculateInverses();
                    else if (t.length !== e.length) {
                        console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."), this.boneInverses = [];
                        for (let t = 0, e = this.bones.length; t < e; t++) this.boneInverses.push(new na)
                    }
                }
                calculateInverses() {
                    this.boneInverses.length = 0;
                    for (let t = 0, e = this.bones.length; t < e; t++) {
                        const e = new na;
                        this.bones[t] && e.copy(this.bones[t].matrixWorld).invert(), this.boneInverses.push(e)
                    }
                }
                pose() {
                    for (let t = 0, e = this.bones.length; t < e; t++) {
                        const e = this.bones[t];
                        e && e.matrixWorld.copy(this.boneInverses[t]).invert()
                    }
                    for (let t = 0, e = this.bones.length; t < e; t++) {
                        const e = this.bones[t];
                        e && (e.parent && e.parent.isBone ? (e.matrix.copy(e.parent.matrixWorld).invert(), e.matrix.multiply(e.matrixWorld)) : e.matrix.copy(e.matrixWorld), e.matrix.decompose(e.position, e.quaternion, e.scale))
                    }
                }
                update() {
                    const t = this.bones,
                        e = this.boneInverses,
                        n = this.boneMatrices,
                        i = this.boneTexture;
                    for (let i = 0, r = t.length; i < r; i++) {
                        const r = t[i] ? t[i].matrixWorld : Uh;
                        Hh.multiplyMatrices(r, e[i]), Hh.toArray(n, 16 * i)
                    }
                    null !== i && (i.needsUpdate = !0)
                }
                clone() {
                    return new Gh(this.bones, this.boneInverses)
                }
                getBoneByName(t) {
                    for (let e = 0, n = this.bones.length; e < n; e++) {
                        const n = this.bones[e];
                        if (n.name === t) return n
                    }
                }
                dispose() {
                    null !== this.boneTexture && (this.boneTexture.dispose(), this.boneTexture = null)
                }
                fromJSON(t, e) {
                    this.uuid = t.uuid;
                    for (let n = 0, i = t.bones.length; n < i; n++) {
                        const i = t.bones[n];
                        let r = e[i];
                        void 0 === r && (console.warn("THREE.Skeleton: No bone found with UUID:", i), r = new kh), this.bones.push(r), this.boneInverses.push((new na).fromArray(t.boneInverses[n]))
                    }
                    return this.init(), this
                }
                toJSON() {
                    const t = {
                        metadata: {
                            version: 4.5,
                            type: "Skeleton",
                            generator: "Skeleton.toJSON"
                        },
                        bones: [],
                        boneInverses: []
                    };
                    t.uuid = this.uuid;
                    const e = this.bones,
                        n = this.boneInverses;
                    for (let i = 0, r = e.length; i < r; i++) {
                        const r = e[i];
                        t.bones.push(r.uuid);
                        const s = n[i];
                        t.boneInverses.push(s.toArray())
                    }
                    return t
                }
            }
            const Wh = new na,
                Vh = new na,
                jh = [],
                qh = new zl;

            function Xh(t, e, n) {
                zl.call(this, t, e), this.instanceMatrix = new el(new Float32Array(16 * n), 16), this.instanceColor = null, this.count = n, this.frustumCulled = !1
            }
            Xh.prototype = Object.assign(Object.create(zl.prototype), {
                constructor: Xh,
                isInstancedMesh: !0,
                copy: function(t) {
                    return zl.prototype.copy.call(this, t), this.instanceMatrix.copy(t.instanceMatrix), null !== t.instanceColor && (this.instanceColor = t.instanceColor.clone()), this.count = t.count, this
                },
                getColorAt: function(t, e) {
                    e.fromArray(this.instanceColor.array, 3 * t)
                },
                getMatrixAt: function(t, e) {
                    e.fromArray(this.instanceMatrix.array, 16 * t)
                },
                raycast: function(t, e) {
                    const n = this.matrixWorld,
                        i = this.count;
                    if (qh.geometry = this.geometry, qh.material = this.material, void 0 !== qh.material)
                        for (let r = 0; r < i; r++) {
                            this.getMatrixAt(r, Wh), Vh.multiplyMatrices(n, Wh), qh.matrixWorld = Vh, qh.raycast(t, jh);
                            for (let t = 0, n = jh.length; t < n; t++) {
                                const n = jh[t];
                                n.instanceId = r, n.object = this, e.push(n)
                            }
                            jh.length = 0
                        }
                },
                setColorAt: function(t, e) {
                    null === this.instanceColor && (this.instanceColor = new el(new Float32Array(3 * this.count), 3)), e.toArray(this.instanceColor.array, 3 * t)
                },
                setMatrixAt: function(t, e) {
                    e.toArray(this.instanceMatrix.array, 16 * t)
                },
                updateMorphTargets: function() {},
                dispose: function() {
                    this.dispatchEvent({
                        type: "dispose"
                    })
                }
            });
            class Yh extends Va {
                constructor(t) {
                    super(), this.type = "LineBasicMaterial", this.color = new Qa(16777215), this.linewidth = 1, this.linecap = "round", this.linejoin = "round", this.morphTargets = !1, this.setValues(t)
                }
                copy(t) {
                    return super.copy(t), this.color.copy(t.color), this.linewidth = t.linewidth, this.linecap = t.linecap, this.linejoin = t.linejoin, this.morphTargets = t.morphTargets, this
                }
            }
            Yh.prototype.isLineBasicMaterial = !0;
            const Zh = new Ao,
                Jh = new Ao,
                Qh = new na,
                Kh = new ea,
                $h = new Xo;

            function td(t = new _l, e = new Yh) {
                Ta.call(this), this.type = "Line", this.geometry = t, this.material = e, this.updateMorphTargets()
            }
            td.prototype = Object.assign(Object.create(Ta.prototype), {
                constructor: td,
                isLine: !0,
                copy: function(t) {
                    return Ta.prototype.copy.call(this, t), this.material = t.material, this.geometry = t.geometry, this
                },
                computeLineDistances: function() {
                    const t = this.geometry;
                    if (t.isBufferGeometry)
                        if (null === t.index) {
                            const e = t.attributes.position,
                                n = [0];
                            for (let t = 1, i = e.count; t < i; t++) Zh.fromBufferAttribute(e, t - 1), Jh.fromBufferAttribute(e, t), n[t] = n[t - 1], n[t] += Zh.distanceTo(Jh);
                            t.setAttribute("lineDistance", new ul(n, 1))
                        } else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
                    else t.isGeometry && console.error("THREE.Line.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
                    return this
                },
                raycast: function(t, e) {
                    const n = this.geometry,
                        i = this.matrixWorld,
                        r = t.params.Line.threshold;
                    if (null === n.boundingSphere && n.computeBoundingSphere(), $h.copy(n.boundingSphere), $h.applyMatrix4(i), $h.radius += r, !1 === t.ray.intersectsSphere($h)) return;
                    Qh.copy(i).invert(), Kh.copy(t.ray).applyMatrix4(Qh);
                    const s = r / ((this.scale.x + this.scale.y + this.scale.z) / 3),
                        o = s * s,
                        a = new Ao,
                        l = new Ao,
                        c = new Ao,
                        u = new Ao,
                        h = this.isLineSegments ? 2 : 1;
                    if (n.isBufferGeometry) {
                        const i = n.index,
                            r = n.attributes.position;
                        if (null !== i) {
                            const n = i.array;
                            for (let i = 0, s = n.length - 1; i < s; i += h) {
                                const s = n[i],
                                    h = n[i + 1];
                                a.fromBufferAttribute(r, s), l.fromBufferAttribute(r, h);
                                if (Kh.distanceSqToSegment(a, l, u, c) > o) continue;
                                u.applyMatrix4(this.matrixWorld);
                                const d = t.ray.origin.distanceTo(u);
                                d < t.near || d > t.far || e.push({
                                    distance: d,
                                    point: c.clone().applyMatrix4(this.matrixWorld),
                                    index: i,
                                    face: null,
                                    faceIndex: null,
                                    object: this
                                })
                            }
                        } else
                            for (let n = 0, i = r.count - 1; n < i; n += h) {
                                a.fromBufferAttribute(r, n), l.fromBufferAttribute(r, n + 1);
                                if (Kh.distanceSqToSegment(a, l, u, c) > o) continue;
                                u.applyMatrix4(this.matrixWorld);
                                const i = t.ray.origin.distanceTo(u);
                                i < t.near || i > t.far || e.push({
                                    distance: i,
                                    point: c.clone().applyMatrix4(this.matrixWorld),
                                    index: n,
                                    face: null,
                                    faceIndex: null,
                                    object: this
                                })
                            }
                    } else n.isGeometry && console.error("THREE.Line.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")
                },
                updateMorphTargets: function() {
                    const t = this.geometry;
                    if (t.isBufferGeometry) {
                        const e = t.morphAttributes,
                            n = Object.keys(e);
                        if (n.length > 0) {
                            const t = e[n[0]];
                            if (void 0 !== t) {
                                this.morphTargetInfluences = [], this.morphTargetDictionary = {};
                                for (let e = 0, n = t.length; e < n; e++) {
                                    const n = t[e].name || String(e);
                                    this.morphTargetInfluences.push(0), this.morphTargetDictionary[n] = e
                                }
                            }
                        }
                    } else {
                        const e = t.morphTargets;
                        void 0 !== e && e.length > 0 && console.error("THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.")
                    }
                }
            });
            const ed = new Ao,
                nd = new Ao;

            function id(t, e) {
                td.call(this, t, e), this.type = "LineSegments"
            }
            id.prototype = Object.assign(Object.create(td.prototype), {
                constructor: id,
                isLineSegments: !0,
                computeLineDistances: function() {
                    const t = this.geometry;
                    if (t.isBufferGeometry)
                        if (null === t.index) {
                            const e = t.attributes.position,
                                n = [];
                            for (let t = 0, i = e.count; t < i; t += 2) ed.fromBufferAttribute(e, t), nd.fromBufferAttribute(e, t + 1), n[t] = 0 === t ? 0 : n[t - 1], n[t + 1] = n[t] + ed.distanceTo(nd);
                            t.setAttribute("lineDistance", new ul(n, 1))
                        } else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
                    else t.isGeometry && console.error("THREE.LineSegments.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
                    return this
                }
            });
            class rd extends td {
                constructor(t, e) {
                    super(t, e), this.type = "LineLoop"
                }
            }
            rd.prototype.isLineLoop = !0;
            class sd extends Va {
                constructor(t) {
                    super(), this.type = "PointsMaterial", this.color = new Qa(16777215), this.map = null, this.alphaMap = null, this.size = 1, this.sizeAttenuation = !0, this.morphTargets = !1, this.setValues(t)
                }
                copy(t) {
                    return super.copy(t), this.color.copy(t.color), this.map = t.map, this.alphaMap = t.alphaMap, this.size = t.size, this.sizeAttenuation = t.sizeAttenuation, this.morphTargets = t.morphTargets, this
                }
            }
            sd.prototype.isPointsMaterial = !0;
            const od = new na,
                ad = new ea,
                ld = new Xo,
                cd = new Ao;

            function ud(t = new _l, e = new sd) {
                Ta.call(this), this.type = "Points", this.geometry = t, this.material = e, this.updateMorphTargets()
            }

            function hd(t, e, n, i, r, s, o) {
                const a = ad.distanceSqToPoint(t);
                if (a < n) {
                    const n = new Ao;
                    ad.closestPointToPoint(t, n), n.applyMatrix4(i);
                    const l = r.ray.origin.distanceTo(n);
                    if (l < r.near || l > r.far) return;
                    s.push({
                        distance: l,
                        distanceToRay: Math.sqrt(a),
                        point: n,
                        index: e,
                        face: null,
                        object: o
                    })
                }
            }
            ud.prototype = Object.assign(Object.create(Ta.prototype), {
                constructor: ud,
                isPoints: !0,
                copy: function(t) {
                    return Ta.prototype.copy.call(this, t), this.material = t.material, this.geometry = t.geometry, this
                },
                raycast: function(t, e) {
                    const n = this.geometry,
                        i = this.matrixWorld,
                        r = t.params.Points.threshold;
                    if (null === n.boundingSphere && n.computeBoundingSphere(), ld.copy(n.boundingSphere), ld.applyMatrix4(i), ld.radius += r, !1 === t.ray.intersectsSphere(ld)) return;
                    od.copy(i).invert(), ad.copy(t.ray).applyMatrix4(od);
                    const s = r / ((this.scale.x + this.scale.y + this.scale.z) / 3),
                        o = s * s;
                    if (n.isBufferGeometry) {
                        const r = n.index,
                            s = n.attributes.position;
                        if (null !== r) {
                            const n = r.array;
                            for (let r = 0, a = n.length; r < a; r++) {
                                const a = n[r];
                                cd.fromBufferAttribute(s, a), hd(cd, a, o, i, t, e, this)
                            }
                        } else
                            for (let n = 0, r = s.count; n < r; n++) cd.fromBufferAttribute(s, n), hd(cd, n, o, i, t, e, this)
                    } else console.error("THREE.Points.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")
                },
                updateMorphTargets: function() {
                    const t = this.geometry;
                    if (t.isBufferGeometry) {
                        const e = t.morphAttributes,
                            n = Object.keys(e);
                        if (n.length > 0) {
                            const t = e[n[0]];
                            if (void 0 !== t) {
                                this.morphTargetInfluences = [], this.morphTargetDictionary = {};
                                for (let e = 0, n = t.length; e < n; e++) {
                                    const n = t[e].name || String(e);
                                    this.morphTargetInfluences.push(0), this.morphTargetDictionary[n] = e
                                }
                            }
                        }
                    } else {
                        const e = t.morphTargets;
                        void 0 !== e && e.length > 0 && console.error("THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.")
                    }
                }
            });
            (class extends Mo {
                constructor(t, e, n, i, r, s, o, a, l) {
                    super(t, e, n, i, r, s, o, a, l), this.format = void 0 !== o ? o : Ys, this.minFilter = void 0 !== s ? s : Hs, this.magFilter = void 0 !== r ? r : Hs, this.generateMipmaps = !1;
                    const c = this;
                    "requestVideoFrameCallback" in t && t.requestVideoFrameCallback((function e() {
                        c.needsUpdate = !0, t.requestVideoFrameCallback(e)
                    }))
                }
                clone() {
                    return new this.constructor(this.image).copy(this)
                }
                update() {
                    const t = this.image;
                    !1 === "requestVideoFrameCallback" in t && t.readyState >= t.HAVE_CURRENT_DATA && (this.needsUpdate = !0)
                }
            }).prototype.isVideoTexture = !0;
            class dd extends Mo {
                constructor(t, e, n, i, r, s, o, a, l, c, u, h) {
                    super(null, s, o, a, l, c, i, r, u, h), this.image = {
                        width: e,
                        height: n
                    }, this.mipmaps = t, this.flipY = !1, this.generateMipmaps = !1
                }
            }
            dd.prototype.isCompressedTexture = !0;
            (class extends Mo {
                constructor(t, e, n, i, r, s, o, a, l) {
                    super(t, e, n, i, r, s, o, a, l), this.needsUpdate = !0
                }
            }).prototype.isCanvasTexture = !0;
            (class extends Mo {
                constructor(t, e, n, i, r, s, o, a, l, c) {
                    if ((c = void 0 !== c ? c : Js) !== Js && c !== Qs) throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
                    void 0 === n && c === Js && (n = Ws), void 0 === n && c === Qs && (n = Xs), super(null, i, r, s, o, a, c, n, l), this.image = {
                        width: t,
                        height: e
                    }, this.magFilter = void 0 !== o ? o : Bs, this.minFilter = void 0 !== a ? a : Bs, this.flipY = !1, this.generateMipmaps = !1
                }
            }).prototype.isDepthTexture = !0;
            class pd extends _l {
                constructor(t = 1, e = 1, n = 1, i = 8, r = 1, s = !1, o = 0, a = 2 * Math.PI) {
                    super(), this.type = "CylinderGeometry", this.parameters = {
                        radiusTop: t,
                        radiusBottom: e,
                        height: n,
                        radialSegments: i,
                        heightSegments: r,
                        openEnded: s,
                        thetaStart: o,
                        thetaLength: a
                    };
                    const l = this;
                    i = Math.floor(i), r = Math.floor(r);
                    const c = [],
                        u = [],
                        h = [],
                        d = [];
                    let p = 0;
                    const f = [],
                        m = n / 2;
                    let g = 0;

                    function v(n) {
                        const r = p,
                            s = new yo,
                            f = new Ao;
                        let v = 0;
                        const y = !0 === n ? t : e,
                            x = !0 === n ? 1 : -1;
                        for (let t = 1; t <= i; t++) u.push(0, m * x, 0), h.push(0, x, 0), d.push(.5, .5), p++;
                        const _ = p;
                        for (let t = 0; t <= i; t++) {
                            const e = t / i * a + o,
                                n = Math.cos(e),
                                r = Math.sin(e);
                            f.x = y * r, f.y = m * x, f.z = y * n, u.push(f.x, f.y, f.z), h.push(0, x, 0), s.x = .5 * n + .5, s.y = .5 * r * x + .5, d.push(s.x, s.y), p++
                        }
                        for (let t = 0; t < i; t++) {
                            const e = r + t,
                                i = _ + t;
                            !0 === n ? c.push(i, i + 1, e) : c.push(i + 1, i, e), v += 3
                        }
                        l.addGroup(g, v, !0 === n ? 1 : 2), g += v
                    }! function() {
                        const s = new Ao,
                            v = new Ao;
                        let y = 0;
                        const x = (e - t) / n;
                        for (let l = 0; l <= r; l++) {
                            const c = [],
                                g = l / r,
                                y = g * (e - t) + t;
                            for (let t = 0; t <= i; t++) {
                                const e = t / i,
                                    r = e * a + o,
                                    l = Math.sin(r),
                                    f = Math.cos(r);
                                v.x = y * l, v.y = -g * n + m, v.z = y * f, u.push(v.x, v.y, v.z), s.set(l, x, f).normalize(), h.push(s.x, s.y, s.z), d.push(e, 1 - g), c.push(p++)
                            }
                            f.push(c)
                        }
                        for (let t = 0; t < i; t++)
                            for (let e = 0; e < r; e++) {
                                const n = f[e][t],
                                    i = f[e + 1][t],
                                    r = f[e + 1][t + 1],
                                    s = f[e][t + 1];
                                c.push(n, i, s), c.push(i, r, s), y += 6
                            }
                        l.addGroup(g, y, 0), g += y
                    }(), !1 === s && (t > 0 && v(!0), e > 0 && v(!1)), this.setIndex(c), this.setAttribute("position", new ul(u, 3)), this.setAttribute("normal", new ul(h, 3)), this.setAttribute("uv", new ul(d, 2))
                }
            }
            new Ao, new Ao, new Ao, new Ga;
            const fd = function(t, e, n) {
                n = n || 2;
                const i = e && e.length,
                    r = i ? e[0] * n : t.length;
                let s = md(t, 0, r, n, !0);
                const o = [];
                if (!s || s.next === s.prev) return o;
                let a, l, c, u, h, d, p;
                if (i && (s = function(t, e, n, i) {
                        const r = [];
                        let s, o, a, l, c;
                        for (s = 0, o = e.length; s < o; s++) a = e[s] * i, l = s < o - 1 ? e[s + 1] * i : t.length, c = md(t, a, l, i, !1), c === c.next && (c.steiner = !0), r.push(Dd(c));
                        for (r.sort(wd), s = 0; s < r.length; s++) Md(r[s], n), n = gd(n, n.next);
                        return n
                    }(t, e, s, n)), t.length > 80 * n) {
                    a = c = t[0], l = u = t[1];
                    for (let e = n; e < r; e += n) h = t[e], d = t[e + 1], h < a && (a = h), d < l && (l = d), h > c && (c = h), d > u && (u = d);
                    p = Math.max(c - a, u - l), p = 0 !== p ? 1 / p : 0
                }
                return vd(s, o, n, a, l, p), o
            };

            function md(t, e, n, i, r) {
                let s, o;
                if (r === function(t, e, n, i) {
                        let r = 0;
                        for (let s = e, o = n - i; s < n; s += i) r += (t[o] - t[s]) * (t[s + 1] + t[o + 1]), o = s;
                        return r
                    }(t, e, n, i) > 0)
                    for (s = e; s < n; s += i) o = Nd(s, t[s], t[s + 1], o);
                else
                    for (s = n - i; s >= e; s -= i) o = Nd(s, t[s], t[s + 1], o);
                return o && Ld(o, o.next) && (Bd(o), o = o.next), o
            }

            function gd(t, e) {
                if (!t) return t;
                e || (e = t);
                let n, i = t;
                do {
                    if (n = !1, i.steiner || !Ld(i, i.next) && 0 !== Cd(i.prev, i, i.next)) i = i.next;
                    else {
                        if (Bd(i), i = e = i.prev, i === i.next) break;
                        n = !0
                    }
                } while (n || i !== e);
                return e
            }

            function vd(t, e, n, i, r, s, o) {
                if (!t) return;
                !o && s && function(t, e, n, i) {
                    let r = t;
                    do {
                        null === r.z && (r.z = Ed(r.x, r.y, e, n, i)), r.prevZ = r.prev, r.nextZ = r.next, r = r.next
                    } while (r !== t);
                    r.prevZ.nextZ = null, r.prevZ = null,
                        function(t) {
                            let e, n, i, r, s, o, a, l, c = 1;
                            do {
                                for (n = t, t = null, s = null, o = 0; n;) {
                                    for (o++, i = n, a = 0, e = 0; e < c && (a++, i = i.nextZ, i); e++);
                                    for (l = c; a > 0 || l > 0 && i;) 0 !== a && (0 === l || !i || n.z <= i.z) ? (r = n, n = n.nextZ, a--) : (r = i, i = i.nextZ, l--), s ? s.nextZ = r : t = r, r.prevZ = s, s = r;
                                    n = i
                                }
                                s.nextZ = null, c *= 2
                            } while (o > 1)
                        }(r)
                }(t, i, r, s);
                let a, l, c = t;
                for (; t.prev !== t.next;)
                    if (a = t.prev, l = t.next, s ? xd(t, i, r, s) : yd(t)) e.push(a.i / n), e.push(t.i / n), e.push(l.i / n), Bd(t), t = l.next, c = l.next;
                    else if ((t = l) === c) {
                    o ? 1 === o ? vd(t = _d(gd(t), e, n), e, n, i, r, s, 2) : 2 === o && bd(t, e, n, i, r, s) : vd(gd(t), e, n, i, r, s, 1);
                    break
                }
            }

            function yd(t) {
                const e = t.prev,
                    n = t,
                    i = t.next;
                if (Cd(e, n, i) >= 0) return !1;
                let r = t.next.next;
                for (; r !== t.prev;) {
                    if (Td(e.x, e.y, n.x, n.y, i.x, i.y, r.x, r.y) && Cd(r.prev, r, r.next) >= 0) return !1;
                    r = r.next
                }
                return !0
            }

            function xd(t, e, n, i) {
                const r = t.prev,
                    s = t,
                    o = t.next;
                if (Cd(r, s, o) >= 0) return !1;
                const a = r.x < s.x ? r.x < o.x ? r.x : o.x : s.x < o.x ? s.x : o.x,
                    l = r.y < s.y ? r.y < o.y ? r.y : o.y : s.y < o.y ? s.y : o.y,
                    c = r.x > s.x ? r.x > o.x ? r.x : o.x : s.x > o.x ? s.x : o.x,
                    u = r.y > s.y ? r.y > o.y ? r.y : o.y : s.y > o.y ? s.y : o.y,
                    h = Ed(a, l, e, n, i),
                    d = Ed(c, u, e, n, i);
                let p = t.prevZ,
                    f = t.nextZ;
                for (; p && p.z >= h && f && f.z <= d;) {
                    if (p !== t.prev && p !== t.next && Td(r.x, r.y, s.x, s.y, o.x, o.y, p.x, p.y) && Cd(p.prev, p, p.next) >= 0) return !1;
                    if (p = p.prevZ, f !== t.prev && f !== t.next && Td(r.x, r.y, s.x, s.y, o.x, o.y, f.x, f.y) && Cd(f.prev, f, f.next) >= 0) return !1;
                    f = f.nextZ
                }
                for (; p && p.z >= h;) {
                    if (p !== t.prev && p !== t.next && Td(r.x, r.y, s.x, s.y, o.x, o.y, p.x, p.y) && Cd(p.prev, p, p.next) >= 0) return !1;
                    p = p.prevZ
                }
                for (; f && f.z <= d;) {
                    if (f !== t.prev && f !== t.next && Td(r.x, r.y, s.x, s.y, o.x, o.y, f.x, f.y) && Cd(f.prev, f, f.next) >= 0) return !1;
                    f = f.nextZ
                }
                return !0
            }

            function _d(t, e, n) {
                let i = t;
                do {
                    const r = i.prev,
                        s = i.next.next;
                    !Ld(r, s) && Rd(r, i, i.next, s) && Od(r, s) && Od(s, r) && (e.push(r.i / n), e.push(i.i / n), e.push(s.i / n), Bd(i), Bd(i.next), i = t = s), i = i.next
                } while (i !== t);
                return gd(i)
            }

            function bd(t, e, n, i, r, s) {
                let o = t;
                do {
                    let t = o.next.next;
                    for (; t !== o.prev;) {
                        if (o.i !== t.i && Ad(o, t)) {
                            let a = Id(o, t);
                            return o = gd(o, o.next), a = gd(a, a.next), vd(o, e, n, i, r, s), void vd(a, e, n, i, r, s)
                        }
                        t = t.next
                    }
                    o = o.next
                } while (o !== t)
            }

            function wd(t, e) {
                return t.x - e.x
            }

            function Md(t, e) {
                if (e = function(t, e) {
                        let n = e;
                        const i = t.x,
                            r = t.y;
                        let s, o = -1 / 0;
                        do {
                            if (r <= n.y && r >= n.next.y && n.next.y !== n.y) {
                                const t = n.x + (r - n.y) * (n.next.x - n.x) / (n.next.y - n.y);
                                if (t <= i && t > o) {
                                    if (o = t, t === i) {
                                        if (r === n.y) return n;
                                        if (r === n.next.y) return n.next
                                    }
                                    s = n.x < n.next.x ? n : n.next
                                }
                            }
                            n = n.next
                        } while (n !== e);
                        if (!s) return null;
                        if (i === o) return s;
                        const a = s,
                            l = s.x,
                            c = s.y;
                        let u, h = 1 / 0;
                        n = s;
                        do {
                            i >= n.x && n.x >= l && i !== n.x && Td(r < c ? i : o, r, l, c, r < c ? o : i, r, n.x, n.y) && (u = Math.abs(r - n.y) / (i - n.x), Od(n, t) && (u < h || u === h && (n.x > s.x || n.x === s.x && Sd(s, n))) && (s = n, h = u)), n = n.next
                        } while (n !== a);
                        return s
                    }(t, e)) {
                    const n = Id(e, t);
                    gd(e, e.next), gd(n, n.next)
                }
            }

            function Sd(t, e) {
                return Cd(t.prev, t, e.prev) < 0 && Cd(e.next, t, t.next) < 0
            }

            function Ed(t, e, n, i, r) {
                return (t = 1431655765 & ((t = 858993459 & ((t = 252645135 & ((t = 16711935 & ((t = 32767 * (t - n) * r) | t << 8)) | t << 4)) | t << 2)) | t << 1)) | (e = 1431655765 & ((e = 858993459 & ((e = 252645135 & ((e = 16711935 & ((e = 32767 * (e - i) * r) | e << 8)) | e << 4)) | e << 2)) | e << 1)) << 1
            }

            function Dd(t) {
                let e = t,
                    n = t;
                do {
                    (e.x < n.x || e.x === n.x && e.y < n.y) && (n = e), e = e.next
                } while (e !== t);
                return n
            }

            function Td(t, e, n, i, r, s, o, a) {
                return (r - o) * (e - a) - (t - o) * (s - a) >= 0 && (t - o) * (i - a) - (n - o) * (e - a) >= 0 && (n - o) * (s - a) - (r - o) * (i - a) >= 0
            }

            function Ad(t, e) {
                return t.next.i !== e.i && t.prev.i !== e.i && ! function(t, e) {
                    let n = t;
                    do {
                        if (n.i !== t.i && n.next.i !== t.i && n.i !== e.i && n.next.i !== e.i && Rd(n, n.next, t, e)) return !0;
                        n = n.next
                    } while (n !== t);
                    return !1
                }(t, e) && (Od(t, e) && Od(e, t) && function(t, e) {
                    let n = t,
                        i = !1;
                    const r = (t.x + e.x) / 2,
                        s = (t.y + e.y) / 2;
                    do {
                        n.y > s != n.next.y > s && n.next.y !== n.y && r < (n.next.x - n.x) * (s - n.y) / (n.next.y - n.y) + n.x && (i = !i), n = n.next
                    } while (n !== t);
                    return i
                }(t, e) && (Cd(t.prev, t, e.prev) || Cd(t, e.prev, e)) || Ld(t, e) && Cd(t.prev, t, t.next) > 0 && Cd(e.prev, e, e.next) > 0)
            }

            function Cd(t, e, n) {
                return (e.y - t.y) * (n.x - e.x) - (e.x - t.x) * (n.y - e.y)
            }

            function Ld(t, e) {
                return t.x === e.x && t.y === e.y
            }

            function Rd(t, e, n, i) {
                const r = Fd(Cd(t, e, n)),
                    s = Fd(Cd(t, e, i)),
                    o = Fd(Cd(n, i, t)),
                    a = Fd(Cd(n, i, e));
                return r !== s && o !== a || (!(0 !== r || !Pd(t, n, e)) || (!(0 !== s || !Pd(t, i, e)) || (!(0 !== o || !Pd(n, t, i)) || !(0 !== a || !Pd(n, e, i)))))
            }

            function Pd(t, e, n) {
                return e.x <= Math.max(t.x, n.x) && e.x >= Math.min(t.x, n.x) && e.y <= Math.max(t.y, n.y) && e.y >= Math.min(t.y, n.y)
            }

            function Fd(t) {
                return t > 0 ? 1 : t < 0 ? -1 : 0
            }

            function Od(t, e) {
                return Cd(t.prev, t, t.next) < 0 ? Cd(t, e, t.next) >= 0 && Cd(t, t.prev, e) >= 0 : Cd(t, e, t.prev) < 0 || Cd(t, t.next, e) < 0
            }

            function Id(t, e) {
                const n = new zd(t.i, t.x, t.y),
                    i = new zd(e.i, e.x, e.y),
                    r = t.next,
                    s = e.prev;
                return t.next = e, e.prev = t, n.next = r, r.prev = n, i.next = n, n.prev = i, s.next = i, i.prev = s, i
            }

            function Nd(t, e, n, i) {
                const r = new zd(t, e, n);
                return i ? (r.next = i.next, r.prev = i, i.next.prev = r, i.next = r) : (r.prev = r, r.next = r), r
            }

            function Bd(t) {
                t.next.prev = t.prev, t.prev.next = t.next, t.prevZ && (t.prevZ.nextZ = t.nextZ), t.nextZ && (t.nextZ.prevZ = t.prevZ)
            }

            function zd(t, e, n) {
                this.i = t, this.x = e, this.y = n, this.prev = null, this.next = null, this.z = null, this.prevZ = null, this.nextZ = null, this.steiner = !1
            }
            const kd = {
                area: function(t) {
                    const e = t.length;
                    let n = 0;
                    for (let i = e - 1, r = 0; r < e; i = r++) n += t[i].x * t[r].y - t[r].x * t[i].y;
                    return .5 * n
                },
                isClockWise: function(t) {
                    return kd.area(t) < 0
                },
                triangulateShape: function(t, e) {
                    const n = [],
                        i = [],
                        r = [];
                    Hd(t), Ud(n, t);
                    let s = t.length;
                    e.forEach(Hd);
                    for (let t = 0; t < e.length; t++) i.push(s), s += e[t].length, Ud(n, e[t]);
                    const o = fd(n, i);
                    for (let t = 0; t < o.length; t += 3) r.push(o.slice(t, t + 3));
                    return r
                }
            };

            function Hd(t) {
                const e = t.length;
                e > 2 && t[e - 1].equals(t[0]) && t.pop()
            }

            function Ud(t, e) {
                for (let n = 0; n < e.length; n++) t.push(e[n].x), t.push(e[n].y)
            }
            class Gd extends _l {
                constructor(t, e) {
                    super(), this.type = "ExtrudeGeometry", this.parameters = {
                        shapes: t,
                        options: e
                    }, t = Array.isArray(t) ? t : [t];
                    const n = this,
                        i = [],
                        r = [];
                    for (let e = 0, n = t.length; e < n; e++) {
                        s(t[e])
                    }

                    function s(t) {
                        const s = [],
                            o = void 0 !== e.curveSegments ? e.curveSegments : 12,
                            a = void 0 !== e.steps ? e.steps : 1;
                        let l = void 0 !== e.depth ? e.depth : 100,
                            c = void 0 === e.bevelEnabled || e.bevelEnabled,
                            u = void 0 !== e.bevelThickness ? e.bevelThickness : 6,
                            h = void 0 !== e.bevelSize ? e.bevelSize : u - 2,
                            d = void 0 !== e.bevelOffset ? e.bevelOffset : 0,
                            p = void 0 !== e.bevelSegments ? e.bevelSegments : 3;
                        const f = e.extrudePath,
                            m = void 0 !== e.UVGenerator ? e.UVGenerator : Wd;
                        void 0 !== e.amount && (console.warn("THREE.ExtrudeBufferGeometry: amount has been renamed to depth."), l = e.amount);
                        let g, v, y, x, _, b = !1;
                        f && (g = f.getSpacedPoints(a), b = !0, c = !1, v = f.computeFrenetFrames(a, !1), y = new Ao, x = new Ao, _ = new Ao), c || (p = 0, u = 0, h = 0, d = 0);
                        const w = t.extractPoints(o);
                        let M = w.shape;
                        const S = w.holes;
                        if (!kd.isClockWise(M)) {
                            M = M.reverse();
                            for (let t = 0, e = S.length; t < e; t++) {
                                const e = S[t];
                                kd.isClockWise(e) && (S[t] = e.reverse())
                            }
                        }
                        const E = kd.triangulateShape(M, S),
                            D = M;
                        for (let t = 0, e = S.length; t < e; t++) {
                            const e = S[t];
                            M = M.concat(e)
                        }

                        function T(t, e, n) {
                            return e || console.error("THREE.ExtrudeGeometry: vec does not exist"), e.clone().multiplyScalar(n).add(t)
                        }
                        const A = M.length,
                            C = E.length;

                        function L(t, e, n) {
                            let i, r, s;
                            const o = t.x - e.x,
                                a = t.y - e.y,
                                l = n.x - t.x,
                                c = n.y - t.y,
                                u = o * o + a * a,
                                h = o * c - a * l;
                            if (Math.abs(h) > Number.EPSILON) {
                                const h = Math.sqrt(u),
                                    d = Math.sqrt(l * l + c * c),
                                    p = e.x - a / h,
                                    f = e.y + o / h,
                                    m = ((n.x - c / d - p) * c - (n.y + l / d - f) * l) / (o * c - a * l);
                                i = p + o * m - t.x, r = f + a * m - t.y;
                                const g = i * i + r * r;
                                if (g <= 2) return new yo(i, r);
                                s = Math.sqrt(g / 2)
                            } else {
                                let t = !1;
                                o > Number.EPSILON ? l > Number.EPSILON && (t = !0) : o < -Number.EPSILON ? l < -Number.EPSILON && (t = !0) : Math.sign(a) === Math.sign(c) && (t = !0), t ? (i = -a, r = o, s = Math.sqrt(u)) : (i = o, r = a, s = Math.sqrt(u / 2))
                            }
                            return new yo(i / s, r / s)
                        }
                        const R = [];
                        for (let t = 0, e = D.length, n = e - 1, i = t + 1; t < e; t++, n++, i++) n === e && (n = 0), i === e && (i = 0), R[t] = L(D[t], D[n], D[i]);
                        const P = [];
                        let F, O = R.concat();
                        for (let t = 0, e = S.length; t < e; t++) {
                            const e = S[t];
                            F = [];
                            for (let t = 0, n = e.length, i = n - 1, r = t + 1; t < n; t++, i++, r++) i === n && (i = 0), r === n && (r = 0), F[t] = L(e[t], e[i], e[r]);
                            P.push(F), O = O.concat(F)
                        }
                        for (let t = 0; t < p; t++) {
                            const e = t / p,
                                n = u * Math.cos(e * Math.PI / 2),
                                i = h * Math.sin(e * Math.PI / 2) + d;
                            for (let t = 0, e = D.length; t < e; t++) {
                                const e = T(D[t], R[t], i);
                                B(e.x, e.y, -n)
                            }
                            for (let t = 0, e = S.length; t < e; t++) {
                                const e = S[t];
                                F = P[t];
                                for (let t = 0, r = e.length; t < r; t++) {
                                    const r = T(e[t], F[t], i);
                                    B(r.x, r.y, -n)
                                }
                            }
                        }
                        const I = h + d;
                        for (let t = 0; t < A; t++) {
                            const e = c ? T(M[t], O[t], I) : M[t];
                            b ? (x.copy(v.normals[0]).multiplyScalar(e.x), y.copy(v.binormals[0]).multiplyScalar(e.y), _.copy(g[0]).add(x).add(y), B(_.x, _.y, _.z)) : B(e.x, e.y, 0)
                        }
                        for (let t = 1; t <= a; t++)
                            for (let e = 0; e < A; e++) {
                                const n = c ? T(M[e], O[e], I) : M[e];
                                b ? (x.copy(v.normals[t]).multiplyScalar(n.x), y.copy(v.binormals[t]).multiplyScalar(n.y), _.copy(g[t]).add(x).add(y), B(_.x, _.y, _.z)) : B(n.x, n.y, l / a * t)
                            }
                        for (let t = p - 1; t >= 0; t--) {
                            const e = t / p,
                                n = u * Math.cos(e * Math.PI / 2),
                                i = h * Math.sin(e * Math.PI / 2) + d;
                            for (let t = 0, e = D.length; t < e; t++) {
                                const e = T(D[t], R[t], i);
                                B(e.x, e.y, l + n)
                            }
                            for (let t = 0, e = S.length; t < e; t++) {
                                const e = S[t];
                                F = P[t];
                                for (let t = 0, r = e.length; t < r; t++) {
                                    const r = T(e[t], F[t], i);
                                    b ? B(r.x, r.y + g[a - 1].y, g[a - 1].x + n) : B(r.x, r.y, l + n)
                                }
                            }
                        }

                        function N(t, e) {
                            let n = t.length;
                            for (; --n >= 0;) {
                                const i = n;
                                let r = n - 1;
                                r < 0 && (r = t.length - 1);
                                for (let t = 0, n = a + 2 * p; t < n; t++) {
                                    const n = A * t,
                                        s = A * (t + 1);
                                    k(e + i + n, e + r + n, e + r + s, e + i + s)
                                }
                            }
                        }

                        function B(t, e, n) {
                            s.push(t), s.push(e), s.push(n)
                        }

                        function z(t, e, r) {
                            H(t), H(e), H(r);
                            const s = i.length / 3,
                                o = m.generateTopUV(n, i, s - 3, s - 2, s - 1);
                            U(o[0]), U(o[1]), U(o[2])
                        }

                        function k(t, e, r, s) {
                            H(t), H(e), H(s), H(e), H(r), H(s);
                            const o = i.length / 3,
                                a = m.generateSideWallUV(n, i, o - 6, o - 3, o - 2, o - 1);
                            U(a[0]), U(a[1]), U(a[3]), U(a[1]), U(a[2]), U(a[3])
                        }

                        function H(t) {
                            i.push(s[3 * t + 0]), i.push(s[3 * t + 1]), i.push(s[3 * t + 2])
                        }

                        function U(t) {
                            r.push(t.x), r.push(t.y)
                        }! function() {
                            const t = i.length / 3;
                            if (c) {
                                let t = 0,
                                    e = A * t;
                                for (let t = 0; t < C; t++) {
                                    const n = E[t];
                                    z(n[2] + e, n[1] + e, n[0] + e)
                                }
                                t = a + 2 * p, e = A * t;
                                for (let t = 0; t < C; t++) {
                                    const n = E[t];
                                    z(n[0] + e, n[1] + e, n[2] + e)
                                }
                            } else {
                                for (let t = 0; t < C; t++) {
                                    const e = E[t];
                                    z(e[2], e[1], e[0])
                                }
                                for (let t = 0; t < C; t++) {
                                    const e = E[t];
                                    z(e[0] + A * a, e[1] + A * a, e[2] + A * a)
                                }
                            }
                            n.addGroup(t, i.length / 3 - t, 0)
                        }(),
                        function() {
                            const t = i.length / 3;
                            let e = 0;
                            N(D, e), e += D.length;
                            for (let t = 0, n = S.length; t < n; t++) {
                                const n = S[t];
                                N(n, e), e += n.length
                            }
                            n.addGroup(t, i.length / 3 - t, 1)
                        }()
                    }
                    this.setAttribute("position", new ul(i, 3)), this.setAttribute("uv", new ul(r, 2)), this.computeVertexNormals()
                }
                toJSON() {
                    const t = _l.prototype.toJSON.call(this);
                    return function(t, e, n) {
                        if (n.shapes = [], Array.isArray(t))
                            for (let e = 0, i = t.length; e < i; e++) {
                                const i = t[e];
                                n.shapes.push(i.uuid)
                            } else n.shapes.push(t.uuid);
                        void 0 !== e.extrudePath && (n.options.extrudePath = e.extrudePath.toJSON());
                        return n
                    }(this.parameters.shapes, this.parameters.options, t)
                }
            }
            const Wd = {
                generateTopUV: function(t, e, n, i, r) {
                    const s = e[3 * n],
                        o = e[3 * n + 1],
                        a = e[3 * i],
                        l = e[3 * i + 1],
                        c = e[3 * r],
                        u = e[3 * r + 1];
                    return [new yo(s, o), new yo(a, l), new yo(c, u)]
                },
                generateSideWallUV: function(t, e, n, i, r, s) {
                    const o = e[3 * n],
                        a = e[3 * n + 1],
                        l = e[3 * n + 2],
                        c = e[3 * i],
                        u = e[3 * i + 1],
                        h = e[3 * i + 2],
                        d = e[3 * r],
                        p = e[3 * r + 1],
                        f = e[3 * r + 2],
                        m = e[3 * s],
                        g = e[3 * s + 1],
                        v = e[3 * s + 2];
                    return Math.abs(a - u) < .01 ? [new yo(o, 1 - l), new yo(c, 1 - h), new yo(d, 1 - f), new yo(m, 1 - v)] : [new yo(a, 1 - l), new yo(u, 1 - h), new yo(p, 1 - f), new yo(g, 1 - v)]
                }
            };

            function Vd(t, e, n) {
                _l.call(this), this.type = "ParametricGeometry", this.parameters = {
                    func: t,
                    slices: e,
                    stacks: n
                };
                const i = [],
                    r = [],
                    s = [],
                    o = [],
                    a = 1e-5,
                    l = new Ao,
                    c = new Ao,
                    u = new Ao,
                    h = new Ao,
                    d = new Ao;
                t.length < 3 && console.error("THREE.ParametricGeometry: Function must now modify a Vector3 as third parameter.");
                const p = e + 1;
                for (let i = 0; i <= n; i++) {
                    const p = i / n;
                    for (let n = 0; n <= e; n++) {
                        const i = n / e;
                        t(i, p, c), r.push(c.x, c.y, c.z), i - a >= 0 ? (t(i - a, p, u), h.subVectors(c, u)) : (t(i + a, p, u), h.subVectors(u, c)), p - a >= 0 ? (t(i, p - a, u), d.subVectors(c, u)) : (t(i, p + a, u), d.subVectors(u, c)), l.crossVectors(h, d).normalize(), s.push(l.x, l.y, l.z), o.push(i, p)
                    }
                }
                for (let t = 0; t < n; t++)
                    for (let n = 0; n < e; n++) {
                        const e = t * p + n,
                            r = t * p + n + 1,
                            s = (t + 1) * p + n + 1,
                            o = (t + 1) * p + n;
                        i.push(e, r, o), i.push(r, s, o)
                    }
                this.setIndex(i), this.setAttribute("position", new ul(r, 3)), this.setAttribute("normal", new ul(s, 3)), this.setAttribute("uv", new ul(o, 2))
            }
            Vd.prototype = Object.create(_l.prototype), Vd.prototype.constructor = Vd;
            class jd extends _l {
                constructor(t, e = 12) {
                    super(), this.type = "ShapeGeometry", this.parameters = {
                        shapes: t,
                        curveSegments: e
                    };
                    const n = [],
                        i = [],
                        r = [],
                        s = [];
                    let o = 0,
                        a = 0;
                    if (!1 === Array.isArray(t)) l(t);
                    else
                        for (let e = 0; e < t.length; e++) l(t[e]), this.addGroup(o, a, e), o += a, a = 0;

                    function l(t) {
                        const o = i.length / 3,
                            l = t.extractPoints(e);
                        let c = l.shape;
                        const u = l.holes;
                        !1 === kd.isClockWise(c) && (c = c.reverse());
                        for (let t = 0, e = u.length; t < e; t++) {
                            const e = u[t];
                            !0 === kd.isClockWise(e) && (u[t] = e.reverse())
                        }
                        const h = kd.triangulateShape(c, u);
                        for (let t = 0, e = u.length; t < e; t++) {
                            const e = u[t];
                            c = c.concat(e)
                        }
                        for (let t = 0, e = c.length; t < e; t++) {
                            const e = c[t];
                            i.push(e.x, e.y, 0), r.push(0, 0, 1), s.push(e.x, e.y)
                        }
                        for (let t = 0, e = h.length; t < e; t++) {
                            const e = h[t],
                                i = e[0] + o,
                                r = e[1] + o,
                                s = e[2] + o;
                            n.push(i, r, s), a += 3
                        }
                    }
                    this.setIndex(n), this.setAttribute("position", new ul(i, 3)), this.setAttribute("normal", new ul(r, 3)), this.setAttribute("uv", new ul(s, 2))
                }
                toJSON() {
                    const t = _l.prototype.toJSON.call(this);
                    return function(t, e) {
                        if (e.shapes = [], Array.isArray(t))
                            for (let n = 0, i = t.length; n < i; n++) {
                                const i = t[n];
                                e.shapes.push(i.uuid)
                            } else e.shapes.push(t.uuid);
                        return e
                    }(this.parameters.shapes, t)
                }
            }
            class qd extends Va {
                constructor(t) {
                    super(), this.type = "ShadowMaterial", this.color = new Qa(0), this.transparent = !0, this.setValues(t)
                }
                copy(t) {
                    return super.copy(t), this.color.copy(t.color), this
                }
            }
            qd.prototype.isShadowMaterial = !0;
            class Xd extends Vl {
                constructor(t) {
                    super(t), this.type = "RawShaderMaterial"
                }
            }

            function Yd(t) {
                Va.call(this), this.defines = {
                    STANDARD: ""
                }, this.type = "MeshStandardMaterial", this.color = new Qa(16777215), this.roughness = 1, this.metalness = 0, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Qa(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new yo(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.roughnessMap = null, this.metalnessMap = null, this.alphaMap = null, this.envMap = null, this.envMapIntensity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.flatShading = !1, this.vertexTangents = !1, this.setValues(t)
            }

            function Zd(t) {
                Yd.call(this), this.defines = {
                    STANDARD: "",
                    PHYSICAL: ""
                }, this.type = "MeshPhysicalMaterial", this.clearcoat = 0, this.clearcoatMap = null, this.clearcoatRoughness = 0, this.clearcoatRoughnessMap = null, this.clearcoatNormalScale = new yo(1, 1), this.clearcoatNormalMap = null, this.reflectivity = .5, Object.defineProperty(this, "ior", {
                    get: function() {
                        return (1 + .4 * this.reflectivity) / (1 - .4 * this.reflectivity)
                    },
                    set: function(t) {
                        this.reflectivity = vo.clamp(2.5 * (t - 1) / (t + 1), 0, 1)
                    }
                }), this.sheen = null, this.transmission = 0, this.transmissionMap = null, this.setValues(t)
            }
            Xd.prototype.isRawShaderMaterial = !0, Yd.prototype = Object.create(Va.prototype), Yd.prototype.constructor = Yd, Yd.prototype.isMeshStandardMaterial = !0, Yd.prototype.copy = function(t) {
                return Va.prototype.copy.call(this, t), this.defines = {
                    STANDARD: ""
                }, this.color.copy(t.color), this.roughness = t.roughness, this.metalness = t.metalness, this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.roughnessMap = t.roughnessMap, this.metalnessMap = t.metalnessMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.envMapIntensity = t.envMapIntensity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this.flatShading = t.flatShading, this.vertexTangents = t.vertexTangents, this
            }, Zd.prototype = Object.create(Yd.prototype), Zd.prototype.constructor = Zd, Zd.prototype.isMeshPhysicalMaterial = !0, Zd.prototype.copy = function(t) {
                return Yd.prototype.copy.call(this, t), this.defines = {
                    STANDARD: "",
                    PHYSICAL: ""
                }, this.clearcoat = t.clearcoat, this.clearcoatMap = t.clearcoatMap, this.clearcoatRoughness = t.clearcoatRoughness, this.clearcoatRoughnessMap = t.clearcoatRoughnessMap, this.clearcoatNormalMap = t.clearcoatNormalMap, this.clearcoatNormalScale.copy(t.clearcoatNormalScale), this.reflectivity = t.reflectivity, t.sheen ? this.sheen = (this.sheen || new Qa).copy(t.sheen) : this.sheen = null, this.transmission = t.transmission, this.transmissionMap = t.transmissionMap, this
            };
            class Jd extends Va {
                constructor(t) {
                    super(), this.type = "MeshPhongMaterial", this.color = new Qa(16777215), this.specular = new Qa(1118481), this.shininess = 30, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Qa(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new yo(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = 0, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.flatShading = !1, this.setValues(t)
                }
                copy(t) {
                    return super.copy(t), this.color.copy(t.color), this.specular.copy(t.specular), this.shininess = t.shininess, this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this.flatShading = t.flatShading, this
                }
            }
            Jd.prototype.isMeshPhongMaterial = !0;
            class Qd extends Va {
                constructor(t) {
                    super(), this.defines = {
                        TOON: ""
                    }, this.type = "MeshToonMaterial", this.color = new Qa(16777215), this.map = null, this.gradientMap = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Qa(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new yo(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(t)
                }
                copy(t) {
                    return super.copy(t), this.color.copy(t.color), this.map = t.map, this.gradientMap = t.gradientMap, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.alphaMap = t.alphaMap, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this
                }
            }
            Qd.prototype.isMeshToonMaterial = !0;
            class Kd extends Va {
                constructor(t) {
                    super(), this.type = "MeshNormalMaterial", this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new yo(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.flatShading = !1, this.setValues(t)
                }
                copy(t) {
                    return super.copy(t), this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this.flatShading = t.flatShading, this
                }
            }
            Kd.prototype.isMeshNormalMaterial = !0;
            class $d extends Va {
                constructor(t) {
                    super(), this.type = "MeshLambertMaterial", this.color = new Qa(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Qa(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = 0, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(t)
                }
                copy(t) {
                    return super.copy(t), this.color.copy(t.color), this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this
                }
            }
            $d.prototype.isMeshLambertMaterial = !0;
            class tp extends Va {
                constructor(t) {
                    super(), this.defines = {
                        MATCAP: ""
                    }, this.type = "MeshMatcapMaterial", this.color = new Qa(16777215), this.matcap = null, this.map = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new yo(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.flatShading = !1, this.setValues(t)
                }
                copy(t) {
                    return super.copy(t), this.defines = {
                        MATCAP: ""
                    }, this.color.copy(t.color), this.matcap = t.matcap, this.map = t.map, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.alphaMap = t.alphaMap, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this.flatShading = t.flatShading, this
                }
            }
            tp.prototype.isMeshMatcapMaterial = !0;
            class ep extends Yh {
                constructor(t) {
                    super(), this.type = "LineDashedMaterial", this.scale = 1, this.dashSize = 3, this.gapSize = 1, this.setValues(t)
                }
                copy(t) {
                    return super.copy(t), this.scale = t.scale, this.dashSize = t.dashSize, this.gapSize = t.gapSize, this
                }
            }
            ep.prototype.isLineDashedMaterial = !0;
            const np = {
                arraySlice: function(t, e, n) {
                    return np.isTypedArray(t) ? new t.constructor(t.subarray(e, void 0 !== n ? n : t.length)) : t.slice(e, n)
                },
                convertArray: function(t, e, n) {
                    return !t || !n && t.constructor === e ? t : "number" == typeof e.BYTES_PER_ELEMENT ? new e(t) : Array.prototype.slice.call(t)
                },
                isTypedArray: function(t) {
                    return ArrayBuffer.isView(t) && !(t instanceof DataView)
                },
                getKeyframeOrder: function(t) {
                    const e = t.length,
                        n = new Array(e);
                    for (let t = 0; t !== e; ++t) n[t] = t;
                    return n.sort((function(e, n) {
                        return t[e] - t[n]
                    })), n
                },
                sortedArray: function(t, e, n) {
                    const i = t.length,
                        r = new t.constructor(i);
                    for (let s = 0, o = 0; o !== i; ++s) {
                        const i = n[s] * e;
                        for (let n = 0; n !== e; ++n) r[o++] = t[i + n]
                    }
                    return r
                },
                flattenJSON: function(t, e, n, i) {
                    let r = 1,
                        s = t[0];
                    for (; void 0 !== s && void 0 === s[i];) s = t[r++];
                    if (void 0 === s) return;
                    let o = s[i];
                    if (void 0 !== o)
                        if (Array.isArray(o))
                            do {
                                o = s[i], void 0 !== o && (e.push(s.time), n.push.apply(n, o)), s = t[r++]
                            } while (void 0 !== s);
                        else if (void 0 !== o.toArray)
                        do {
                            o = s[i], void 0 !== o && (e.push(s.time), o.toArray(n, n.length)), s = t[r++]
                        } while (void 0 !== s);
                    else
                        do {
                            o = s[i], void 0 !== o && (e.push(s.time), n.push(o)), s = t[r++]
                        } while (void 0 !== s)
                },
                subclip: function(t, e, n, i, r = 30) {
                    const s = t.clone();
                    s.name = e;
                    const o = [];
                    for (let t = 0; t < s.tracks.length; ++t) {
                        const e = s.tracks[t],
                            a = e.getValueSize(),
                            l = [],
                            c = [];
                        for (let t = 0; t < e.times.length; ++t) {
                            const s = e.times[t] * r;
                            if (!(s < n || s >= i)) {
                                l.push(e.times[t]);
                                for (let n = 0; n < a; ++n) c.push(e.values[t * a + n])
                            }
                        }
                        0 !== l.length && (e.times = np.convertArray(l, e.times.constructor), e.values = np.convertArray(c, e.values.constructor), o.push(e))
                    }
                    s.tracks = o;
                    let a = 1 / 0;
                    for (let t = 0; t < s.tracks.length; ++t) a > s.tracks[t].times[0] && (a = s.tracks[t].times[0]);
                    for (let t = 0; t < s.tracks.length; ++t) s.tracks[t].shift(-1 * a);
                    return s.resetDuration(), s
                },
                makeClipAdditive: function(t, e = 0, n = t, i = 30) {
                    i <= 0 && (i = 30);
                    const r = n.tracks.length,
                        s = e / i;
                    for (let e = 0; e < r; ++e) {
                        const i = n.tracks[e],
                            r = i.ValueTypeName;
                        if ("bool" === r || "string" === r) continue;
                        const o = t.tracks.find((function(t) {
                            return t.name === i.name && t.ValueTypeName === r
                        }));
                        if (void 0 === o) continue;
                        let a = 0;
                        const l = i.getValueSize();
                        i.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (a = l / 3);
                        let c = 0;
                        const u = o.getValueSize();
                        o.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (c = u / 3);
                        const h = i.times.length - 1;
                        let d;
                        if (s <= i.times[0]) {
                            const t = a,
                                e = l - a;
                            d = np.arraySlice(i.values, t, e)
                        } else if (s >= i.times[h]) {
                            const t = h * l + a,
                                e = t + l - a;
                            d = np.arraySlice(i.values, t, e)
                        } else {
                            const t = i.createInterpolant(),
                                e = a,
                                n = l - a;
                            t.evaluate(s), d = np.arraySlice(t.resultBuffer, e, n)
                        }
                        if ("quaternion" === r) {
                            (new To).fromArray(d).normalize().conjugate().toArray(d)
                        }
                        const p = o.times.length;
                        for (let t = 0; t < p; ++t) {
                            const e = t * u + c;
                            if ("quaternion" === r) To.multiplyQuaternionsFlat(o.values, e, d, 0, o.values, e);
                            else {
                                const t = u - 2 * c;
                                for (let n = 0; n < t; ++n) o.values[e + n] -= d[n]
                            }
                        }
                    }
                    return t.blendMode = 2501, t
                }
            };

            function ip(t, e, n, i) {
                this.parameterPositions = t, this._cachedIndex = 0, this.resultBuffer = void 0 !== i ? i : new e.constructor(n), this.sampleValues = e, this.valueSize = n
            }

            function rp(t, e, n, i) {
                ip.call(this, t, e, n, i), this._weightPrev = -0, this._offsetPrev = -0, this._weightNext = -0, this._offsetNext = -0
            }

            function sp(t, e, n, i) {
                ip.call(this, t, e, n, i)
            }

            function op(t, e, n, i) {
                ip.call(this, t, e, n, i)
            }
            Object.assign(ip.prototype, {
                evaluate: function(t) {
                    const e = this.parameterPositions;
                    let n = this._cachedIndex,
                        i = e[n],
                        r = e[n - 1];
                    t: {
                        e: {
                            let s;n: {
                                i: if (!(t < i)) {
                                    for (let s = n + 2;;) {
                                        if (void 0 === i) {
                                            if (t < r) break i;
                                            return n = e.length, this._cachedIndex = n, this.afterEnd_(n - 1, t, r)
                                        }
                                        if (n === s) break;
                                        if (r = i, i = e[++n], t < i) break e
                                    }
                                    s = e.length;
                                    break n
                                }if (t >= r) break t; {
                                    const o = e[1];
                                    t < o && (n = 2, r = o);
                                    for (let s = n - 2;;) {
                                        if (void 0 === r) return this._cachedIndex = 0, this.beforeStart_(0, t, i);
                                        if (n === s) break;
                                        if (i = r, r = e[--n - 1], t >= r) break e
                                    }
                                    s = n, n = 0
                                }
                            }
                            for (; n < s;) {
                                const i = n + s >>> 1;
                                t < e[i] ? s = i : n = i + 1
                            }
                            if (i = e[n], r = e[n - 1], void 0 === r) return this._cachedIndex = 0, this.beforeStart_(0, t, i);
                            if (void 0 === i) return n = e.length, this._cachedIndex = n, this.afterEnd_(n - 1, r, t)
                        }
                        this._cachedIndex = n,
                        this.intervalChanged_(n, r, i)
                    }
                    return this.interpolate_(n, r, t, i)
                },
                settings: null,
                DefaultSettings_: {},
                getSettings_: function() {
                    return this.settings || this.DefaultSettings_
                },
                copySampleValue_: function(t) {
                    const e = this.resultBuffer,
                        n = this.sampleValues,
                        i = this.valueSize,
                        r = t * i;
                    for (let t = 0; t !== i; ++t) e[t] = n[r + t];
                    return e
                },
                interpolate_: function() {
                    throw new Error("call to abstract method")
                },
                intervalChanged_: function() {}
            }), Object.assign(ip.prototype, {
                beforeStart_: ip.prototype.copySampleValue_,
                afterEnd_: ip.prototype.copySampleValue_
            }), rp.prototype = Object.assign(Object.create(ip.prototype), {
                constructor: rp,
                DefaultSettings_: {
                    endingStart: eo,
                    endingEnd: eo
                },
                intervalChanged_: function(t, e, n) {
                    const i = this.parameterPositions;
                    let r = t - 2,
                        s = t + 1,
                        o = i[r],
                        a = i[s];
                    if (void 0 === o) switch (this.getSettings_().endingStart) {
                        case no:
                            r = t, o = 2 * e - n;
                            break;
                        case io:
                            r = i.length - 2, o = e + i[r] - i[r + 1];
                            break;
                        default:
                            r = t, o = n
                    }
                    if (void 0 === a) switch (this.getSettings_().endingEnd) {
                        case no:
                            s = t, a = 2 * n - e;
                            break;
                        case io:
                            s = 1, a = n + i[1] - i[0];
                            break;
                        default:
                            s = t - 1, a = e
                    }
                    const l = .5 * (n - e),
                        c = this.valueSize;
                    this._weightPrev = l / (e - o), this._weightNext = l / (a - n), this._offsetPrev = r * c, this._offsetNext = s * c
                },
                interpolate_: function(t, e, n, i) {
                    const r = this.resultBuffer,
                        s = this.sampleValues,
                        o = this.valueSize,
                        a = t * o,
                        l = a - o,
                        c = this._offsetPrev,
                        u = this._offsetNext,
                        h = this._weightPrev,
                        d = this._weightNext,
                        p = (n - e) / (i - e),
                        f = p * p,
                        m = f * p,
                        g = -h * m + 2 * h * f - h * p,
                        v = (1 + h) * m + (-1.5 - 2 * h) * f + (-.5 + h) * p + 1,
                        y = (-1 - d) * m + (1.5 + d) * f + .5 * p,
                        x = d * m - d * f;
                    for (let t = 0; t !== o; ++t) r[t] = g * s[c + t] + v * s[l + t] + y * s[a + t] + x * s[u + t];
                    return r
                }
            }), sp.prototype = Object.assign(Object.create(ip.prototype), {
                constructor: sp,
                interpolate_: function(t, e, n, i) {
                    const r = this.resultBuffer,
                        s = this.sampleValues,
                        o = this.valueSize,
                        a = t * o,
                        l = a - o,
                        c = (n - e) / (i - e),
                        u = 1 - c;
                    for (let t = 0; t !== o; ++t) r[t] = s[l + t] * u + s[a + t] * c;
                    return r
                }
            }), op.prototype = Object.assign(Object.create(ip.prototype), {
                constructor: op,
                interpolate_: function(t) {
                    return this.copySampleValue_(t - 1)
                }
            });
            class ap {
                constructor(t, e, n, i) {
                    if (void 0 === t) throw new Error("THREE.KeyframeTrack: track name is undefined");
                    if (void 0 === e || 0 === e.length) throw new Error("THREE.KeyframeTrack: no keyframes in track named " + t);
                    this.name = t, this.times = np.convertArray(e, this.TimeBufferType), this.values = np.convertArray(n, this.ValueBufferType), this.setInterpolation(i || this.DefaultInterpolation)
                }
                static toJSON(t) {
                    const e = t.constructor;
                    let n;
                    if (e.toJSON !== this.toJSON) n = e.toJSON(t);
                    else {
                        n = {
                            name: t.name,
                            times: np.convertArray(t.times, Array),
                            values: np.convertArray(t.values, Array)
                        };
                        const e = t.getInterpolation();
                        e !== t.DefaultInterpolation && (n.interpolation = e)
                    }
                    return n.type = t.ValueTypeName, n
                }
                InterpolantFactoryMethodDiscrete(t) {
                    return new op(this.times, this.values, this.getValueSize(), t)
                }
                InterpolantFactoryMethodLinear(t) {
                    return new sp(this.times, this.values, this.getValueSize(), t)
                }
                InterpolantFactoryMethodSmooth(t) {
                    return new rp(this.times, this.values, this.getValueSize(), t)
                }
                setInterpolation(t) {
                    let e;
                    switch (t) {
                        case Ks:
                            e = this.InterpolantFactoryMethodDiscrete;
                            break;
                        case $s:
                            e = this.InterpolantFactoryMethodLinear;
                            break;
                        case to:
                            e = this.InterpolantFactoryMethodSmooth
                    }
                    if (void 0 === e) {
                        const e = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
                        if (void 0 === this.createInterpolant) {
                            if (t === this.DefaultInterpolation) throw new Error(e);
                            this.setInterpolation(this.DefaultInterpolation)
                        }
                        return console.warn("THREE.KeyframeTrack:", e), this
                    }
                    return this.createInterpolant = e, this
                }
                getInterpolation() {
                    switch (this.createInterpolant) {
                        case this.InterpolantFactoryMethodDiscrete:
                            return Ks;
                        case this.InterpolantFactoryMethodLinear:
                            return $s;
                        case this.InterpolantFactoryMethodSmooth:
                            return to
                    }
                }
                getValueSize() {
                    return this.values.length / this.times.length
                }
                shift(t) {
                    if (0 !== t) {
                        const e = this.times;
                        for (let n = 0, i = e.length; n !== i; ++n) e[n] += t
                    }
                    return this
                }
                scale(t) {
                    if (1 !== t) {
                        const e = this.times;
                        for (let n = 0, i = e.length; n !== i; ++n) e[n] *= t
                    }
                    return this
                }
                trim(t, e) {
                    const n = this.times,
                        i = n.length;
                    let r = 0,
                        s = i - 1;
                    for (; r !== i && n[r] < t;) ++r;
                    for (; - 1 !== s && n[s] > e;) --s;
                    if (++s, 0 !== r || s !== i) {
                        r >= s && (s = Math.max(s, 1), r = s - 1);
                        const t = this.getValueSize();
                        this.times = np.arraySlice(n, r, s), this.values = np.arraySlice(this.values, r * t, s * t)
                    }
                    return this
                }
                validate() {
                    let t = !0;
                    const e = this.getValueSize();
                    e - Math.floor(e) != 0 && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this), t = !1);
                    const n = this.times,
                        i = this.values,
                        r = n.length;
                    0 === r && (console.error("THREE.KeyframeTrack: Track is empty.", this), t = !1);
                    let s = null;
                    for (let e = 0; e !== r; e++) {
                        const i = n[e];
                        if ("number" == typeof i && isNaN(i)) {
                            console.error("THREE.KeyframeTrack: Time is not a valid number.", this, e, i), t = !1;
                            break
                        }
                        if (null !== s && s > i) {
                            console.error("THREE.KeyframeTrack: Out of order keys.", this, e, i, s), t = !1;
                            break
                        }
                        s = i
                    }
                    if (void 0 !== i && np.isTypedArray(i))
                        for (let e = 0, n = i.length; e !== n; ++e) {
                            const n = i[e];
                            if (isNaN(n)) {
                                console.error("THREE.KeyframeTrack: Value is not a valid number.", this, e, n), t = !1;
                                break
                            }
                        }
                    return t
                }
                optimize() {
                    const t = np.arraySlice(this.times),
                        e = np.arraySlice(this.values),
                        n = this.getValueSize(),
                        i = this.getInterpolation() === to,
                        r = t.length - 1;
                    let s = 1;
                    for (let o = 1; o < r; ++o) {
                        let r = !1;
                        const a = t[o];
                        if (a !== t[o + 1] && (1 !== o || a !== t[0]))
                            if (i) r = !0;
                            else {
                                const t = o * n,
                                    i = t - n,
                                    s = t + n;
                                for (let o = 0; o !== n; ++o) {
                                    const n = e[t + o];
                                    if (n !== e[i + o] || n !== e[s + o]) {
                                        r = !0;
                                        break
                                    }
                                }
                            }
                        if (r) {
                            if (o !== s) {
                                t[s] = t[o];
                                const i = o * n,
                                    r = s * n;
                                for (let t = 0; t !== n; ++t) e[r + t] = e[i + t]
                            }++s
                        }
                    }
                    if (r > 0) {
                        t[s] = t[r];
                        for (let t = r * n, i = s * n, o = 0; o !== n; ++o) e[i + o] = e[t + o];
                        ++s
                    }
                    return s !== t.length ? (this.times = np.arraySlice(t, 0, s), this.values = np.arraySlice(e, 0, s * n)) : (this.times = t, this.values = e), this
                }
                clone() {
                    const t = np.arraySlice(this.times, 0),
                        e = np.arraySlice(this.values, 0),
                        n = new(0, this.constructor)(this.name, t, e);
                    return n.createInterpolant = this.createInterpolant, n
                }
            }
            ap.prototype.TimeBufferType = Float32Array, ap.prototype.ValueBufferType = Float32Array, ap.prototype.DefaultInterpolation = $s;
            class lp extends ap {}
            lp.prototype.ValueTypeName = "bool", lp.prototype.ValueBufferType = Array, lp.prototype.DefaultInterpolation = Ks, lp.prototype.InterpolantFactoryMethodLinear = void 0, lp.prototype.InterpolantFactoryMethodSmooth = void 0;
            class cp extends ap {}
            cp.prototype.ValueTypeName = "color";
            class up extends ap {}

            function hp(t, e, n, i) {
                ip.call(this, t, e, n, i)
            }
            up.prototype.ValueTypeName = "number", hp.prototype = Object.assign(Object.create(ip.prototype), {
                constructor: hp,
                interpolate_: function(t, e, n, i) {
                    const r = this.resultBuffer,
                        s = this.sampleValues,
                        o = this.valueSize,
                        a = (n - e) / (i - e);
                    let l = t * o;
                    for (let t = l + o; l !== t; l += 4) To.slerpFlat(r, 0, s, l - o, s, l, a);
                    return r
                }
            });
            class dp extends ap {
                InterpolantFactoryMethodLinear(t) {
                    return new hp(this.times, this.values, this.getValueSize(), t)
                }
            }
            dp.prototype.ValueTypeName = "quaternion", dp.prototype.DefaultInterpolation = $s, dp.prototype.InterpolantFactoryMethodSmooth = void 0;
            class pp extends ap {}
            pp.prototype.ValueTypeName = "string", pp.prototype.ValueBufferType = Array, pp.prototype.DefaultInterpolation = Ks, pp.prototype.InterpolantFactoryMethodLinear = void 0, pp.prototype.InterpolantFactoryMethodSmooth = void 0;
            class fp extends ap {}
            fp.prototype.ValueTypeName = "vector";
            class mp {
                constructor(t, e = -1, n, i = 2500) {
                    this.name = t, this.tracks = n, this.duration = e, this.blendMode = i, this.uuid = vo.generateUUID(), this.duration < 0 && this.resetDuration()
                }
                static parse(t) {
                    const e = [],
                        n = t.tracks,
                        i = 1 / (t.fps || 1);
                    for (let t = 0, r = n.length; t !== r; ++t) e.push(gp(n[t]).scale(i));
                    const r = new this(t.name, t.duration, e, t.blendMode);
                    return r.uuid = t.uuid, r
                }
                static toJSON(t) {
                    const e = [],
                        n = t.tracks,
                        i = {
                            name: t.name,
                            duration: t.duration,
                            tracks: e,
                            uuid: t.uuid,
                            blendMode: t.blendMode
                        };
                    for (let t = 0, i = n.length; t !== i; ++t) e.push(ap.toJSON(n[t]));
                    return i
                }
                static CreateFromMorphTargetSequence(t, e, n, i) {
                    const r = e.length,
                        s = [];
                    for (let t = 0; t < r; t++) {
                        let o = [],
                            a = [];
                        o.push((t + r - 1) % r, t, (t + 1) % r), a.push(0, 1, 0);
                        const l = np.getKeyframeOrder(o);
                        o = np.sortedArray(o, 1, l), a = np.sortedArray(a, 1, l), i || 0 !== o[0] || (o.push(r), a.push(a[0])), s.push(new up(".morphTargetInfluences[" + e[t].name + "]", o, a).scale(1 / n))
                    }
                    return new this(t, -1, s)
                }
                static findByName(t, e) {
                    let n = t;
                    if (!Array.isArray(t)) {
                        const e = t;
                        n = e.geometry && e.geometry.animations || e.animations
                    }
                    for (let t = 0; t < n.length; t++)
                        if (n[t].name === e) return n[t];
                    return null
                }
                static CreateClipsFromMorphTargetSequences(t, e, n) {
                    const i = {},
                        r = /^([\w-]*?)([\d]+)$/;
                    for (let e = 0, n = t.length; e < n; e++) {
                        const n = t[e],
                            s = n.name.match(r);
                        if (s && s.length > 1) {
                            const t = s[1];
                            let e = i[t];
                            e || (i[t] = e = []), e.push(n)
                        }
                    }
                    const s = [];
                    for (const t in i) s.push(this.CreateFromMorphTargetSequence(t, i[t], e, n));
                    return s
                }
                static parseAnimation(t, e) {
                    if (!t) return console.error("THREE.AnimationClip: No animation in JSONLoader data."), null;
                    const n = function(t, e, n, i, r) {
                            if (0 !== n.length) {
                                const s = [],
                                    o = [];
                                np.flattenJSON(n, s, o, i), 0 !== s.length && r.push(new t(e, s, o))
                            }
                        },
                        i = [],
                        r = t.name || "default",
                        s = t.fps || 30,
                        o = t.blendMode;
                    let a = t.length || -1;
                    const l = t.hierarchy || [];
                    for (let t = 0; t < l.length; t++) {
                        const r = l[t].keys;
                        if (r && 0 !== r.length)
                            if (r[0].morphTargets) {
                                const t = {};
                                let e;
                                for (e = 0; e < r.length; e++)
                                    if (r[e].morphTargets)
                                        for (let n = 0; n < r[e].morphTargets.length; n++) t[r[e].morphTargets[n]] = -1;
                                for (const n in t) {
                                    const t = [],
                                        s = [];
                                    for (let i = 0; i !== r[e].morphTargets.length; ++i) {
                                        const i = r[e];
                                        t.push(i.time), s.push(i.morphTarget === n ? 1 : 0)
                                    }
                                    i.push(new up(".morphTargetInfluence[" + n + "]", t, s))
                                }
                                a = t.length * (s || 1)
                            } else {
                                const s = ".bones[" + e[t].name + "]";
                                n(fp, s + ".position", r, "pos", i), n(dp, s + ".quaternion", r, "rot", i), n(fp, s + ".scale", r, "scl", i)
                            }
                    }
                    if (0 === i.length) return null;
                    return new this(r, a, i, o)
                }
                resetDuration() {
                    let t = 0;
                    for (let e = 0, n = this.tracks.length; e !== n; ++e) {
                        const n = this.tracks[e];
                        t = Math.max(t, n.times[n.times.length - 1])
                    }
                    return this.duration = t, this
                }
                trim() {
                    for (let t = 0; t < this.tracks.length; t++) this.tracks[t].trim(0, this.duration);
                    return this
                }
                validate() {
                    let t = !0;
                    for (let e = 0; e < this.tracks.length; e++) t = t && this.tracks[e].validate();
                    return t
                }
                optimize() {
                    for (let t = 0; t < this.tracks.length; t++) this.tracks[t].optimize();
                    return this
                }
                clone() {
                    const t = [];
                    for (let e = 0; e < this.tracks.length; e++) t.push(this.tracks[e].clone());
                    return new this.constructor(this.name, this.duration, t, this.blendMode)
                }
                toJSON() {
                    return this.constructor.toJSON(this)
                }
            }

            function gp(t) {
                if (void 0 === t.type) throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
                const e = function(t) {
                    switch (t.toLowerCase()) {
                        case "scalar":
                        case "double":
                        case "float":
                        case "number":
                        case "integer":
                            return up;
                        case "vector":
                        case "vector2":
                        case "vector3":
                        case "vector4":
                            return fp;
                        case "color":
                            return cp;
                        case "quaternion":
                            return dp;
                        case "bool":
                        case "boolean":
                            return lp;
                        case "string":
                            return pp
                    }
                    throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + t)
                }(t.type);
                if (void 0 === t.times) {
                    const e = [],
                        n = [];
                    np.flattenJSON(t.keys, e, n, "value"), t.times = e, t.values = n
                }
                return void 0 !== e.parse ? e.parse(t) : new e(t.name, t.times, t.values, t.interpolation)
            }
            const vp = {
                enabled: !1,
                files: {},
                add: function(t, e) {
                    !1 !== this.enabled && (this.files[t] = e)
                },
                get: function(t) {
                    if (!1 !== this.enabled) return this.files[t]
                },
                remove: function(t) {
                    delete this.files[t]
                },
                clear: function() {
                    this.files = {}
                }
            };

            function yp(t, e, n) {
                const i = this;
                let r, s = !1,
                    o = 0,
                    a = 0;
                const l = [];
                this.onStart = void 0, this.onLoad = t, this.onProgress = e, this.onError = n, this.itemStart = function(t) {
                    a++, !1 === s && void 0 !== i.onStart && i.onStart(t, o, a), s = !0
                }, this.itemEnd = function(t) {
                    o++, void 0 !== i.onProgress && i.onProgress(t, o, a), o === a && (s = !1, void 0 !== i.onLoad && i.onLoad())
                }, this.itemError = function(t) {
                    void 0 !== i.onError && i.onError(t)
                }, this.resolveURL = function(t) {
                    return r ? r(t) : t
                }, this.setURLModifier = function(t) {
                    return r = t, this
                }, this.addHandler = function(t, e) {
                    return l.push(t, e), this
                }, this.removeHandler = function(t) {
                    const e = l.indexOf(t);
                    return -1 !== e && l.splice(e, 2), this
                }, this.getHandler = function(t) {
                    for (let e = 0, n = l.length; e < n; e += 2) {
                        const n = l[e],
                            i = l[e + 1];
                        if (n.global && (n.lastIndex = 0), n.test(t)) return i
                    }
                    return null
                }
            }
            const xp = new yp;

            function _p(t) {
                this.manager = void 0 !== t ? t : xp, this.crossOrigin = "anonymous", this.withCredentials = !1, this.path = "", this.resourcePath = "", this.requestHeader = {}
            }
            Object.assign(_p.prototype, {
                load: function() {},
                loadAsync: function(t, e) {
                    const n = this;
                    return new Promise((function(i, r) {
                        n.load(t, i, e, r)
                    }))
                },
                parse: function() {},
                setCrossOrigin: function(t) {
                    return this.crossOrigin = t, this
                },
                setWithCredentials: function(t) {
                    return this.withCredentials = t, this
                },
                setPath: function(t) {
                    return this.path = t, this
                },
                setResourcePath: function(t) {
                    return this.resourcePath = t, this
                },
                setRequestHeader: function(t) {
                    return this.requestHeader = t, this
                }
            });
            const bp = {};

            function wp(t) {
                _p.call(this, t)
            }
            wp.prototype = Object.assign(Object.create(_p.prototype), {
                constructor: wp,
                load: function(t, e, n, i) {
                    void 0 === t && (t = ""), void 0 !== this.path && (t = this.path + t), t = this.manager.resolveURL(t);
                    const r = this,
                        s = vp.get(t);
                    if (void 0 !== s) return r.manager.itemStart(t), setTimeout((function() {
                        e && e(s), r.manager.itemEnd(t)
                    }), 0), s;
                    if (void 0 !== bp[t]) return void bp[t].push({
                        onLoad: e,
                        onProgress: n,
                        onError: i
                    });
                    const o = t.match(/^data:(.*?)(;base64)?,(.*)$/);
                    let a;
                    if (o) {
                        const n = o[1],
                            s = !!o[2];
                        let a = o[3];
                        a = decodeURIComponent(a), s && (a = atob(a));
                        try {
                            let i;
                            const s = (this.responseType || "").toLowerCase();
                            switch (s) {
                                case "arraybuffer":
                                case "blob":
                                    const t = new Uint8Array(a.length);
                                    for (let e = 0; e < a.length; e++) t[e] = a.charCodeAt(e);
                                    i = "blob" === s ? new Blob([t.buffer], {
                                        type: n
                                    }) : t.buffer;
                                    break;
                                case "document":
                                    const e = new DOMParser;
                                    i = e.parseFromString(a, n);
                                    break;
                                case "json":
                                    i = JSON.parse(a);
                                    break;
                                default:
                                    i = a
                            }
                            setTimeout((function() {
                                e && e(i), r.manager.itemEnd(t)
                            }), 0)
                        } catch (e) {
                            setTimeout((function() {
                                i && i(e), r.manager.itemError(t), r.manager.itemEnd(t)
                            }), 0)
                        }
                    } else {
                        bp[t] = [], bp[t].push({
                            onLoad: e,
                            onProgress: n,
                            onError: i
                        }), a = new XMLHttpRequest, a.open("GET", t, !0), a.addEventListener("load", (function(e) {
                            const n = this.response,
                                i = bp[t];
                            if (delete bp[t], 200 === this.status || 0 === this.status) {
                                0 === this.status && console.warn("THREE.FileLoader: HTTP Status 0 received."), vp.add(t, n);
                                for (let t = 0, e = i.length; t < e; t++) {
                                    const e = i[t];
                                    e.onLoad && e.onLoad(n)
                                }
                                r.manager.itemEnd(t)
                            } else {
                                for (let t = 0, n = i.length; t < n; t++) {
                                    const n = i[t];
                                    n.onError && n.onError(e)
                                }
                                r.manager.itemError(t), r.manager.itemEnd(t)
                            }
                        }), !1), a.addEventListener("progress", (function(e) {
                            const n = bp[t];
                            for (let t = 0, i = n.length; t < i; t++) {
                                const i = n[t];
                                i.onProgress && i.onProgress(e)
                            }
                        }), !1), a.addEventListener("error", (function(e) {
                            const n = bp[t];
                            delete bp[t];
                            for (let t = 0, i = n.length; t < i; t++) {
                                const i = n[t];
                                i.onError && i.onError(e)
                            }
                            r.manager.itemError(t), r.manager.itemEnd(t)
                        }), !1), a.addEventListener("abort", (function(e) {
                            const n = bp[t];
                            delete bp[t];
                            for (let t = 0, i = n.length; t < i; t++) {
                                const i = n[t];
                                i.onError && i.onError(e)
                            }
                            r.manager.itemError(t), r.manager.itemEnd(t)
                        }), !1), void 0 !== this.responseType && (a.responseType = this.responseType), void 0 !== this.withCredentials && (a.withCredentials = this.withCredentials), a.overrideMimeType && a.overrideMimeType(void 0 !== this.mimeType ? this.mimeType : "text/plain");
                        for (const t in this.requestHeader) a.setRequestHeader(t, this.requestHeader[t]);
                        a.send(null)
                    }
                    return r.manager.itemStart(t), a
                },
                setResponseType: function(t) {
                    return this.responseType = t, this
                },
                setMimeType: function(t) {
                    return this.mimeType = t, this
                }
            });

            function Mp(t) {
                _p.call(this, t)
            }
            Mp.prototype = Object.assign(Object.create(_p.prototype), {
                constructor: Mp,
                load: function(t, e, n, i) {
                    const r = this,
                        s = [],
                        o = new dd,
                        a = new wp(this.manager);
                    a.setPath(this.path), a.setResponseType("arraybuffer"), a.setRequestHeader(this.requestHeader), a.setWithCredentials(r.withCredentials);
                    let l = 0;

                    function c(c) {
                        a.load(t[c], (function(t) {
                            const n = r.parse(t, !0);
                            s[c] = {
                                width: n.width,
                                height: n.height,
                                format: n.format,
                                mipmaps: n.mipmaps
                            }, l += 1, 6 === l && (1 === n.mipmapCount && (o.minFilter = Hs), o.image = s, o.format = n.format, o.needsUpdate = !0, e && e(o))
                        }), n, i)
                    }
                    if (Array.isArray(t))
                        for (let e = 0, n = t.length; e < n; ++e) c(e);
                    else a.load(t, (function(t) {
                        const n = r.parse(t, !0);
                        if (n.isCubemap) {
                            const t = n.mipmaps.length / n.mipmapCount;
                            for (let e = 0; e < t; e++) {
                                s[e] = {
                                    mipmaps: []
                                };
                                for (let t = 0; t < n.mipmapCount; t++) s[e].mipmaps.push(n.mipmaps[e * n.mipmapCount + t]), s[e].format = n.format, s[e].width = n.width, s[e].height = n.height
                            }
                            o.image = s
                        } else o.image.width = n.width, o.image.height = n.height, o.mipmaps = n.mipmaps;
                        1 === n.mipmapCount && (o.minFilter = Hs), o.format = n.format, o.needsUpdate = !0, e && e(o)
                    }), n, i);
                    return o
                }
            });
            class Sp extends _p {
                constructor(t) {
                    super(t)
                }
                load(t, e, n, i) {
                    void 0 !== this.path && (t = this.path + t), t = this.manager.resolveURL(t);
                    const r = this,
                        s = vp.get(t);
                    if (void 0 !== s) return r.manager.itemStart(t), setTimeout((function() {
                        e && e(s), r.manager.itemEnd(t)
                    }), 0), s;
                    const o = document.createElementNS("http://www.w3.org/1999/xhtml", "img");

                    function a() {
                        o.removeEventListener("load", a, !1), o.removeEventListener("error", l, !1), vp.add(t, this), e && e(this), r.manager.itemEnd(t)
                    }

                    function l(e) {
                        o.removeEventListener("load", a, !1), o.removeEventListener("error", l, !1), i && i(e), r.manager.itemError(t), r.manager.itemEnd(t)
                    }
                    return o.addEventListener("load", a, !1), o.addEventListener("error", l, !1), "data:" !== t.substr(0, 5) && void 0 !== this.crossOrigin && (o.crossOrigin = this.crossOrigin), r.manager.itemStart(t), o.src = t, o
                }
            }
            class Ep extends _p {
                constructor(t) {
                    super(t)
                }
                load(t, e, n, i) {
                    const r = new Zl,
                        s = new Sp(this.manager);
                    s.setCrossOrigin(this.crossOrigin), s.setPath(this.path);
                    let o = 0;

                    function a(n) {
                        s.load(t[n], (function(t) {
                            r.images[n] = t, o++, 6 === o && (r.needsUpdate = !0, e && e(r))
                        }), void 0, i)
                    }
                    for (let e = 0; e < t.length; ++e) a(e);
                    return r
                }
            }

            function Dp(t) {
                _p.call(this, t)
            }

            function Tp(t) {
                _p.call(this, t)
            }

            function Ap() {
                this.type = "Curve", this.arcLengthDivisions = 200
            }
            Dp.prototype = Object.assign(Object.create(_p.prototype), {
                constructor: Dp,
                load: function(t, e, n, i) {
                    const r = this,
                        s = new Ql,
                        o = new wp(this.manager);
                    return o.setResponseType("arraybuffer"), o.setRequestHeader(this.requestHeader), o.setPath(this.path), o.setWithCredentials(r.withCredentials), o.load(t, (function(t) {
                        const n = r.parse(t);
                        n && (void 0 !== n.image ? s.image = n.image : void 0 !== n.data && (s.image.width = n.width, s.image.height = n.height, s.image.data = n.data), s.wrapS = void 0 !== n.wrapS ? n.wrapS : Is, s.wrapT = void 0 !== n.wrapT ? n.wrapT : Is, s.magFilter = void 0 !== n.magFilter ? n.magFilter : Hs, s.minFilter = void 0 !== n.minFilter ? n.minFilter : Hs, s.anisotropy = void 0 !== n.anisotropy ? n.anisotropy : 1, void 0 !== n.encoding && (s.encoding = n.encoding), void 0 !== n.flipY && (s.flipY = n.flipY), void 0 !== n.format && (s.format = n.format), void 0 !== n.type && (s.type = n.type), void 0 !== n.mipmaps && (s.mipmaps = n.mipmaps, s.minFilter = Us), 1 === n.mipmapCount && (s.minFilter = Hs), s.needsUpdate = !0, e && e(s, n))
                    }), n, i), s
                }
            }), Tp.prototype = Object.assign(Object.create(_p.prototype), {
                constructor: Tp,
                load: function(t, e, n, i) {
                    const r = new Mo,
                        s = new Sp(this.manager);
                    return s.setCrossOrigin(this.crossOrigin), s.setPath(this.path), s.load(t, (function(n) {
                        r.image = n;
                        const i = t.search(/\.jpe?g($|\?)/i) > 0 || 0 === t.search(/^data\:image\/jpeg/);
                        r.format = i ? Ys : Zs, r.needsUpdate = !0, void 0 !== e && e(r)
                    }), n, i), r
                }
            }), Object.assign(Ap.prototype, {
                getPoint: function() {
                    return console.warn("THREE.Curve: .getPoint() not implemented."), null
                },
                getPointAt: function(t, e) {
                    const n = this.getUtoTmapping(t);
                    return this.getPoint(n, e)
                },
                getPoints: function(t = 5) {
                    const e = [];
                    for (let n = 0; n <= t; n++) e.push(this.getPoint(n / t));
                    return e
                },
                getSpacedPoints: function(t = 5) {
                    const e = [];
                    for (let n = 0; n <= t; n++) e.push(this.getPointAt(n / t));
                    return e
                },
                getLength: function() {
                    const t = this.getLengths();
                    return t[t.length - 1]
                },
                getLengths: function(t) {
                    if (void 0 === t && (t = this.arcLengthDivisions), this.cacheArcLengths && this.cacheArcLengths.length === t + 1 && !this.needsUpdate) return this.cacheArcLengths;
                    this.needsUpdate = !1;
                    const e = [];
                    let n, i = this.getPoint(0),
                        r = 0;
                    e.push(0);
                    for (let s = 1; s <= t; s++) n = this.getPoint(s / t), r += n.distanceTo(i), e.push(r), i = n;
                    return this.cacheArcLengths = e, e
                },
                updateArcLengths: function() {
                    this.needsUpdate = !0, this.getLengths()
                },
                getUtoTmapping: function(t, e) {
                    const n = this.getLengths();
                    let i = 0;
                    const r = n.length;
                    let s;
                    s = e || t * n[r - 1];
                    let o, a = 0,
                        l = r - 1;
                    for (; a <= l;)
                        if (i = Math.floor(a + (l - a) / 2), o = n[i] - s, o < 0) a = i + 1;
                        else {
                            if (!(o > 0)) {
                                l = i;
                                break
                            }
                            l = i - 1
                        }
                    if (i = l, n[i] === s) return i / (r - 1);
                    const c = n[i];
                    return (i + (s - c) / (n[i + 1] - c)) / (r - 1)
                },
                getTangent: function(t, e) {
                    const n = 1e-4;
                    let i = t - n,
                        r = t + n;
                    i < 0 && (i = 0), r > 1 && (r = 1);
                    const s = this.getPoint(i),
                        o = this.getPoint(r),
                        a = e || (s.isVector2 ? new yo : new Ao);
                    return a.copy(o).sub(s).normalize(), a
                },
                getTangentAt: function(t, e) {
                    const n = this.getUtoTmapping(t);
                    return this.getTangent(n, e)
                },
                computeFrenetFrames: function(t, e) {
                    const n = new Ao,
                        i = [],
                        r = [],
                        s = [],
                        o = new Ao,
                        a = new na;
                    for (let e = 0; e <= t; e++) {
                        const n = e / t;
                        i[e] = this.getTangentAt(n, new Ao), i[e].normalize()
                    }
                    r[0] = new Ao, s[0] = new Ao;
                    let l = Number.MAX_VALUE;
                    const c = Math.abs(i[0].x),
                        u = Math.abs(i[0].y),
                        h = Math.abs(i[0].z);
                    c <= l && (l = c, n.set(1, 0, 0)), u <= l && (l = u, n.set(0, 1, 0)), h <= l && n.set(0, 0, 1), o.crossVectors(i[0], n).normalize(), r[0].crossVectors(i[0], o), s[0].crossVectors(i[0], r[0]);
                    for (let e = 1; e <= t; e++) {
                        if (r[e] = r[e - 1].clone(), s[e] = s[e - 1].clone(), o.crossVectors(i[e - 1], i[e]), o.length() > Number.EPSILON) {
                            o.normalize();
                            const t = Math.acos(vo.clamp(i[e - 1].dot(i[e]), -1, 1));
                            r[e].applyMatrix4(a.makeRotationAxis(o, t))
                        }
                        s[e].crossVectors(i[e], r[e])
                    }
                    if (!0 === e) {
                        let e = Math.acos(vo.clamp(r[0].dot(r[t]), -1, 1));
                        e /= t, i[0].dot(o.crossVectors(r[0], r[t])) > 0 && (e = -e);
                        for (let n = 1; n <= t; n++) r[n].applyMatrix4(a.makeRotationAxis(i[n], e * n)), s[n].crossVectors(i[n], r[n])
                    }
                    return {
                        tangents: i,
                        normals: r,
                        binormals: s
                    }
                },
                clone: function() {
                    return (new this.constructor).copy(this)
                },
                copy: function(t) {
                    return this.arcLengthDivisions = t.arcLengthDivisions, this
                },
                toJSON: function() {
                    const t = {
                        metadata: {
                            version: 4.5,
                            type: "Curve",
                            generator: "Curve.toJSON"
                        }
                    };
                    return t.arcLengthDivisions = this.arcLengthDivisions, t.type = this.type, t
                },
                fromJSON: function(t) {
                    return this.arcLengthDivisions = t.arcLengthDivisions, this
                }
            });
            class Cp extends Ap {
                constructor(t = 0, e = 0, n = 1, i = 1, r = 0, s = 2 * Math.PI, o = !1, a = 0) {
                    super(), this.type = "EllipseCurve", this.aX = t, this.aY = e, this.xRadius = n, this.yRadius = i, this.aStartAngle = r, this.aEndAngle = s, this.aClockwise = o, this.aRotation = a
                }
                getPoint(t, e) {
                    const n = e || new yo,
                        i = 2 * Math.PI;
                    let r = this.aEndAngle - this.aStartAngle;
                    const s = Math.abs(r) < Number.EPSILON;
                    for (; r < 0;) r += i;
                    for (; r > i;) r -= i;
                    r < Number.EPSILON && (r = s ? 0 : i), !0 !== this.aClockwise || s || (r === i ? r = -i : r -= i);
                    const o = this.aStartAngle + t * r;
                    let a = this.aX + this.xRadius * Math.cos(o),
                        l = this.aY + this.yRadius * Math.sin(o);
                    if (0 !== this.aRotation) {
                        const t = Math.cos(this.aRotation),
                            e = Math.sin(this.aRotation),
                            n = a - this.aX,
                            i = l - this.aY;
                        a = n * t - i * e + this.aX, l = n * e + i * t + this.aY
                    }
                    return n.set(a, l)
                }
                copy(t) {
                    return super.copy(t), this.aX = t.aX, this.aY = t.aY, this.xRadius = t.xRadius, this.yRadius = t.yRadius, this.aStartAngle = t.aStartAngle, this.aEndAngle = t.aEndAngle, this.aClockwise = t.aClockwise, this.aRotation = t.aRotation, this
                }
                toJSON() {
                    const t = super.toJSON();
                    return t.aX = this.aX, t.aY = this.aY, t.xRadius = this.xRadius, t.yRadius = this.yRadius, t.aStartAngle = this.aStartAngle, t.aEndAngle = this.aEndAngle, t.aClockwise = this.aClockwise, t.aRotation = this.aRotation, t
                }
                fromJSON(t) {
                    return super.fromJSON(t), this.aX = t.aX, this.aY = t.aY, this.xRadius = t.xRadius, this.yRadius = t.yRadius, this.aStartAngle = t.aStartAngle, this.aEndAngle = t.aEndAngle, this.aClockwise = t.aClockwise, this.aRotation = t.aRotation, this
                }
            }
            Cp.prototype.isEllipseCurve = !0;
            class Lp extends Cp {
                constructor(t, e, n, i, r, s) {
                    super(t, e, n, n, i, r, s), this.type = "ArcCurve"
                }
            }

            function Rp() {
                let t = 0,
                    e = 0,
                    n = 0,
                    i = 0;

                function r(r, s, o, a) {
                    t = r, e = o, n = -3 * r + 3 * s - 2 * o - a, i = 2 * r - 2 * s + o + a
                }
                return {
                    initCatmullRom: function(t, e, n, i, s) {
                        r(e, n, s * (n - t), s * (i - e))
                    },
                    initNonuniformCatmullRom: function(t, e, n, i, s, o, a) {
                        let l = (e - t) / s - (n - t) / (s + o) + (n - e) / o,
                            c = (n - e) / o - (i - e) / (o + a) + (i - n) / a;
                        l *= o, c *= o, r(e, n, l, c)
                    },
                    calc: function(r) {
                        const s = r * r;
                        return t + e * r + n * s + i * (s * r)
                    }
                }
            }
            Lp.prototype.isArcCurve = !0;
            const Pp = new Ao,
                Fp = new Rp,
                Op = new Rp,
                Ip = new Rp;
            class Np extends Ap {
                constructor(t = [], e = !1, n = "centripetal", i = .5) {
                    super(), this.type = "CatmullRomCurve3", this.points = t, this.closed = e, this.curveType = n, this.tension = i
                }
                getPoint(t, e = new Ao) {
                    const n = e,
                        i = this.points,
                        r = i.length,
                        s = (r - (this.closed ? 0 : 1)) * t;
                    let o, a, l = Math.floor(s),
                        c = s - l;
                    this.closed ? l += l > 0 ? 0 : (Math.floor(Math.abs(l) / r) + 1) * r : 0 === c && l === r - 1 && (l = r - 2, c = 1), this.closed || l > 0 ? o = i[(l - 1) % r] : (Pp.subVectors(i[0], i[1]).add(i[0]), o = Pp);
                    const u = i[l % r],
                        h = i[(l + 1) % r];
                    if (this.closed || l + 2 < r ? a = i[(l + 2) % r] : (Pp.subVectors(i[r - 1], i[r - 2]).add(i[r - 1]), a = Pp), "centripetal" === this.curveType || "chordal" === this.curveType) {
                        const t = "chordal" === this.curveType ? .5 : .25;
                        let e = Math.pow(o.distanceToSquared(u), t),
                            n = Math.pow(u.distanceToSquared(h), t),
                            i = Math.pow(h.distanceToSquared(a), t);
                        n < 1e-4 && (n = 1), e < 1e-4 && (e = n), i < 1e-4 && (i = n), Fp.initNonuniformCatmullRom(o.x, u.x, h.x, a.x, e, n, i), Op.initNonuniformCatmullRom(o.y, u.y, h.y, a.y, e, n, i), Ip.initNonuniformCatmullRom(o.z, u.z, h.z, a.z, e, n, i)
                    } else "catmullrom" === this.curveType && (Fp.initCatmullRom(o.x, u.x, h.x, a.x, this.tension), Op.initCatmullRom(o.y, u.y, h.y, a.y, this.tension), Ip.initCatmullRom(o.z, u.z, h.z, a.z, this.tension));
                    return n.set(Fp.calc(c), Op.calc(c), Ip.calc(c)), n
                }
                copy(t) {
                    super.copy(t), this.points = [];
                    for (let e = 0, n = t.points.length; e < n; e++) {
                        const n = t.points[e];
                        this.points.push(n.clone())
                    }
                    return this.closed = t.closed, this.curveType = t.curveType, this.tension = t.tension, this
                }
                toJSON() {
                    const t = super.toJSON();
                    t.points = [];
                    for (let e = 0, n = this.points.length; e < n; e++) {
                        const n = this.points[e];
                        t.points.push(n.toArray())
                    }
                    return t.closed = this.closed, t.curveType = this.curveType, t.tension = this.tension, t
                }
                fromJSON(t) {
                    super.fromJSON(t), this.points = [];
                    for (let e = 0, n = t.points.length; e < n; e++) {
                        const n = t.points[e];
                        this.points.push((new Ao).fromArray(n))
                    }
                    return this.closed = t.closed, this.curveType = t.curveType, this.tension = t.tension, this
                }
            }

            function Bp(t, e, n, i, r) {
                const s = .5 * (i - e),
                    o = .5 * (r - n),
                    a = t * t;
                return (2 * n - 2 * i + s + o) * (t * a) + (-3 * n + 3 * i - 2 * s - o) * a + s * t + n
            }

            function zp(t, e, n, i) {
                return function(t, e) {
                    const n = 1 - t;
                    return n * n * e
                }(t, e) + function(t, e) {
                    return 2 * (1 - t) * t * e
                }(t, n) + function(t, e) {
                    return t * t * e
                }(t, i)
            }

            function kp(t, e, n, i, r) {
                return function(t, e) {
                    const n = 1 - t;
                    return n * n * n * e
                }(t, e) + function(t, e) {
                    const n = 1 - t;
                    return 3 * n * n * t * e
                }(t, n) + function(t, e) {
                    return 3 * (1 - t) * t * t * e
                }(t, i) + function(t, e) {
                    return t * t * t * e
                }(t, r)
            }
            Np.prototype.isCatmullRomCurve3 = !0;
            class Hp extends Ap {
                constructor(t = new yo, e = new yo, n = new yo, i = new yo) {
                    super(), this.type = "CubicBezierCurve", this.v0 = t, this.v1 = e, this.v2 = n, this.v3 = i
                }
                getPoint(t, e = new yo) {
                    const n = e,
                        i = this.v0,
                        r = this.v1,
                        s = this.v2,
                        o = this.v3;
                    return n.set(kp(t, i.x, r.x, s.x, o.x), kp(t, i.y, r.y, s.y, o.y)), n
                }
                copy(t) {
                    return super.copy(t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this.v3.copy(t.v3), this
                }
                toJSON() {
                    const t = super.toJSON();
                    return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t.v3 = this.v3.toArray(), t
                }
                fromJSON(t) {
                    return super.fromJSON(t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this.v3.fromArray(t.v3), this
                }
            }
            Hp.prototype.isCubicBezierCurve = !0;
            class Up extends Ap {
                constructor(t = new Ao, e = new Ao, n = new Ao, i = new Ao) {
                    super(), this.type = "CubicBezierCurve3", this.v0 = t, this.v1 = e, this.v2 = n, this.v3 = i
                }
                getPoint(t, e = new Ao) {
                    const n = e,
                        i = this.v0,
                        r = this.v1,
                        s = this.v2,
                        o = this.v3;
                    return n.set(kp(t, i.x, r.x, s.x, o.x), kp(t, i.y, r.y, s.y, o.y), kp(t, i.z, r.z, s.z, o.z)), n
                }
                copy(t) {
                    return super.copy(t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this.v3.copy(t.v3), this
                }
                toJSON() {
                    const t = super.toJSON();
                    return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t.v3 = this.v3.toArray(), t
                }
                fromJSON(t) {
                    return super.fromJSON(t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this.v3.fromArray(t.v3), this
                }
            }
            Up.prototype.isCubicBezierCurve3 = !0;
            class Gp extends Ap {
                constructor(t = new yo, e = new yo) {
                    super(), this.type = "LineCurve", this.v1 = t, this.v2 = e
                }
                getPoint(t, e = new yo) {
                    const n = e;
                    return 1 === t ? n.copy(this.v2) : (n.copy(this.v2).sub(this.v1), n.multiplyScalar(t).add(this.v1)), n
                }
                getPointAt(t, e) {
                    return this.getPoint(t, e)
                }
                getTangent(t, e) {
                    const n = e || new yo;
                    return n.copy(this.v2).sub(this.v1).normalize(), n
                }
                copy(t) {
                    return super.copy(t), this.v1.copy(t.v1), this.v2.copy(t.v2), this
                }
                toJSON() {
                    const t = super.toJSON();
                    return t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t
                }
                fromJSON(t) {
                    return super.fromJSON(t), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this
                }
            }
            Gp.prototype.isLineCurve = !0;
            class Wp extends Ap {
                constructor(t = new yo, e = new yo, n = new yo) {
                    super(), this.type = "QuadraticBezierCurve", this.v0 = t, this.v1 = e, this.v2 = n
                }
                getPoint(t, e = new yo) {
                    const n = e,
                        i = this.v0,
                        r = this.v1,
                        s = this.v2;
                    return n.set(zp(t, i.x, r.x, s.x), zp(t, i.y, r.y, s.y)), n
                }
                copy(t) {
                    return super.copy(t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this
                }
                toJSON() {
                    const t = super.toJSON();
                    return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t
                }
                fromJSON(t) {
                    return super.fromJSON(t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this
                }
            }
            Wp.prototype.isQuadraticBezierCurve = !0;
            class Vp extends Ap {
                constructor(t = new Ao, e = new Ao, n = new Ao) {
                    super(), this.type = "QuadraticBezierCurve3", this.v0 = t, this.v1 = e, this.v2 = n
                }
                getPoint(t, e = new Ao) {
                    const n = e,
                        i = this.v0,
                        r = this.v1,
                        s = this.v2;
                    return n.set(zp(t, i.x, r.x, s.x), zp(t, i.y, r.y, s.y), zp(t, i.z, r.z, s.z)), n
                }
                copy(t) {
                    return super.copy(t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this
                }
                toJSON() {
                    const t = super.toJSON();
                    return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t
                }
                fromJSON(t) {
                    return super.fromJSON(t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this
                }
            }
            Vp.prototype.isQuadraticBezierCurve3 = !0;
            class jp extends Ap {
                constructor(t = []) {
                    super(), this.type = "SplineCurve", this.points = t
                }
                getPoint(t, e = new yo) {
                    const n = e,
                        i = this.points,
                        r = (i.length - 1) * t,
                        s = Math.floor(r),
                        o = r - s,
                        a = i[0 === s ? s : s - 1],
                        l = i[s],
                        c = i[s > i.length - 2 ? i.length - 1 : s + 1],
                        u = i[s > i.length - 3 ? i.length - 1 : s + 2];
                    return n.set(Bp(o, a.x, l.x, c.x, u.x), Bp(o, a.y, l.y, c.y, u.y)), n
                }
                copy(t) {
                    super.copy(t), this.points = [];
                    for (let e = 0, n = t.points.length; e < n; e++) {
                        const n = t.points[e];
                        this.points.push(n.clone())
                    }
                    return this
                }
                toJSON() {
                    const t = super.toJSON();
                    t.points = [];
                    for (let e = 0, n = this.points.length; e < n; e++) {
                        const n = this.points[e];
                        t.points.push(n.toArray())
                    }
                    return t
                }
                fromJSON(t) {
                    super.fromJSON(t), this.points = [];
                    for (let e = 0, n = t.points.length; e < n; e++) {
                        const n = t.points[e];
                        this.points.push((new yo).fromArray(n))
                    }
                    return this
                }
            }
            jp.prototype.isSplineCurve = !0;
            var qp = Object.freeze({
                __proto__: null,
                ArcCurve: Lp,
                CatmullRomCurve3: Np,
                CubicBezierCurve: Hp,
                CubicBezierCurve3: Up,
                EllipseCurve: Cp,
                LineCurve: Gp,
                LineCurve3: class extends Ap {
                    constructor(t = new Ao, e = new Ao) {
                        super(), this.type = "LineCurve3", this.isLineCurve3 = !0, this.v1 = t, this.v2 = e
                    }
                    getPoint(t, e = new Ao) {
                        const n = e;
                        return 1 === t ? n.copy(this.v2) : (n.copy(this.v2).sub(this.v1), n.multiplyScalar(t).add(this.v1)), n
                    }
                    getPointAt(t, e) {
                        return this.getPoint(t, e)
                    }
                    copy(t) {
                        return super.copy(t), this.v1.copy(t.v1), this.v2.copy(t.v2), this
                    }
                    toJSON() {
                        const t = super.toJSON();
                        return t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t
                    }
                    fromJSON(t) {
                        return super.fromJSON(t), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this
                    }
                },
                QuadraticBezierCurve: Wp,
                QuadraticBezierCurve3: Vp,
                SplineCurve: jp
            });
            class Xp extends Ap {
                constructor() {
                    super(), this.type = "CurvePath", this.curves = [], this.autoClose = !1
                }
                add(t) {
                    this.curves.push(t)
                }
                closePath() {
                    const t = this.curves[0].getPoint(0),
                        e = this.curves[this.curves.length - 1].getPoint(1);
                    t.equals(e) || this.curves.push(new Gp(e, t))
                }
                getPoint(t) {
                    const e = t * this.getLength(),
                        n = this.getCurveLengths();
                    let i = 0;
                    for (; i < n.length;) {
                        if (n[i] >= e) {
                            const t = n[i] - e,
                                r = this.curves[i],
                                s = r.getLength(),
                                o = 0 === s ? 0 : 1 - t / s;
                            return r.getPointAt(o)
                        }
                        i++
                    }
                    return null
                }
                getLength() {
                    const t = this.getCurveLengths();
                    return t[t.length - 1]
                }
                updateArcLengths() {
                    this.needsUpdate = !0, this.cacheLengths = null, this.getCurveLengths()
                }
                getCurveLengths() {
                    if (this.cacheLengths && this.cacheLengths.length === this.curves.length) return this.cacheLengths;
                    const t = [];
                    let e = 0;
                    for (let n = 0, i = this.curves.length; n < i; n++) e += this.curves[n].getLength(), t.push(e);
                    return this.cacheLengths = t, t
                }
                getSpacedPoints(t = 40) {
                    const e = [];
                    for (let n = 0; n <= t; n++) e.push(this.getPoint(n / t));
                    return this.autoClose && e.push(e[0]), e
                }
                getPoints(t = 12) {
                    const e = [];
                    let n;
                    for (let i = 0, r = this.curves; i < r.length; i++) {
                        const s = r[i],
                            o = s && s.isEllipseCurve ? 2 * t : s && (s.isLineCurve || s.isLineCurve3) ? 1 : s && s.isSplineCurve ? t * s.points.length : t,
                            a = s.getPoints(o);
                        for (let t = 0; t < a.length; t++) {
                            const i = a[t];
                            n && n.equals(i) || (e.push(i), n = i)
                        }
                    }
                    return this.autoClose && e.length > 1 && !e[e.length - 1].equals(e[0]) && e.push(e[0]), e
                }
                copy(t) {
                    super.copy(t), this.curves = [];
                    for (let e = 0, n = t.curves.length; e < n; e++) {
                        const n = t.curves[e];
                        this.curves.push(n.clone())
                    }
                    return this.autoClose = t.autoClose, this
                }
                toJSON() {
                    const t = super.toJSON();
                    t.autoClose = this.autoClose, t.curves = [];
                    for (let e = 0, n = this.curves.length; e < n; e++) {
                        const n = this.curves[e];
                        t.curves.push(n.toJSON())
                    }
                    return t
                }
                fromJSON(t) {
                    super.fromJSON(t), this.autoClose = t.autoClose, this.curves = [];
                    for (let e = 0, n = t.curves.length; e < n; e++) {
                        const n = t.curves[e];
                        this.curves.push((new qp[n.type]).fromJSON(n))
                    }
                    return this
                }
            }
            class Yp extends Xp {
                constructor(t) {
                    super(), this.type = "Path", this.currentPoint = new yo, t && this.setFromPoints(t)
                }
                setFromPoints(t) {
                    this.moveTo(t[0].x, t[0].y);
                    for (let e = 1, n = t.length; e < n; e++) this.lineTo(t[e].x, t[e].y);
                    return this
                }
                moveTo(t, e) {
                    return this.currentPoint.set(t, e), this
                }
                lineTo(t, e) {
                    const n = new Gp(this.currentPoint.clone(), new yo(t, e));
                    return this.curves.push(n), this.currentPoint.set(t, e), this
                }
                quadraticCurveTo(t, e, n, i) {
                    const r = new Wp(this.currentPoint.clone(), new yo(t, e), new yo(n, i));
                    return this.curves.push(r), this.currentPoint.set(n, i), this
                }
                bezierCurveTo(t, e, n, i, r, s) {
                    const o = new Hp(this.currentPoint.clone(), new yo(t, e), new yo(n, i), new yo(r, s));
                    return this.curves.push(o), this.currentPoint.set(r, s), this
                }
                splineThru(t) {
                    const e = [this.currentPoint.clone()].concat(t),
                        n = new jp(e);
                    return this.curves.push(n), this.currentPoint.copy(t[t.length - 1]), this
                }
                arc(t, e, n, i, r, s) {
                    const o = this.currentPoint.x,
                        a = this.currentPoint.y;
                    return this.absarc(t + o, e + a, n, i, r, s), this
                }
                absarc(t, e, n, i, r, s) {
                    return this.absellipse(t, e, n, n, i, r, s), this
                }
                ellipse(t, e, n, i, r, s, o, a) {
                    const l = this.currentPoint.x,
                        c = this.currentPoint.y;
                    return this.absellipse(t + l, e + c, n, i, r, s, o, a), this
                }
                absellipse(t, e, n, i, r, s, o, a) {
                    const l = new Cp(t, e, n, i, r, s, o, a);
                    if (this.curves.length > 0) {
                        const t = l.getPoint(0);
                        t.equals(this.currentPoint) || this.lineTo(t.x, t.y)
                    }
                    this.curves.push(l);
                    const c = l.getPoint(1);
                    return this.currentPoint.copy(c), this
                }
                copy(t) {
                    return super.copy(t), this.currentPoint.copy(t.currentPoint), this
                }
                toJSON() {
                    const t = super.toJSON();
                    return t.currentPoint = this.currentPoint.toArray(), t
                }
                fromJSON(t) {
                    return super.fromJSON(t), this.currentPoint.fromArray(t.currentPoint), this
                }
            }
            class Zp extends Yp {
                constructor(t) {
                    super(t), this.uuid = vo.generateUUID(), this.type = "Shape", this.holes = []
                }
                getPointsHoles(t) {
                    const e = [];
                    for (let n = 0, i = this.holes.length; n < i; n++) e[n] = this.holes[n].getPoints(t);
                    return e
                }
                extractPoints(t) {
                    return {
                        shape: this.getPoints(t),
                        holes: this.getPointsHoles(t)
                    }
                }
                copy(t) {
                    super.copy(t), this.holes = [];
                    for (let e = 0, n = t.holes.length; e < n; e++) {
                        const n = t.holes[e];
                        this.holes.push(n.clone())
                    }
                    return this
                }
                toJSON() {
                    const t = super.toJSON();
                    t.uuid = this.uuid, t.holes = [];
                    for (let e = 0, n = this.holes.length; e < n; e++) {
                        const n = this.holes[e];
                        t.holes.push(n.toJSON())
                    }
                    return t
                }
                fromJSON(t) {
                    super.fromJSON(t), this.uuid = t.uuid, this.holes = [];
                    for (let e = 0, n = t.holes.length; e < n; e++) {
                        const n = t.holes[e];
                        this.holes.push((new Yp).fromJSON(n))
                    }
                    return this
                }
            }
            class Jp extends Ta {
                constructor(t, e = 1) {
                    super(), this.type = "Light", this.color = new Qa(t), this.intensity = e
                }
                copy(t) {
                    return super.copy(t), this.color.copy(t.color), this.intensity = t.intensity, this
                }
                toJSON(t) {
                    const e = super.toJSON(t);
                    return e.object.color = this.color.getHex(), e.object.intensity = this.intensity, void 0 !== this.groundColor && (e.object.groundColor = this.groundColor.getHex()), void 0 !== this.distance && (e.object.distance = this.distance), void 0 !== this.angle && (e.object.angle = this.angle), void 0 !== this.decay && (e.object.decay = this.decay), void 0 !== this.penumbra && (e.object.penumbra = this.penumbra), void 0 !== this.shadow && (e.object.shadow = this.shadow.toJSON()), e
                }
            }
            Jp.prototype.isLight = !0;
            class Qp extends Jp {
                constructor(t, e, n) {
                    super(t, n), this.type = "HemisphereLight", this.position.copy(Ta.DefaultUp), this.updateMatrix(), this.groundColor = new Qa(e)
                }
                copy(t) {
                    return Jp.prototype.copy.call(this, t), this.groundColor.copy(t.groundColor), this
                }
            }
            Qp.prototype.isHemisphereLight = !0;
            const Kp = new na,
                $p = new Ao,
                tf = new Ao;
            class ef {
                constructor(t) {
                    this.camera = t, this.bias = 0, this.normalBias = 0, this.radius = 1, this.mapSize = new yo(512, 512), this.map = null, this.mapPass = null, this.matrix = new na, this.autoUpdate = !0, this.needsUpdate = !1, this._frustum = new tc, this._frameExtents = new yo(1, 1), this._viewportCount = 1, this._viewports = [new Eo(0, 0, 1, 1)]
                }
                getViewportCount() {
                    return this._viewportCount
                }
                getFrustum() {
                    return this._frustum
                }
                updateMatrices(t) {
                    const e = this.camera,
                        n = this.matrix;
                    $p.setFromMatrixPosition(t.matrixWorld), e.position.copy($p), tf.setFromMatrixPosition(t.target.matrixWorld), e.lookAt(tf), e.updateMatrixWorld(), Kp.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse), this._frustum.setFromProjectionMatrix(Kp), n.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1), n.multiply(e.projectionMatrix), n.multiply(e.matrixWorldInverse)
                }
                getViewport(t) {
                    return this._viewports[t]
                }
                getFrameExtents() {
                    return this._frameExtents
                }
                copy(t) {
                    return this.camera = t.camera.clone(), this.bias = t.bias, this.radius = t.radius, this.mapSize.copy(t.mapSize), this
                }
                clone() {
                    return (new this.constructor).copy(this)
                }
                toJSON() {
                    const t = {};
                    return 0 !== this.bias && (t.bias = this.bias), 0 !== this.normalBias && (t.normalBias = this.normalBias), 1 !== this.radius && (t.radius = this.radius), 512 === this.mapSize.x && 512 === this.mapSize.y || (t.mapSize = this.mapSize.toArray()), t.camera = this.camera.toJSON(!1).object, delete t.camera.matrix, t
                }
            }
            class nf extends ef {
                constructor() {
                    super(new ql(50, 1, .5, 500)), this.focus = 1
                }
                updateMatrices(t) {
                    const e = this.camera,
                        n = 2 * vo.RAD2DEG * t.angle * this.focus,
                        i = this.mapSize.width / this.mapSize.height,
                        r = t.distance || e.far;
                    n === e.fov && i === e.aspect && r === e.far || (e.fov = n, e.aspect = i, e.far = r, e.updateProjectionMatrix()), super.updateMatrices(t)
                }
            }
            nf.prototype.isSpotLightShadow = !0;
            class rf extends Jp {
                constructor(t, e, n = 0, i = Math.PI / 3, r = 0, s = 1) {
                    super(t, e), this.type = "SpotLight", this.position.copy(Ta.DefaultUp), this.updateMatrix(), this.target = new Ta, this.distance = n, this.angle = i, this.penumbra = r, this.decay = s, this.shadow = new nf
                }
                get power() {
                    return this.intensity * Math.PI
                }
                set power(t) {
                    this.intensity = t / Math.PI
                }
                copy(t) {
                    return super.copy(t), this.distance = t.distance, this.angle = t.angle, this.penumbra = t.penumbra, this.decay = t.decay, this.target = t.target.clone(), this.shadow = t.shadow.clone(), this
                }
            }
            rf.prototype.isSpotLight = !0;
            const sf = new na,
                of = new Ao,
                af = new Ao;
            class lf extends ef {
                constructor() {
                    super(new ql(90, 1, .5, 500)), this._frameExtents = new yo(4, 2), this._viewportCount = 6, this._viewports = [new Eo(2, 1, 1, 1), new Eo(0, 1, 1, 1), new Eo(3, 1, 1, 1), new Eo(1, 1, 1, 1), new Eo(3, 0, 1, 1), new Eo(1, 0, 1, 1)], this._cubeDirections = [new Ao(1, 0, 0), new Ao(-1, 0, 0), new Ao(0, 0, 1), new Ao(0, 0, -1), new Ao(0, 1, 0), new Ao(0, -1, 0)], this._cubeUps = [new Ao(0, 1, 0), new Ao(0, 1, 0), new Ao(0, 1, 0), new Ao(0, 1, 0), new Ao(0, 0, 1), new Ao(0, 0, -1)]
                }
                updateMatrices(t, e = 0) {
                    const n = this.camera,
                        i = this.matrix; of .setFromMatrixPosition(t.matrixWorld), n.position.copy( of ), af.copy(n.position), af.add(this._cubeDirections[e]), n.up.copy(this._cubeUps[e]), n.lookAt(af), n.updateMatrixWorld(), i.makeTranslation(- of .x, - of .y, - of .z), sf.multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse), this._frustum.setFromProjectionMatrix(sf)
                }
            }
            lf.prototype.isPointLightShadow = !0;
            class cf extends Jp {
                constructor(t, e, n = 0, i = 1) {
                    super(t, e), this.type = "PointLight", this.distance = n, this.decay = i, this.shadow = new lf
                }
                get power() {
                    return 4 * this.intensity * Math.PI
                }
                set power(t) {
                    this.intensity = t / (4 * Math.PI)
                }
                copy(t) {
                    return super.copy(t), this.distance = t.distance, this.decay = t.decay, this.shadow = t.shadow.clone(), this
                }
            }
            cf.prototype.isPointLight = !0;
            class uf extends jl {
                constructor(t = -1, e = 1, n = 1, i = -1, r = .1, s = 2e3) {
                    super(), this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = t, this.right = e, this.top = n, this.bottom = i, this.near = r, this.far = s, this.updateProjectionMatrix()
                }
                copy(t, e) {
                    return super.copy(t, e), this.left = t.left, this.right = t.right, this.top = t.top, this.bottom = t.bottom, this.near = t.near, this.far = t.far, this.zoom = t.zoom, this.view = null === t.view ? null : Object.assign({}, t.view), this
                }
                setViewOffset(t, e, n, i, r, s) {
                    null === this.view && (this.view = {
                        enabled: !0,
                        fullWidth: 1,
                        fullHeight: 1,
                        offsetX: 0,
                        offsetY: 0,
                        width: 1,
                        height: 1
                    }), this.view.enabled = !0, this.view.fullWidth = t, this.view.fullHeight = e, this.view.offsetX = n, this.view.offsetY = i, this.view.width = r, this.view.height = s, this.updateProjectionMatrix()
                }
                clearViewOffset() {
                    null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix()
                }
                updateProjectionMatrix() {
                    const t = (this.right - this.left) / (2 * this.zoom),
                        e = (this.top - this.bottom) / (2 * this.zoom),
                        n = (this.right + this.left) / 2,
                        i = (this.top + this.bottom) / 2;
                    let r = n - t,
                        s = n + t,
                        o = i + e,
                        a = i - e;
                    if (null !== this.view && this.view.enabled) {
                        const t = (this.right - this.left) / this.view.fullWidth / this.zoom,
                            e = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
                        r += t * this.view.offsetX, s = r + t * this.view.width, o -= e * this.view.offsetY, a = o - e * this.view.height
                    }
                    this.projectionMatrix.makeOrthographic(r, s, o, a, this.near, this.far), this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
                }
                toJSON(t) {
                    const e = Ta.prototype.toJSON.call(this, t);
                    return e.object.zoom = this.zoom, e.object.left = this.left, e.object.right = this.right, e.object.top = this.top, e.object.bottom = this.bottom, e.object.near = this.near, e.object.far = this.far, null !== this.view && (e.object.view = Object.assign({}, this.view)), e
                }
            }
            uf.prototype.isOrthographicCamera = !0;
            class hf extends ef {
                constructor() {
                    super(new uf(-5, 5, 5, -5, .5, 500))
                }
            }
            hf.prototype.isDirectionalLightShadow = !0;
            class df extends Jp {
                constructor(t, e) {
                    super(t, e), this.type = "DirectionalLight", this.position.copy(Ta.DefaultUp), this.updateMatrix(), this.target = new Ta, this.shadow = new hf
                }
                copy(t) {
                    return super.copy(t), this.target = t.target.clone(), this.shadow = t.shadow.clone(), this
                }
            }
            df.prototype.isDirectionalLight = !0;
            class pf extends Jp {
                constructor(t, e) {
                    super(t, e), this.type = "AmbientLight"
                }
            }
            pf.prototype.isAmbientLight = !0;
            class ff extends Jp {
                constructor(t, e, n = 10, i = 10) {
                    super(t, e), this.type = "RectAreaLight", this.width = n, this.height = i
                }
                copy(t) {
                    return super.copy(t), this.width = t.width, this.height = t.height, this
                }
                toJSON(t) {
                    const e = super.toJSON(t);
                    return e.object.width = this.width, e.object.height = this.height, e
                }
            }
            ff.prototype.isRectAreaLight = !0;
            class mf {
                constructor() {
                    this.coefficients = [];
                    for (let t = 0; t < 9; t++) this.coefficients.push(new Ao)
                }
                set(t) {
                    for (let e = 0; e < 9; e++) this.coefficients[e].copy(t[e]);
                    return this
                }
                zero() {
                    for (let t = 0; t < 9; t++) this.coefficients[t].set(0, 0, 0);
                    return this
                }
                getAt(t, e) {
                    const n = t.x,
                        i = t.y,
                        r = t.z,
                        s = this.coefficients;
                    return e.copy(s[0]).multiplyScalar(.282095), e.addScaledVector(s[1], .488603 * i), e.addScaledVector(s[2], .488603 * r), e.addScaledVector(s[3], .488603 * n), e.addScaledVector(s[4], n * i * 1.092548), e.addScaledVector(s[5], i * r * 1.092548), e.addScaledVector(s[6], .315392 * (3 * r * r - 1)), e.addScaledVector(s[7], n * r * 1.092548), e.addScaledVector(s[8], .546274 * (n * n - i * i)), e
                }
                getIrradianceAt(t, e) {
                    const n = t.x,
                        i = t.y,
                        r = t.z,
                        s = this.coefficients;
                    return e.copy(s[0]).multiplyScalar(.886227), e.addScaledVector(s[1], 1.023328 * i), e.addScaledVector(s[2], 1.023328 * r), e.addScaledVector(s[3], 1.023328 * n), e.addScaledVector(s[4], .858086 * n * i), e.addScaledVector(s[5], .858086 * i * r), e.addScaledVector(s[6], .743125 * r * r - .247708), e.addScaledVector(s[7], .858086 * n * r), e.addScaledVector(s[8], .429043 * (n * n - i * i)), e
                }
                add(t) {
                    for (let e = 0; e < 9; e++) this.coefficients[e].add(t.coefficients[e]);
                    return this
                }
                addScaledSH(t, e) {
                    for (let n = 0; n < 9; n++) this.coefficients[n].addScaledVector(t.coefficients[n], e);
                    return this
                }
                scale(t) {
                    for (let e = 0; e < 9; e++) this.coefficients[e].multiplyScalar(t);
                    return this
                }
                lerp(t, e) {
                    for (let n = 0; n < 9; n++) this.coefficients[n].lerp(t.coefficients[n], e);
                    return this
                }
                equals(t) {
                    for (let e = 0; e < 9; e++)
                        if (!this.coefficients[e].equals(t.coefficients[e])) return !1;
                    return !0
                }
                copy(t) {
                    return this.set(t.coefficients)
                }
                clone() {
                    return (new this.constructor).copy(this)
                }
                fromArray(t, e = 0) {
                    const n = this.coefficients;
                    for (let i = 0; i < 9; i++) n[i].fromArray(t, e + 3 * i);
                    return this
                }
                toArray(t = [], e = 0) {
                    const n = this.coefficients;
                    for (let i = 0; i < 9; i++) n[i].toArray(t, e + 3 * i);
                    return t
                }
                static getBasisAt(t, e) {
                    const n = t.x,
                        i = t.y,
                        r = t.z;
                    e[0] = .282095, e[1] = .488603 * i, e[2] = .488603 * r, e[3] = .488603 * n, e[4] = 1.092548 * n * i, e[5] = 1.092548 * i * r, e[6] = .315392 * (3 * r * r - 1), e[7] = 1.092548 * n * r, e[8] = .546274 * (n * n - i * i)
                }
            }
            mf.prototype.isSphericalHarmonics3 = !0;
            class gf extends Jp {
                constructor(t = new mf, e = 1) {
                    super(void 0, e), this.sh = t
                }
                copy(t) {
                    return super.copy(t), this.sh.copy(t.sh), this
                }
                fromJSON(t) {
                    return this.intensity = t.intensity, this.sh.fromArray(t.sh), this
                }
                toJSON(t) {
                    const e = super.toJSON(t);
                    return e.object.sh = this.sh.toArray(), e
                }
            }
            gf.prototype.isLightProbe = !0;
            const vf = function(t) {
                const e = t.lastIndexOf("/");
                return -1 === e ? "./" : t.substr(0, e + 1)
            };

            function yf() {
                _l.call(this), this.type = "InstancedBufferGeometry", this.instanceCount = 1 / 0
            }

            function xf(t, e, n, i) {
                "number" == typeof n && (i = n, n = !1, console.error("THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.")), el.call(this, t, e, n), this.meshPerAttribute = i || 1
            }
            yf.prototype = Object.assign(Object.create(_l.prototype), {
                constructor: yf,
                isInstancedBufferGeometry: !0,
                copy: function(t) {
                    return _l.prototype.copy.call(this, t), this.instanceCount = t.instanceCount, this
                },
                clone: function() {
                    return (new this.constructor).copy(this)
                },
                toJSON: function() {
                    const t = _l.prototype.toJSON.call(this);
                    return t.instanceCount = this.instanceCount, t.isInstancedBufferGeometry = !0, t
                }
            }), xf.prototype = Object.assign(Object.create(el.prototype), {
                constructor: xf,
                isInstancedBufferAttribute: !0,
                copy: function(t) {
                    return el.prototype.copy.call(this, t), this.meshPerAttribute = t.meshPerAttribute, this
                },
                toJSON: function() {
                    const t = el.prototype.toJSON.call(this);
                    return t.meshPerAttribute = this.meshPerAttribute, t.isInstancedBufferAttribute = !0, t
                }
            });

            function _f(t) {
                "undefined" == typeof createImageBitmap && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."), "undefined" == typeof fetch && console.warn("THREE.ImageBitmapLoader: fetch() not supported."), _p.call(this, t), this.options = {
                    premultiplyAlpha: "none"
                }
            }
            _f.prototype = Object.assign(Object.create(_p.prototype), {
                constructor: _f,
                isImageBitmapLoader: !0,
                setOptions: function(t) {
                    return this.options = t, this
                },
                load: function(t, e, n, i) {
                    void 0 === t && (t = ""), void 0 !== this.path && (t = this.path + t), t = this.manager.resolveURL(t);
                    const r = this,
                        s = vp.get(t);
                    if (void 0 !== s) return r.manager.itemStart(t), setTimeout((function() {
                        e && e(s), r.manager.itemEnd(t)
                    }), 0), s;
                    const o = {};
                    o.credentials = "anonymous" === this.crossOrigin ? "same-origin" : "include", o.headers = this.requestHeader, fetch(t, o).then((function(t) {
                        return t.blob()
                    })).then((function(t) {
                        return createImageBitmap(t, Object.assign(r.options, {
                            colorSpaceConversion: "none"
                        }))
                    })).then((function(n) {
                        vp.add(t, n), e && e(n), r.manager.itemEnd(t)
                    })).catch((function(e) {
                        i && i(e), r.manager.itemError(t), r.manager.itemEnd(t)
                    })), r.manager.itemStart(t)
                }
            });
            class bf {
                constructor() {
                    this.type = "ShapePath", this.color = new Qa, this.subPaths = [], this.currentPath = null
                }
                moveTo(t, e) {
                    return this.currentPath = new Yp, this.subPaths.push(this.currentPath), this.currentPath.moveTo(t, e), this
                }
                lineTo(t, e) {
                    return this.currentPath.lineTo(t, e), this
                }
                quadraticCurveTo(t, e, n, i) {
                    return this.currentPath.quadraticCurveTo(t, e, n, i), this
                }
                bezierCurveTo(t, e, n, i, r, s) {
                    return this.currentPath.bezierCurveTo(t, e, n, i, r, s), this
                }
                splineThru(t) {
                    return this.currentPath.splineThru(t), this
                }
                toShapes(t, e) {
                    function n(t) {
                        const e = [];
                        for (let n = 0, i = t.length; n < i; n++) {
                            const i = t[n],
                                r = new Zp;
                            r.curves = i.curves, e.push(r)
                        }
                        return e
                    }

                    function i(t, e) {
                        const n = e.length;
                        let i = !1;
                        for (let r = n - 1, s = 0; s < n; r = s++) {
                            let n = e[r],
                                o = e[s],
                                a = o.x - n.x,
                                l = o.y - n.y;
                            if (Math.abs(l) > Number.EPSILON) {
                                if (l < 0 && (n = e[s], a = -a, o = e[r], l = -l), t.y < n.y || t.y > o.y) continue;
                                if (t.y === n.y) {
                                    if (t.x === n.x) return !0
                                } else {
                                    const e = l * (t.x - n.x) - a * (t.y - n.y);
                                    if (0 === e) return !0;
                                    if (e < 0) continue;
                                    i = !i
                                }
                            } else {
                                if (t.y !== n.y) continue;
                                if (o.x <= t.x && t.x <= n.x || n.x <= t.x && t.x <= o.x) return !0
                            }
                        }
                        return i
                    }
                    const r = kd.isClockWise,
                        s = this.subPaths;
                    if (0 === s.length) return [];
                    if (!0 === e) return n(s);
                    let o, a, l;
                    const c = [];
                    if (1 === s.length) return a = s[0], l = new Zp, l.curves = a.curves, c.push(l), c;
                    let u = !r(s[0].getPoints());
                    u = t ? !u : u;
                    const h = [],
                        d = [];
                    let p, f, m = [],
                        g = 0;
                    d[g] = void 0, m[g] = [];
                    for (let e = 0, n = s.length; e < n; e++) a = s[e], p = a.getPoints(), o = r(p), o = t ? !o : o, o ? (!u && d[g] && g++, d[g] = {
                        s: new Zp,
                        p: p
                    }, d[g].s.curves = a.curves, u && g++, m[g] = []) : m[g].push({
                        h: a,
                        p: p[0]
                    });
                    if (!d[0]) return n(s);
                    if (d.length > 1) {
                        let t = !1;
                        const e = [];
                        for (let t = 0, e = d.length; t < e; t++) h[t] = [];
                        for (let n = 0, r = d.length; n < r; n++) {
                            const r = m[n];
                            for (let s = 0; s < r.length; s++) {
                                const o = r[s];
                                let a = !0;
                                for (let r = 0; r < d.length; r++) i(o.p, d[r].p) && (n !== r && e.push({
                                    froms: n,
                                    tos: r,
                                    hole: s
                                }), a ? (a = !1, h[r].push(o)) : t = !0);
                                a && h[n].push(o)
                            }
                        }
                        e.length > 0 && (t || (m = h))
                    }
                    for (let t = 0, e = d.length; t < e; t++) {
                        l = d[t].s, c.push(l), f = m[t];
                        for (let t = 0, e = f.length; t < e; t++) l.holes.push(f[t].h)
                    }
                    return c
                }
            }
            class wf {
                constructor(t) {
                    this.type = "Font", this.data = t
                }
                generateShapes(t, e = 100) {
                    const n = [],
                        i = function(t, e, n) {
                            const i = Array.from(t),
                                r = e / n.resolution,
                                s = (n.boundingBox.yMax - n.boundingBox.yMin + n.underlineThickness) * r,
                                o = [];
                            let a = 0,
                                l = 0;
                            for (let t = 0; t < i.length; t++) {
                                const e = i[t];
                                if ("\n" === e) a = 0, l -= s;
                                else {
                                    const t = Mf(e, r, a, l, n);
                                    a += t.offsetX, o.push(t.path)
                                }
                            }
                            return o
                        }(t, e, this.data);
                    for (let t = 0, e = i.length; t < e; t++) Array.prototype.push.apply(n, i[t].toShapes());
                    return n
                }
            }

            function Mf(t, e, n, i, r) {
                const s = r.glyphs[t] || r.glyphs["?"];
                if (!s) return void console.error('THREE.Font: character "' + t + '" does not exists in font family ' + r.familyName + ".");
                const o = new bf;
                let a, l, c, u, h, d, p, f;
                if (s.o) {
                    const t = s._cachedOutline || (s._cachedOutline = s.o.split(" "));
                    for (let r = 0, s = t.length; r < s;) {
                        switch (t[r++]) {
                            case "m":
                                a = t[r++] * e + n, l = t[r++] * e + i, o.moveTo(a, l);
                                break;
                            case "l":
                                a = t[r++] * e + n, l = t[r++] * e + i, o.lineTo(a, l);
                                break;
                            case "q":
                                c = t[r++] * e + n, u = t[r++] * e + i, h = t[r++] * e + n, d = t[r++] * e + i, o.quadraticCurveTo(h, d, c, u);
                                break;
                            case "b":
                                c = t[r++] * e + n, u = t[r++] * e + i, h = t[r++] * e + n, d = t[r++] * e + i, p = t[r++] * e + n, f = t[r++] * e + i, o.bezierCurveTo(h, d, p, f, c, u)
                        }
                    }
                }
                return {
                    offsetX: s.ha * e,
                    path: o
                }
            }
            wf.prototype.isFont = !0;
            let Sf;
            const Ef = function() {
                return void 0 === Sf && (Sf = new(window.AudioContext || window.webkitAudioContext)), Sf
            };
            class Df extends _p {
                constructor(t) {
                    super(t)
                }
                load(t, e, n, i) {
                    const r = this,
                        s = new wp(this.manager);
                    s.setResponseType("arraybuffer"), s.setPath(this.path), s.setRequestHeader(this.requestHeader), s.setWithCredentials(this.withCredentials), s.load(t, (function(n) {
                        try {
                            const t = n.slice(0);
                            Ef().decodeAudioData(t, (function(t) {
                                e(t)
                            }))
                        } catch (e) {
                            i ? i(e) : console.error(e), r.manager.itemError(t)
                        }
                    }), n, i)
                }
            }(class extends gf {
                constructor(t, e, n = 1) {
                    super(void 0, n);
                    const i = (new Qa).set(t),
                        r = (new Qa).set(e),
                        s = new Ao(i.r, i.g, i.b),
                        o = new Ao(r.r, r.g, r.b),
                        a = Math.sqrt(Math.PI),
                        l = a * Math.sqrt(.75);
                    this.sh.coefficients[0].copy(s).add(o).multiplyScalar(a), this.sh.coefficients[1].copy(s).sub(o).multiplyScalar(l)
                }
            }).prototype.isHemisphereLightProbe = !0;
            (class extends gf {
                constructor(t, e = 1) {
                    super(void 0, e);
                    const n = (new Qa).set(t);
                    this.sh.coefficients[0].set(n.r, n.g, n.b).multiplyScalar(2 * Math.sqrt(Math.PI))
                }
            }).prototype.isAmbientLightProbe = !0;
            new na, new na;
            class Tf {
                constructor(t) {
                    this.autoStart = void 0 === t || t, this.startTime = 0, this.oldTime = 0, this.elapsedTime = 0, this.running = !1
                }
                start() {
                    this.startTime = Af(), this.oldTime = this.startTime, this.elapsedTime = 0, this.running = !0
                }
                stop() {
                    this.getElapsedTime(), this.running = !1, this.autoStart = !1
                }
                getElapsedTime() {
                    return this.getDelta(), this.elapsedTime
                }
                getDelta() {
                    let t = 0;
                    if (this.autoStart && !this.running) return this.start(), 0;
                    if (this.running) {
                        const e = Af();
                        t = (e - this.oldTime) / 1e3, this.oldTime = e, this.elapsedTime += t
                    }
                    return t
                }
            }

            function Af() {
                return ("undefined" == typeof performance ? Date : performance).now()
            }
            class Cf extends Ta {
                constructor(t) {
                    super(), this.type = "Audio", this.listener = t, this.context = t.context, this.gain = this.context.createGain(), this.gain.connect(t.getInput()), this.autoplay = !1, this.buffer = null, this.detune = 0, this.loop = !1, this.loopStart = 0, this.loopEnd = 0, this.offset = 0, this.duration = void 0, this.playbackRate = 1, this.isPlaying = !1, this.hasPlaybackControl = !0, this.source = null, this.sourceType = "empty", this._startedAt = 0, this._progress = 0, this._connected = !1, this.filters = []
                }
                getOutput() {
                    return this.gain
                }
                setNodeSource(t) {
                    return this.hasPlaybackControl = !1, this.sourceType = "audioNode", this.source = t, this.connect(), this
                }
                setMediaElementSource(t) {
                    return this.hasPlaybackControl = !1, this.sourceType = "mediaNode", this.source = this.context.createMediaElementSource(t), this.connect(), this
                }
                setMediaStreamSource(t) {
                    return this.hasPlaybackControl = !1, this.sourceType = "mediaStreamNode", this.source = this.context.createMediaStreamSource(t), this.connect(), this
                }
                setBuffer(t) {
                    return this.buffer = t, this.sourceType = "buffer", this.autoplay && this.play(), this
                }
                play(t = 0) {
                    if (!0 === this.isPlaying) return void console.warn("THREE.Audio: Audio is already playing.");
                    if (!1 === this.hasPlaybackControl) return void console.warn("THREE.Audio: this Audio has no playback control.");
                    this._startedAt = this.context.currentTime + t;
                    const e = this.context.createBufferSource();
                    return e.buffer = this.buffer, e.loop = this.loop, e.loopStart = this.loopStart, e.loopEnd = this.loopEnd, e.onended = this.onEnded.bind(this), e.start(this._startedAt, this._progress + this.offset, this.duration), this.isPlaying = !0, this.source = e, this.setDetune(this.detune), this.setPlaybackRate(this.playbackRate), this.connect()
                }
                pause() {
                    if (!1 !== this.hasPlaybackControl) return !0 === this.isPlaying && (this._progress += Math.max(this.context.currentTime - this._startedAt, 0) * this.playbackRate, !0 === this.loop && (this._progress = this._progress % (this.duration || this.buffer.duration)), this.source.stop(), this.source.onended = null, this.isPlaying = !1), this;
                    console.warn("THREE.Audio: this Audio has no playback control.")
                }
                stop() {
                    if (!1 !== this.hasPlaybackControl) return this._progress = 0, this.source.stop(), this.source.onended = null, this.isPlaying = !1, this;
                    console.warn("THREE.Audio: this Audio has no playback control.")
                }
                connect() {
                    if (this.filters.length > 0) {
                        this.source.connect(this.filters[0]);
                        for (let t = 1, e = this.filters.length; t < e; t++) this.filters[t - 1].connect(this.filters[t]);
                        this.filters[this.filters.length - 1].connect(this.getOutput())
                    } else this.source.connect(this.getOutput());
                    return this._connected = !0, this
                }
                disconnect() {
                    if (this.filters.length > 0) {
                        this.source.disconnect(this.filters[0]);
                        for (let t = 1, e = this.filters.length; t < e; t++) this.filters[t - 1].disconnect(this.filters[t]);
                        this.filters[this.filters.length - 1].disconnect(this.getOutput())
                    } else this.source.disconnect(this.getOutput());
                    return this._connected = !1, this
                }
                getFilters() {
                    return this.filters
                }
                setFilters(t) {
                    return t || (t = []), !0 === this._connected ? (this.disconnect(), this.filters = t.slice(), this.connect()) : this.filters = t.slice(), this
                }
                setDetune(t) {
                    if (this.detune = t, void 0 !== this.source.detune) return !0 === this.isPlaying && this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, .01), this
                }
                getDetune() {
                    return this.detune
                }
                getFilter() {
                    return this.getFilters()[0]
                }
                setFilter(t) {
                    return this.setFilters(t ? [t] : [])
                }
                setPlaybackRate(t) {
                    if (!1 !== this.hasPlaybackControl) return this.playbackRate = t, !0 === this.isPlaying && this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, .01), this;
                    console.warn("THREE.Audio: this Audio has no playback control.")
                }
                getPlaybackRate() {
                    return this.playbackRate
                }
                onEnded() {
                    this.isPlaying = !1
                }
                getLoop() {
                    return !1 === this.hasPlaybackControl ? (console.warn("THREE.Audio: this Audio has no playback control."), !1) : this.loop
                }
                setLoop(t) {
                    if (!1 !== this.hasPlaybackControl) return this.loop = t, !0 === this.isPlaying && (this.source.loop = this.loop), this;
                    console.warn("THREE.Audio: this Audio has no playback control.")
                }
                setLoopStart(t) {
                    return this.loopStart = t, this
                }
                setLoopEnd(t) {
                    return this.loopEnd = t, this
                }
                getVolume() {
                    return this.gain.gain.value
                }
                setVolume(t) {
                    return this.gain.gain.setTargetAtTime(t, this.context.currentTime, .01), this
                }
            }
            class Lf {
                constructor(t, e, n) {
                    let i, r, s;
                    switch (this.binding = t, this.valueSize = n, e) {
                        case "quaternion":
                            i = this._slerp, r = this._slerpAdditive, s = this._setAdditiveIdentityQuaternion, this.buffer = new Float64Array(6 * n), this._workIndex = 5;
                            break;
                        case "string":
                        case "bool":
                            i = this._select, r = this._select, s = this._setAdditiveIdentityOther, this.buffer = new Array(5 * n);
                            break;
                        default:
                            i = this._lerp, r = this._lerpAdditive, s = this._setAdditiveIdentityNumeric, this.buffer = new Float64Array(5 * n)
                    }
                    this._mixBufferRegion = i, this._mixBufferRegionAdditive = r, this._setIdentity = s, this._origIndex = 3, this._addIndex = 4, this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, this.useCount = 0, this.referenceCount = 0
                }
                accumulate(t, e) {
                    const n = this.buffer,
                        i = this.valueSize,
                        r = t * i + i;
                    let s = this.cumulativeWeight;
                    if (0 === s) {
                        for (let t = 0; t !== i; ++t) n[r + t] = n[t];
                        s = e
                    } else {
                        s += e;
                        const t = e / s;
                        this._mixBufferRegion(n, r, 0, t, i)
                    }
                    this.cumulativeWeight = s
                }
                accumulateAdditive(t) {
                    const e = this.buffer,
                        n = this.valueSize,
                        i = n * this._addIndex;
                    0 === this.cumulativeWeightAdditive && this._setIdentity(), this._mixBufferRegionAdditive(e, i, 0, t, n), this.cumulativeWeightAdditive += t
                }
                apply(t) {
                    const e = this.valueSize,
                        n = this.buffer,
                        i = t * e + e,
                        r = this.cumulativeWeight,
                        s = this.cumulativeWeightAdditive,
                        o = this.binding;
                    if (this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, r < 1) {
                        const t = e * this._origIndex;
                        this._mixBufferRegion(n, i, t, 1 - r, e)
                    }
                    s > 0 && this._mixBufferRegionAdditive(n, i, this._addIndex * e, 1, e);
                    for (let t = e, r = e + e; t !== r; ++t)
                        if (n[t] !== n[t + e]) {
                            o.setValue(n, i);
                            break
                        }
                }
                saveOriginalState() {
                    const t = this.binding,
                        e = this.buffer,
                        n = this.valueSize,
                        i = n * this._origIndex;
                    t.getValue(e, i);
                    for (let t = n, r = i; t !== r; ++t) e[t] = e[i + t % n];
                    this._setIdentity(), this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0
                }
                restoreOriginalState() {
                    const t = 3 * this.valueSize;
                    this.binding.setValue(this.buffer, t)
                }
                _setAdditiveIdentityNumeric() {
                    const t = this._addIndex * this.valueSize,
                        e = t + this.valueSize;
                    for (let n = t; n < e; n++) this.buffer[n] = 0
                }
                _setAdditiveIdentityQuaternion() {
                    this._setAdditiveIdentityNumeric(), this.buffer[this._addIndex * this.valueSize + 3] = 1
                }
                _setAdditiveIdentityOther() {
                    const t = this._origIndex * this.valueSize,
                        e = this._addIndex * this.valueSize;
                    for (let n = 0; n < this.valueSize; n++) this.buffer[e + n] = this.buffer[t + n]
                }
                _select(t, e, n, i, r) {
                    if (i >= .5)
                        for (let i = 0; i !== r; ++i) t[e + i] = t[n + i]
                }
                _slerp(t, e, n, i) {
                    To.slerpFlat(t, e, t, e, t, n, i)
                }
                _slerpAdditive(t, e, n, i, r) {
                    const s = this._workIndex * r;
                    To.multiplyQuaternionsFlat(t, s, t, e, t, n), To.slerpFlat(t, e, t, e, t, s, i)
                }
                _lerp(t, e, n, i, r) {
                    const s = 1 - i;
                    for (let o = 0; o !== r; ++o) {
                        const r = e + o;
                        t[r] = t[r] * s + t[n + o] * i
                    }
                }
                _lerpAdditive(t, e, n, i, r) {
                    for (let s = 0; s !== r; ++s) {
                        const r = e + s;
                        t[r] = t[r] + t[n + s] * i
                    }
                }
            }
            const Rf = "\\[\\]\\.:\\/",
                Pf = new RegExp("[\\[\\]\\.:\\/]", "g"),
                Ff = "[^\\[\\]\\.:\\/]",
                Of = "[^" + Rf.replace("\\.", "") + "]",
                If = /((?:WC+[\/:])*)/.source.replace("WC", Ff),
                Nf = /(WCOD+)?/.source.replace("WCOD", Of),
                Bf = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", Ff),
                zf = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", Ff),
                kf = new RegExp("^" + If + Nf + Bf + zf + "$"),
                Hf = ["material", "materials", "bones"];

            function Uf(t, e, n) {
                const i = n || Gf.parseTrackName(e);
                this._targetGroup = t, this._bindings = t.subscribe_(e, i)
            }

            function Gf(t, e, n) {
                this.path = e, this.parsedPath = n || Gf.parseTrackName(e), this.node = Gf.findNode(t, this.parsedPath.nodeName) || t, this.rootNode = t
            }
            Object.assign(Uf.prototype, {
                getValue: function(t, e) {
                    this.bind();
                    const n = this._targetGroup.nCachedObjects_,
                        i = this._bindings[n];
                    void 0 !== i && i.getValue(t, e)
                },
                setValue: function(t, e) {
                    const n = this._bindings;
                    for (let i = this._targetGroup.nCachedObjects_, r = n.length; i !== r; ++i) n[i].setValue(t, e)
                },
                bind: function() {
                    const t = this._bindings;
                    for (let e = this._targetGroup.nCachedObjects_, n = t.length; e !== n; ++e) t[e].bind()
                },
                unbind: function() {
                    const t = this._bindings;
                    for (let e = this._targetGroup.nCachedObjects_, n = t.length; e !== n; ++e) t[e].unbind()
                }
            }), Object.assign(Gf, {
                Composite: Uf,
                create: function(t, e, n) {
                    return t && t.isAnimationObjectGroup ? new Gf.Composite(t, e, n) : new Gf(t, e, n)
                },
                sanitizeNodeName: function(t) {
                    return t.replace(/\s/g, "_").replace(Pf, "")
                },
                parseTrackName: function(t) {
                    const e = kf.exec(t);
                    if (!e) throw new Error("PropertyBinding: Cannot parse trackName: " + t);
                    const n = {
                            nodeName: e[2],
                            objectName: e[3],
                            objectIndex: e[4],
                            propertyName: e[5],
                            propertyIndex: e[6]
                        },
                        i = n.nodeName && n.nodeName.lastIndexOf(".");
                    if (void 0 !== i && -1 !== i) {
                        const t = n.nodeName.substring(i + 1); - 1 !== Hf.indexOf(t) && (n.nodeName = n.nodeName.substring(0, i), n.objectName = t)
                    }
                    if (null === n.propertyName || 0 === n.propertyName.length) throw new Error("PropertyBinding: can not parse propertyName from trackName: " + t);
                    return n
                },
                findNode: function(t, e) {
                    if (!e || "" === e || "." === e || -1 === e || e === t.name || e === t.uuid) return t;
                    if (t.skeleton) {
                        const n = t.skeleton.getBoneByName(e);
                        if (void 0 !== n) return n
                    }
                    if (t.children) {
                        const n = function(t) {
                                for (let i = 0; i < t.length; i++) {
                                    const r = t[i];
                                    if (r.name === e || r.uuid === e) return r;
                                    const s = n(r.children);
                                    if (s) return s
                                }
                                return null
                            },
                            i = n(t.children);
                        if (i) return i
                    }
                    return null
                }
            }), Object.assign(Gf.prototype, {
                _getValue_unavailable: function() {},
                _setValue_unavailable: function() {},
                BindingType: {
                    Direct: 0,
                    EntireArray: 1,
                    ArrayElement: 2,
                    HasFromToArray: 3
                },
                Versioning: {
                    None: 0,
                    NeedsUpdate: 1,
                    MatrixWorldNeedsUpdate: 2
                },
                GetterByBindingType: [function(t, e) {
                    t[e] = this.node[this.propertyName]
                }, function(t, e) {
                    const n = this.resolvedProperty;
                    for (let i = 0, r = n.length; i !== r; ++i) t[e++] = n[i]
                }, function(t, e) {
                    t[e] = this.resolvedProperty[this.propertyIndex]
                }, function(t, e) {
                    this.resolvedProperty.toArray(t, e)
                }],
                SetterByBindingTypeAndVersioning: [
                    [function(t, e) {
                        this.targetObject[this.propertyName] = t[e]
                    }, function(t, e) {
                        this.targetObject[this.propertyName] = t[e], this.targetObject.needsUpdate = !0
                    }, function(t, e) {
                        this.targetObject[this.propertyName] = t[e], this.targetObject.matrixWorldNeedsUpdate = !0
                    }],
                    [function(t, e) {
                        const n = this.resolvedProperty;
                        for (let i = 0, r = n.length; i !== r; ++i) n[i] = t[e++]
                    }, function(t, e) {
                        const n = this.resolvedProperty;
                        for (let i = 0, r = n.length; i !== r; ++i) n[i] = t[e++];
                        this.targetObject.needsUpdate = !0
                    }, function(t, e) {
                        const n = this.resolvedProperty;
                        for (let i = 0, r = n.length; i !== r; ++i) n[i] = t[e++];
                        this.targetObject.matrixWorldNeedsUpdate = !0
                    }],
                    [function(t, e) {
                        this.resolvedProperty[this.propertyIndex] = t[e]
                    }, function(t, e) {
                        this.resolvedProperty[this.propertyIndex] = t[e], this.targetObject.needsUpdate = !0
                    }, function(t, e) {
                        this.resolvedProperty[this.propertyIndex] = t[e], this.targetObject.matrixWorldNeedsUpdate = !0
                    }],
                    [function(t, e) {
                        this.resolvedProperty.fromArray(t, e)
                    }, function(t, e) {
                        this.resolvedProperty.fromArray(t, e), this.targetObject.needsUpdate = !0
                    }, function(t, e) {
                        this.resolvedProperty.fromArray(t, e), this.targetObject.matrixWorldNeedsUpdate = !0
                    }]
                ],
                getValue: function(t, e) {
                    this.bind(), this.getValue(t, e)
                },
                setValue: function(t, e) {
                    this.bind(), this.setValue(t, e)
                },
                bind: function() {
                    let t = this.node;
                    const e = this.parsedPath,
                        n = e.objectName,
                        i = e.propertyName;
                    let r = e.propertyIndex;
                    if (t || (t = Gf.findNode(this.rootNode, e.nodeName) || this.rootNode, this.node = t), this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, !t) return void console.error("THREE.PropertyBinding: Trying to update node for track: " + this.path + " but it wasn't found.");
                    if (n) {
                        let i = e.objectIndex;
                        switch (n) {
                            case "materials":
                                if (!t.material) return void console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                                if (!t.material.materials) return void console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
                                t = t.material.materials;
                                break;
                            case "bones":
                                if (!t.skeleton) return void console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
                                t = t.skeleton.bones;
                                for (let e = 0; e < t.length; e++)
                                    if (t[e].name === i) {
                                        i = e;
                                        break
                                    }
                                break;
                            default:
                                if (void 0 === t[n]) return void console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
                                t = t[n]
                        }
                        if (void 0 !== i) {
                            if (void 0 === t[i]) return void console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, t);
                            t = t[i]
                        }
                    }
                    const s = t[i];
                    if (void 0 === s) {
                        const n = e.nodeName;
                        return void console.error("THREE.PropertyBinding: Trying to update property for track: " + n + "." + i + " but it wasn't found.", t)
                    }
                    let o = this.Versioning.None;
                    this.targetObject = t, void 0 !== t.needsUpdate ? o = this.Versioning.NeedsUpdate : void 0 !== t.matrixWorldNeedsUpdate && (o = this.Versioning.MatrixWorldNeedsUpdate);
                    let a = this.BindingType.Direct;
                    if (void 0 !== r) {
                        if ("morphTargetInfluences" === i) {
                            if (!t.geometry) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
                            if (!t.geometry.isBufferGeometry) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences on THREE.Geometry. Use THREE.BufferGeometry instead.", this);
                            if (!t.geometry.morphAttributes) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
                            void 0 !== t.morphTargetDictionary[r] && (r = t.morphTargetDictionary[r])
                        }
                        a = this.BindingType.ArrayElement, this.resolvedProperty = s, this.propertyIndex = r
                    } else void 0 !== s.fromArray && void 0 !== s.toArray ? (a = this.BindingType.HasFromToArray, this.resolvedProperty = s) : Array.isArray(s) ? (a = this.BindingType.EntireArray, this.resolvedProperty = s) : this.propertyName = i;
                    this.getValue = this.GetterByBindingType[a], this.setValue = this.SetterByBindingTypeAndVersioning[a][o]
                },
                unbind: function() {
                    this.node = null, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound
                }
            }), Object.assign(Gf.prototype, {
                _getValue_unbound: Gf.prototype.getValue,
                _setValue_unbound: Gf.prototype.setValue
            });
            (class {
                constructor() {
                    this.uuid = vo.generateUUID(), this._objects = Array.prototype.slice.call(arguments), this.nCachedObjects_ = 0;
                    const t = {};
                    this._indicesByUUID = t;
                    for (let e = 0, n = arguments.length; e !== n; ++e) t[arguments[e].uuid] = e;
                    this._paths = [], this._parsedPaths = [], this._bindings = [], this._bindingsIndicesByPath = {};
                    const e = this;
                    this.stats = {
                        objects: {
                            get total() {
                                return e._objects.length
                            },
                            get inUse() {
                                return this.total - e.nCachedObjects_
                            }
                        },
                        get bindingsPerObject() {
                            return e._bindings.length
                        }
                    }
                }
                add() {
                    const t = this._objects,
                        e = this._indicesByUUID,
                        n = this._paths,
                        i = this._parsedPaths,
                        r = this._bindings,
                        s = r.length;
                    let o, a = t.length,
                        l = this.nCachedObjects_;
                    for (let c = 0, u = arguments.length; c !== u; ++c) {
                        const u = arguments[c],
                            h = u.uuid;
                        let d = e[h];
                        if (void 0 === d) {
                            d = a++, e[h] = d, t.push(u);
                            for (let t = 0, e = s; t !== e; ++t) r[t].push(new Gf(u, n[t], i[t]))
                        } else if (d < l) {
                            o = t[d];
                            const a = --l,
                                c = t[a];
                            e[c.uuid] = d, t[d] = c, e[h] = a, t[a] = u;
                            for (let t = 0, e = s; t !== e; ++t) {
                                const e = r[t],
                                    s = e[a];
                                let o = e[d];
                                e[d] = s, void 0 === o && (o = new Gf(u, n[t], i[t])), e[a] = o
                            }
                        } else t[d] !== o && console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.")
                    }
                    this.nCachedObjects_ = l
                }
                remove() {
                    const t = this._objects,
                        e = this._indicesByUUID,
                        n = this._bindings,
                        i = n.length;
                    let r = this.nCachedObjects_;
                    for (let s = 0, o = arguments.length; s !== o; ++s) {
                        const o = arguments[s],
                            a = o.uuid,
                            l = e[a];
                        if (void 0 !== l && l >= r) {
                            const s = r++,
                                c = t[s];
                            e[c.uuid] = l, t[l] = c, e[a] = s, t[s] = o;
                            for (let t = 0, e = i; t !== e; ++t) {
                                const e = n[t],
                                    i = e[s],
                                    r = e[l];
                                e[l] = i, e[s] = r
                            }
                        }
                    }
                    this.nCachedObjects_ = r
                }
                uncache() {
                    const t = this._objects,
                        e = this._indicesByUUID,
                        n = this._bindings,
                        i = n.length;
                    let r = this.nCachedObjects_,
                        s = t.length;
                    for (let o = 0, a = arguments.length; o !== a; ++o) {
                        const a = arguments[o].uuid,
                            l = e[a];
                        if (void 0 !== l)
                            if (delete e[a], l < r) {
                                const o = --r,
                                    a = t[o],
                                    c = --s,
                                    u = t[c];
                                e[a.uuid] = l, t[l] = a, e[u.uuid] = o, t[o] = u, t.pop();
                                for (let t = 0, e = i; t !== e; ++t) {
                                    const e = n[t],
                                        i = e[o],
                                        r = e[c];
                                    e[l] = i, e[o] = r, e.pop()
                                }
                            } else {
                                const r = --s,
                                    o = t[r];
                                r > 0 && (e[o.uuid] = l), t[l] = o, t.pop();
                                for (let t = 0, e = i; t !== e; ++t) {
                                    const e = n[t];
                                    e[l] = e[r], e.pop()
                                }
                            }
                    }
                    this.nCachedObjects_ = r
                }
                subscribe_(t, e) {
                    const n = this._bindingsIndicesByPath;
                    let i = n[t];
                    const r = this._bindings;
                    if (void 0 !== i) return r[i];
                    const s = this._paths,
                        o = this._parsedPaths,
                        a = this._objects,
                        l = a.length,
                        c = this.nCachedObjects_,
                        u = new Array(l);
                    i = r.length, n[t] = i, s.push(t), o.push(e), r.push(u);
                    for (let n = c, i = a.length; n !== i; ++n) {
                        const i = a[n];
                        u[n] = new Gf(i, t, e)
                    }
                    return u
                }
                unsubscribe_(t) {
                    const e = this._bindingsIndicesByPath,
                        n = e[t];
                    if (void 0 !== n) {
                        const i = this._paths,
                            r = this._parsedPaths,
                            s = this._bindings,
                            o = s.length - 1,
                            a = s[o];
                        e[t[o]] = n, s[n] = a, s.pop(), r[n] = r[o], r.pop(), i[n] = i[o], i.pop()
                    }
                }
            }).prototype.isAnimationObjectGroup = !0;
            class Wf {
                constructor(t, e, n = null, i = e.blendMode) {
                    this._mixer = t, this._clip = e, this._localRoot = n, this.blendMode = i;
                    const r = e.tracks,
                        s = r.length,
                        o = new Array(s),
                        a = {
                            endingStart: eo,
                            endingEnd: eo
                        };
                    for (let t = 0; t !== s; ++t) {
                        const e = r[t].createInterpolant(null);
                        o[t] = e, e.settings = a
                    }
                    this._interpolantSettings = a, this._interpolants = o, this._propertyBindings = new Array(s), this._cacheIndex = null, this._byClipCacheIndex = null, this._timeScaleInterpolant = null, this._weightInterpolant = null, this.loop = 2201, this._loopCount = -1, this._startTime = null, this.time = 0, this.timeScale = 1, this._effectiveTimeScale = 1, this.weight = 1, this._effectiveWeight = 1, this.repetitions = 1 / 0, this.paused = !1, this.enabled = !0, this.clampWhenFinished = !1, this.zeroSlopeAtStart = !0, this.zeroSlopeAtEnd = !0
                }
                play() {
                    return this._mixer._activateAction(this), this
                }
                stop() {
                    return this._mixer._deactivateAction(this), this.reset()
                }
                reset() {
                    return this.paused = !1, this.enabled = !0, this.time = 0, this._loopCount = -1, this._startTime = null, this.stopFading().stopWarping()
                }
                isRunning() {
                    return this.enabled && !this.paused && 0 !== this.timeScale && null === this._startTime && this._mixer._isActiveAction(this)
                }
                isScheduled() {
                    return this._mixer._isActiveAction(this)
                }
                startAt(t) {
                    return this._startTime = t, this
                }
                setLoop(t, e) {
                    return this.loop = t, this.repetitions = e, this
                }
                setEffectiveWeight(t) {
                    return this.weight = t, this._effectiveWeight = this.enabled ? t : 0, this.stopFading()
                }
                getEffectiveWeight() {
                    return this._effectiveWeight
                }
                fadeIn(t) {
                    return this._scheduleFading(t, 0, 1)
                }
                fadeOut(t) {
                    return this._scheduleFading(t, 1, 0)
                }
                crossFadeFrom(t, e, n) {
                    if (t.fadeOut(e), this.fadeIn(e), n) {
                        const n = this._clip.duration,
                            i = t._clip.duration,
                            r = i / n,
                            s = n / i;
                        t.warp(1, r, e), this.warp(s, 1, e)
                    }
                    return this
                }
                crossFadeTo(t, e, n) {
                    return t.crossFadeFrom(this, e, n)
                }
                stopFading() {
                    const t = this._weightInterpolant;
                    return null !== t && (this._weightInterpolant = null, this._mixer._takeBackControlInterpolant(t)), this
                }
                setEffectiveTimeScale(t) {
                    return this.timeScale = t, this._effectiveTimeScale = this.paused ? 0 : t, this.stopWarping()
                }
                getEffectiveTimeScale() {
                    return this._effectiveTimeScale
                }
                setDuration(t) {
                    return this.timeScale = this._clip.duration / t, this.stopWarping()
                }
                syncWith(t) {
                    return this.time = t.time, this.timeScale = t.timeScale, this.stopWarping()
                }
                halt(t) {
                    return this.warp(this._effectiveTimeScale, 0, t)
                }
                warp(t, e, n) {
                    const i = this._mixer,
                        r = i.time,
                        s = this.timeScale;
                    let o = this._timeScaleInterpolant;
                    null === o && (o = i._lendControlInterpolant(), this._timeScaleInterpolant = o);
                    const a = o.parameterPositions,
                        l = o.sampleValues;
                    return a[0] = r, a[1] = r + n, l[0] = t / s, l[1] = e / s, this
                }
                stopWarping() {
                    const t = this._timeScaleInterpolant;
                    return null !== t && (this._timeScaleInterpolant = null, this._mixer._takeBackControlInterpolant(t)), this
                }
                getMixer() {
                    return this._mixer
                }
                getClip() {
                    return this._clip
                }
                getRoot() {
                    return this._localRoot || this._mixer._root
                }
                _update(t, e, n, i) {
                    if (!this.enabled) return void this._updateWeight(t);
                    const r = this._startTime;
                    if (null !== r) {
                        const i = (t - r) * n;
                        if (i < 0 || 0 === n) return;
                        this._startTime = null, e = n * i
                    }
                    e *= this._updateTimeScale(t);
                    const s = this._updateTime(e),
                        o = this._updateWeight(t);
                    if (o > 0) {
                        const t = this._interpolants,
                            e = this._propertyBindings;
                        switch (this.blendMode) {
                            case 2501:
                                for (let n = 0, i = t.length; n !== i; ++n) t[n].evaluate(s), e[n].accumulateAdditive(o);
                                break;
                            case ro:
                            default:
                                for (let n = 0, r = t.length; n !== r; ++n) t[n].evaluate(s), e[n].accumulate(i, o)
                        }
                    }
                }
                _updateWeight(t) {
                    let e = 0;
                    if (this.enabled) {
                        e = this.weight;
                        const n = this._weightInterpolant;
                        if (null !== n) {
                            const i = n.evaluate(t)[0];
                            e *= i, t > n.parameterPositions[1] && (this.stopFading(), 0 === i && (this.enabled = !1))
                        }
                    }
                    return this._effectiveWeight = e, e
                }
                _updateTimeScale(t) {
                    let e = 0;
                    if (!this.paused) {
                        e = this.timeScale;
                        const n = this._timeScaleInterpolant;
                        if (null !== n) {
                            e *= n.evaluate(t)[0], t > n.parameterPositions[1] && (this.stopWarping(), 0 === e ? this.paused = !0 : this.timeScale = e)
                        }
                    }
                    return this._effectiveTimeScale = e, e
                }
                _updateTime(t) {
                    const e = this._clip.duration,
                        n = this.loop;
                    let i = this.time + t,
                        r = this._loopCount;
                    const s = 2202 === n;
                    if (0 === t) return -1 === r ? i : s && 1 == (1 & r) ? e - i : i;
                    if (2200 === n) {
                        -1 === r && (this._loopCount = 0, this._setEndings(!0, !0, !1));
                        t: {
                            if (i >= e) i = e;
                            else {
                                if (!(i < 0)) {
                                    this.time = i;
                                    break t
                                }
                                i = 0
                            }
                            this.clampWhenFinished ? this.paused = !0 : this.enabled = !1,
                            this.time = i,
                            this._mixer.dispatchEvent({
                                type: "finished",
                                action: this,
                                direction: t < 0 ? -1 : 1
                            })
                        }
                    } else {
                        if (-1 === r && (t >= 0 ? (r = 0, this._setEndings(!0, 0 === this.repetitions, s)) : this._setEndings(0 === this.repetitions, !0, s)), i >= e || i < 0) {
                            const n = Math.floor(i / e);
                            i -= e * n, r += Math.abs(n);
                            const o = this.repetitions - r;
                            if (o <= 0) this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, i = t > 0 ? e : 0, this.time = i, this._mixer.dispatchEvent({
                                type: "finished",
                                action: this,
                                direction: t > 0 ? 1 : -1
                            });
                            else {
                                if (1 === o) {
                                    const e = t < 0;
                                    this._setEndings(e, !e, s)
                                } else this._setEndings(!1, !1, s);
                                this._loopCount = r, this.time = i, this._mixer.dispatchEvent({
                                    type: "loop",
                                    action: this,
                                    loopDelta: n
                                })
                            }
                        } else this.time = i;
                        if (s && 1 == (1 & r)) return e - i
                    }
                    return i
                }
                _setEndings(t, e, n) {
                    const i = this._interpolantSettings;
                    n ? (i.endingStart = no, i.endingEnd = no) : (i.endingStart = t ? this.zeroSlopeAtStart ? no : eo : io, i.endingEnd = e ? this.zeroSlopeAtEnd ? no : eo : io)
                }
                _scheduleFading(t, e, n) {
                    const i = this._mixer,
                        r = i.time;
                    let s = this._weightInterpolant;
                    null === s && (s = i._lendControlInterpolant(), this._weightInterpolant = s);
                    const o = s.parameterPositions,
                        a = s.sampleValues;
                    return o[0] = r, a[0] = e, o[1] = r + t, a[1] = n, this
                }
            }(class extends fo {
                constructor(t) {
                    super(), this._root = t, this._initMemoryManager(), this._accuIndex = 0, this.time = 0, this.timeScale = 1
                }
                _bindAction(t, e) {
                    const n = t._localRoot || this._root,
                        i = t._clip.tracks,
                        r = i.length,
                        s = t._propertyBindings,
                        o = t._interpolants,
                        a = n.uuid,
                        l = this._bindingsByRootAndName;
                    let c = l[a];
                    void 0 === c && (c = {}, l[a] = c);
                    for (let t = 0; t !== r; ++t) {
                        const r = i[t],
                            l = r.name;
                        let u = c[l];
                        if (void 0 !== u) s[t] = u;
                        else {
                            if (u = s[t], void 0 !== u) {
                                null === u._cacheIndex && (++u.referenceCount, this._addInactiveBinding(u, a, l));
                                continue
                            }
                            const i = e && e._propertyBindings[t].binding.parsedPath;
                            u = new Lf(Gf.create(n, l, i), r.ValueTypeName, r.getValueSize()), ++u.referenceCount, this._addInactiveBinding(u, a, l), s[t] = u
                        }
                        o[t].resultBuffer = u.buffer
                    }
                }
                _activateAction(t) {
                    if (!this._isActiveAction(t)) {
                        if (null === t._cacheIndex) {
                            const e = (t._localRoot || this._root).uuid,
                                n = t._clip.uuid,
                                i = this._actionsByClip[n];
                            this._bindAction(t, i && i.knownActions[0]), this._addInactiveAction(t, n, e)
                        }
                        const e = t._propertyBindings;
                        for (let t = 0, n = e.length; t !== n; ++t) {
                            const n = e[t];
                            0 == n.useCount++ && (this._lendBinding(n), n.saveOriginalState())
                        }
                        this._lendAction(t)
                    }
                }
                _deactivateAction(t) {
                    if (this._isActiveAction(t)) {
                        const e = t._propertyBindings;
                        for (let t = 0, n = e.length; t !== n; ++t) {
                            const n = e[t];
                            0 == --n.useCount && (n.restoreOriginalState(), this._takeBackBinding(n))
                        }
                        this._takeBackAction(t)
                    }
                }
                _initMemoryManager() {
                    this._actions = [], this._nActiveActions = 0, this._actionsByClip = {}, this._bindings = [], this._nActiveBindings = 0, this._bindingsByRootAndName = {}, this._controlInterpolants = [], this._nActiveControlInterpolants = 0;
                    const t = this;
                    this.stats = {
                        actions: {
                            get total() {
                                return t._actions.length
                            },
                            get inUse() {
                                return t._nActiveActions
                            }
                        },
                        bindings: {
                            get total() {
                                return t._bindings.length
                            },
                            get inUse() {
                                return t._nActiveBindings
                            }
                        },
                        controlInterpolants: {
                            get total() {
                                return t._controlInterpolants.length
                            },
                            get inUse() {
                                return t._nActiveControlInterpolants
                            }
                        }
                    }
                }
                _isActiveAction(t) {
                    const e = t._cacheIndex;
                    return null !== e && e < this._nActiveActions
                }
                _addInactiveAction(t, e, n) {
                    const i = this._actions,
                        r = this._actionsByClip;
                    let s = r[e];
                    if (void 0 === s) s = {
                        knownActions: [t],
                        actionByRoot: {}
                    }, t._byClipCacheIndex = 0, r[e] = s;
                    else {
                        const e = s.knownActions;
                        t._byClipCacheIndex = e.length, e.push(t)
                    }
                    t._cacheIndex = i.length, i.push(t), s.actionByRoot[n] = t
                }
                _removeInactiveAction(t) {
                    const e = this._actions,
                        n = e[e.length - 1],
                        i = t._cacheIndex;
                    n._cacheIndex = i, e[i] = n, e.pop(), t._cacheIndex = null;
                    const r = t._clip.uuid,
                        s = this._actionsByClip,
                        o = s[r],
                        a = o.knownActions,
                        l = a[a.length - 1],
                        c = t._byClipCacheIndex;
                    l._byClipCacheIndex = c, a[c] = l, a.pop(), t._byClipCacheIndex = null;
                    delete o.actionByRoot[(t._localRoot || this._root).uuid], 0 === a.length && delete s[r], this._removeInactiveBindingsForAction(t)
                }
                _removeInactiveBindingsForAction(t) {
                    const e = t._propertyBindings;
                    for (let t = 0, n = e.length; t !== n; ++t) {
                        const n = e[t];
                        0 == --n.referenceCount && this._removeInactiveBinding(n)
                    }
                }
                _lendAction(t) {
                    const e = this._actions,
                        n = t._cacheIndex,
                        i = this._nActiveActions++,
                        r = e[i];
                    t._cacheIndex = i, e[i] = t, r._cacheIndex = n, e[n] = r
                }
                _takeBackAction(t) {
                    const e = this._actions,
                        n = t._cacheIndex,
                        i = --this._nActiveActions,
                        r = e[i];
                    t._cacheIndex = i, e[i] = t, r._cacheIndex = n, e[n] = r
                }
                _addInactiveBinding(t, e, n) {
                    const i = this._bindingsByRootAndName,
                        r = this._bindings;
                    let s = i[e];
                    void 0 === s && (s = {}, i[e] = s), s[n] = t, t._cacheIndex = r.length, r.push(t)
                }
                _removeInactiveBinding(t) {
                    const e = this._bindings,
                        n = t.binding,
                        i = n.rootNode.uuid,
                        r = n.path,
                        s = this._bindingsByRootAndName,
                        o = s[i],
                        a = e[e.length - 1],
                        l = t._cacheIndex;
                    a._cacheIndex = l, e[l] = a, e.pop(), delete o[r], 0 === Object.keys(o).length && delete s[i]
                }
                _lendBinding(t) {
                    const e = this._bindings,
                        n = t._cacheIndex,
                        i = this._nActiveBindings++,
                        r = e[i];
                    t._cacheIndex = i, e[i] = t, r._cacheIndex = n, e[n] = r
                }
                _takeBackBinding(t) {
                    const e = this._bindings,
                        n = t._cacheIndex,
                        i = --this._nActiveBindings,
                        r = e[i];
                    t._cacheIndex = i, e[i] = t, r._cacheIndex = n, e[n] = r
                }
                _lendControlInterpolant() {
                    const t = this._controlInterpolants,
                        e = this._nActiveControlInterpolants++;
                    let n = t[e];
                    return void 0 === n && (n = new sp(new Float32Array(2), new Float32Array(2), 1, this._controlInterpolantsResultBuffer), n.__cacheIndex = e, t[e] = n), n
                }
                _takeBackControlInterpolant(t) {
                    const e = this._controlInterpolants,
                        n = t.__cacheIndex,
                        i = --this._nActiveControlInterpolants,
                        r = e[i];
                    t.__cacheIndex = i, e[i] = t, r.__cacheIndex = n, e[n] = r
                }
                clipAction(t, e, n) {
                    const i = e || this._root,
                        r = i.uuid;
                    let s = "string" == typeof t ? mp.findByName(i, t) : t;
                    const o = null !== s ? s.uuid : t,
                        a = this._actionsByClip[o];
                    let l = null;
                    if (void 0 === n && (n = null !== s ? s.blendMode : ro), void 0 !== a) {
                        const t = a.actionByRoot[r];
                        if (void 0 !== t && t.blendMode === n) return t;
                        l = a.knownActions[0], null === s && (s = l._clip)
                    }
                    if (null === s) return null;
                    const c = new Wf(this, s, e, n);
                    return this._bindAction(c, l), this._addInactiveAction(c, o, r), c
                }
                existingAction(t, e) {
                    const n = e || this._root,
                        i = n.uuid,
                        r = "string" == typeof t ? mp.findByName(n, t) : t,
                        s = r ? r.uuid : t,
                        o = this._actionsByClip[s];
                    return void 0 !== o && o.actionByRoot[i] || null
                }
                stopAllAction() {
                    const t = this._actions;
                    for (let e = this._nActiveActions - 1; e >= 0; --e) t[e].stop();
                    return this
                }
                update(t) {
                    t *= this.timeScale;
                    const e = this._actions,
                        n = this._nActiveActions,
                        i = this.time += t,
                        r = Math.sign(t),
                        s = this._accuIndex ^= 1;
                    for (let o = 0; o !== n; ++o) {
                        e[o]._update(i, t, r, s)
                    }
                    const o = this._bindings,
                        a = this._nActiveBindings;
                    for (let t = 0; t !== a; ++t) o[t].apply(s);
                    return this
                }
                setTime(t) {
                    this.time = 0;
                    for (let t = 0; t < this._actions.length; t++) this._actions[t].time = 0;
                    return this.update(t)
                }
                getRoot() {
                    return this._root
                }
                uncacheClip(t) {
                    const e = this._actions,
                        n = t.uuid,
                        i = this._actionsByClip,
                        r = i[n];
                    if (void 0 !== r) {
                        const t = r.knownActions;
                        for (let n = 0, i = t.length; n !== i; ++n) {
                            const i = t[n];
                            this._deactivateAction(i);
                            const r = i._cacheIndex,
                                s = e[e.length - 1];
                            i._cacheIndex = null, i._byClipCacheIndex = null, s._cacheIndex = r, e[r] = s, e.pop(), this._removeInactiveBindingsForAction(i)
                        }
                        delete i[n]
                    }
                }
                uncacheRoot(t) {
                    const e = t.uuid,
                        n = this._actionsByClip;
                    for (const t in n) {
                        const i = n[t].actionByRoot[e];
                        void 0 !== i && (this._deactivateAction(i), this._removeInactiveAction(i))
                    }
                    const i = this._bindingsByRootAndName[e];
                    if (void 0 !== i)
                        for (const t in i) {
                            const e = i[t];
                            e.restoreOriginalState(), this._removeInactiveBinding(e)
                        }
                }
                uncacheAction(t, e) {
                    const n = this.existingAction(t, e);
                    null !== n && (this._deactivateAction(n), this._removeInactiveAction(n))
                }
            }).prototype._controlInterpolantsResultBuffer = new Float32Array(1);
            class Vf {
                constructor(t) {
                    "string" == typeof t && (console.warn("THREE.Uniform: Type parameter is no longer needed."), t = arguments[1]), this.value = t
                }
                clone() {
                    return new Vf(void 0 === this.value.clone ? this.value : this.value.clone())
                }
            }

            function jf(t, e, n) {
                hh.call(this, t, e), this.meshPerAttribute = n || 1
            }

            function qf(t, e, n, i, r) {
                this.buffer = t, this.type = e, this.itemSize = n, this.elementSize = i, this.count = r, this.version = 0
            }

            function Xf(t, e, n = 0, i = 1 / 0) {
                this.ray = new ea(t, e), this.near = n, this.far = i, this.camera = null, this.layers = new pa, this.params = {
                    Mesh: {},
                    Line: {
                        threshold: 1
                    },
                    LOD: {},
                    Points: {
                        threshold: 1
                    },
                    Sprite: {}
                }, Object.defineProperties(this.params, {
                    PointCloud: {
                        get: function() {
                            return console.warn("THREE.Raycaster: params.PointCloud has been renamed to params.Points."), this.Points
                        }
                    }
                })
            }

            function Yf(t, e) {
                return t.distance - e.distance
            }

            function Zf(t, e, n, i) {
                if (t.layers.test(e.layers) && t.raycast(e, n), !0 === i) {
                    const i = t.children;
                    for (let t = 0, r = i.length; t < r; t++) Zf(i[t], e, n, !0)
                }
            }
            jf.prototype = Object.assign(Object.create(hh.prototype), {
                constructor: jf,
                isInstancedInterleavedBuffer: !0,
                copy: function(t) {
                    return hh.prototype.copy.call(this, t), this.meshPerAttribute = t.meshPerAttribute, this
                },
                clone: function(t) {
                    const e = hh.prototype.clone.call(this, t);
                    return e.meshPerAttribute = this.meshPerAttribute, e
                },
                toJSON: function(t) {
                    const e = hh.prototype.toJSON.call(this, t);
                    return e.isInstancedInterleavedBuffer = !0, e.meshPerAttribute = this.meshPerAttribute, e
                }
            }), Object.defineProperty(qf.prototype, "needsUpdate", {
                set: function(t) {
                    !0 === t && this.version++
                }
            }), Object.assign(qf.prototype, {
                isGLBufferAttribute: !0,
                setBuffer: function(t) {
                    return this.buffer = t, this
                },
                setType: function(t, e) {
                    return this.type = t, this.elementSize = e, this
                },
                setItemSize: function(t) {
                    return this.itemSize = t, this
                },
                setCount: function(t) {
                    return this.count = t, this
                }
            }), Object.assign(Xf.prototype, {
                set: function(t, e) {
                    this.ray.set(t, e)
                },
                setFromCamera: function(t, e) {
                    e && e.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(e.matrixWorld), this.ray.direction.set(t.x, t.y, .5).unproject(e).sub(this.ray.origin).normalize(), this.camera = e) : e && e.isOrthographicCamera ? (this.ray.origin.set(t.x, t.y, (e.near + e.far) / (e.near - e.far)).unproject(e), this.ray.direction.set(0, 0, -1).transformDirection(e.matrixWorld), this.camera = e) : console.error("THREE.Raycaster: Unsupported camera type: " + e.type)
                },
                intersectObject: function(t, e = !1, n = []) {
                    return Zf(t, this, n, e), n.sort(Yf), n
                },
                intersectObjects: function(t, e = !1, n = []) {
                    for (let i = 0, r = t.length; i < r; i++) Zf(t[i], this, n, e);
                    return n.sort(Yf), n
                }
            });
            const Jf = new yo;
            class Qf {
                constructor(t = new yo(1 / 0, 1 / 0), e = new yo(-1 / 0, -1 / 0)) {
                    this.min = t, this.max = e
                }
                set(t, e) {
                    return this.min.copy(t), this.max.copy(e), this
                }
                setFromPoints(t) {
                    this.makeEmpty();
                    for (let e = 0, n = t.length; e < n; e++) this.expandByPoint(t[e]);
                    return this
                }
                setFromCenterAndSize(t, e) {
                    const n = Jf.copy(e).multiplyScalar(.5);
                    return this.min.copy(t).sub(n), this.max.copy(t).add(n), this
                }
                clone() {
                    return (new this.constructor).copy(this)
                }
                copy(t) {
                    return this.min.copy(t.min), this.max.copy(t.max), this
                }
                makeEmpty() {
                    return this.min.x = this.min.y = 1 / 0, this.max.x = this.max.y = -1 / 0, this
                }
                isEmpty() {
                    return this.max.x < this.min.x || this.max.y < this.min.y
                }
                getCenter(t) {
                    return void 0 === t && (console.warn("THREE.Box2: .getCenter() target is now required"), t = new yo), this.isEmpty() ? t.set(0, 0) : t.addVectors(this.min, this.max).multiplyScalar(.5)
                }
                getSize(t) {
                    return void 0 === t && (console.warn("THREE.Box2: .getSize() target is now required"), t = new yo), this.isEmpty() ? t.set(0, 0) : t.subVectors(this.max, this.min)
                }
                expandByPoint(t) {
                    return this.min.min(t), this.max.max(t), this
                }
                expandByVector(t) {
                    return this.min.sub(t), this.max.add(t), this
                }
                expandByScalar(t) {
                    return this.min.addScalar(-t), this.max.addScalar(t), this
                }
                containsPoint(t) {
                    return !(t.x < this.min.x || t.x > this.max.x || t.y < this.min.y || t.y > this.max.y)
                }
                containsBox(t) {
                    return this.min.x <= t.min.x && t.max.x <= this.max.x && this.min.y <= t.min.y && t.max.y <= this.max.y
                }
                getParameter(t, e) {
                    return void 0 === e && (console.warn("THREE.Box2: .getParameter() target is now required"), e = new yo), e.set((t.x - this.min.x) / (this.max.x - this.min.x), (t.y - this.min.y) / (this.max.y - this.min.y))
                }
                intersectsBox(t) {
                    return !(t.max.x < this.min.x || t.min.x > this.max.x || t.max.y < this.min.y || t.min.y > this.max.y)
                }
                clampPoint(t, e) {
                    return void 0 === e && (console.warn("THREE.Box2: .clampPoint() target is now required"), e = new yo), e.copy(t).clamp(this.min, this.max)
                }
                distanceToPoint(t) {
                    return Jf.copy(t).clamp(this.min, this.max).sub(t).length()
                }
                intersect(t) {
                    return this.min.max(t.min), this.max.min(t.max), this
                }
                union(t) {
                    return this.min.min(t.min), this.max.max(t.max), this
                }
                translate(t) {
                    return this.min.add(t), this.max.add(t), this
                }
                equals(t) {
                    return t.min.equals(this.min) && t.max.equals(this.max)
                }
            }
            Qf.prototype.isBox2 = !0;
            const Kf = new Ao,
                $f = new Ao;

            function tm(t) {
                Ta.call(this), this.material = t, this.render = function() {}, this.hasPositions = !1, this.hasNormals = !1, this.hasColors = !1, this.hasUvs = !1, this.positionArray = null, this.normalArray = null, this.colorArray = null, this.uvArray = null, this.count = 0
            }
            tm.prototype = Object.create(Ta.prototype), tm.prototype.constructor = tm, tm.prototype.isImmediateRenderObject = !0;
            const em = new Ao,
                nm = new na,
                im = new na;

            function rm(t) {
                const e = [];
                t && t.isBone && e.push(t);
                for (let n = 0; n < t.children.length; n++) e.push.apply(e, rm(t.children[n]));
                return e
            }
            const sm = new Float32Array(1),
                om = (new Int32Array(sm.buffer), Math.pow(2, 8), [.125, .215, .35, .446, .526, .582]),
                am = 5 + om.length,
                lm = new Ka({
                    side: 1,
                    depthWrite: !1,
                    depthTest: !1
                }),
                {
                    _lodPlanes: cm,
                    _sizeLods: um,
                    _sigmas: hm
                } = (new zl(new Hl, lm), dm());
            Math.sqrt(5);

            function dm() {
                const t = [],
                    e = [],
                    n = [];
                let i = 8;
                for (let r = 0; r < am; r++) {
                    const s = Math.pow(2, i);
                    e.push(s);
                    let o = 1 / s;
                    r > 4 ? o = om[r - 8 + 4 - 1] : 0 == r && (o = 0), n.push(o);
                    const a = 1 / (s - 1),
                        l = -a / 2,
                        c = 1 + a / 2,
                        u = [l, l, c, l, c, c, l, l, c, c, l, c],
                        h = 6,
                        d = 6,
                        p = 3,
                        f = 2,
                        m = 1,
                        g = new Float32Array(p * d * h),
                        v = new Float32Array(f * d * h),
                        y = new Float32Array(m * d * h);
                    for (let t = 0; t < h; t++) {
                        const e = t % 3 * 2 / 3 - 1,
                            n = t > 2 ? 0 : -1,
                            i = [e, n, 0, e + 2 / 3, n, 0, e + 2 / 3, n + 1, 0, e, n, 0, e + 2 / 3, n + 1, 0, e, n + 1, 0];
                        g.set(i, p * d * t), v.set(u, f * d * t);
                        const r = [t, t, t, t, t, t];
                        y.set(r, m * d * t)
                    }
                    const x = new _l;
                    x.setAttribute("position", new el(g, p)), x.setAttribute("uv", new el(v, f)), x.setAttribute("faceIndex", new el(y, m)), t.push(x), i > 4 && i--
                }
                return {
                    _lodPlanes: t,
                    _sizeLods: e,
                    _sigmas: n
                }
            }
            Ap.create = function(t, e) {
                return console.log("THREE.Curve.create() has been deprecated"), t.prototype = Object.create(Ap.prototype), t.prototype.constructor = t, t.prototype.getPoint = e, t
            }, Yp.prototype.fromPoints = function(t) {
                return console.warn("THREE.Path: .fromPoints() has been renamed to .setFromPoints()."), this.setFromPoints(t)
            }, class extends id {
                constructor(t = 10, e = 10, n = 4473924, i = 8947848) {
                    n = new Qa(n), i = new Qa(i);
                    const r = e / 2,
                        s = t / e,
                        o = t / 2,
                        a = [],
                        l = [];
                    for (let t = 0, c = 0, u = -o; t <= e; t++, u += s) {
                        a.push(-o, 0, u, o, 0, u), a.push(u, 0, -o, u, 0, o);
                        const e = t === r ? n : i;
                        e.toArray(l, c), c += 3, e.toArray(l, c), c += 3, e.toArray(l, c), c += 3, e.toArray(l, c), c += 3
                    }
                    const c = new _l;
                    c.setAttribute("position", new ul(a, 3)), c.setAttribute("color", new ul(l, 3));
                    super(c, new Yh({
                        vertexColors: !0,
                        toneMapped: !1
                    })), this.type = "GridHelper"
                }
            }.prototype.setColors = function() {
                console.error("THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.")
            }, class extends id {
                constructor(t) {
                    const e = rm(t),
                        n = new _l,
                        i = [],
                        r = [],
                        s = new Qa(0, 0, 1),
                        o = new Qa(0, 1, 0);
                    for (let t = 0; t < e.length; t++) {
                        const n = e[t];
                        n.parent && n.parent.isBone && (i.push(0, 0, 0), i.push(0, 0, 0), r.push(s.r, s.g, s.b), r.push(o.r, o.g, o.b))
                    }
                    n.setAttribute("position", new ul(i, 3)), n.setAttribute("color", new ul(r, 3));
                    super(n, new Yh({
                        vertexColors: !0,
                        depthTest: !1,
                        depthWrite: !1,
                        toneMapped: !1,
                        transparent: !0
                    })), this.type = "SkeletonHelper", this.isSkeletonHelper = !0, this.root = t, this.bones = e, this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1
                }
                updateMatrixWorld(t) {
                    const e = this.bones,
                        n = this.geometry,
                        i = n.getAttribute("position");
                    im.copy(this.root.matrixWorld).invert();
                    for (let t = 0, n = 0; t < e.length; t++) {
                        const r = e[t];
                        r.parent && r.parent.isBone && (nm.multiplyMatrices(im, r.matrixWorld), em.setFromMatrixPosition(nm), i.setXYZ(n, em.x, em.y, em.z), nm.multiplyMatrices(im, r.parent.matrixWorld), em.setFromMatrixPosition(nm), i.setXYZ(n + 1, em.x, em.y, em.z), n += 2)
                    }
                    n.getAttribute("position").needsUpdate = !0, super.updateMatrixWorld(t)
                }
            }.prototype.update = function() {
                console.error("THREE.SkeletonHelper: update() no longer needs to be called.")
            }, _p.prototype.extractUrlBase = function(t) {
                return console.warn("THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead."), vf(t)
            }, _p.Handlers = {
                add: function() {
                    console.error("THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead.")
                },
                get: function() {
                    console.error("THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead.")
                }
            }, Qf.prototype.center = function(t) {
                return console.warn("THREE.Box2: .center() has been renamed to .getCenter()."), this.getCenter(t)
            }, Qf.prototype.empty = function() {
                return console.warn("THREE.Box2: .empty() has been renamed to .isEmpty()."), this.isEmpty()
            }, Qf.prototype.isIntersectionBox = function(t) {
                return console.warn("THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(t)
            }, Qf.prototype.size = function(t) {
                return console.warn("THREE.Box2: .size() has been renamed to .getSize()."), this.getSize(t)
            }, Ro.prototype.center = function(t) {
                return console.warn("THREE.Box3: .center() has been renamed to .getCenter()."), this.getCenter(t)
            }, Ro.prototype.empty = function() {
                return console.warn("THREE.Box3: .empty() has been renamed to .isEmpty()."), this.isEmpty()
            }, Ro.prototype.isIntersectionBox = function(t) {
                return console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(t)
            }, Ro.prototype.isIntersectionSphere = function(t) {
                return console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere()."), this.intersectsSphere(t)
            }, Ro.prototype.size = function(t) {
                return console.warn("THREE.Box3: .size() has been renamed to .getSize()."), this.getSize(t)
            }, Xo.prototype.empty = function() {
                return console.warn("THREE.Sphere: .empty() has been renamed to .isEmpty()."), this.isEmpty()
            }, tc.prototype.setFromMatrix = function(t) {
                return console.warn("THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix()."), this.setFromProjectionMatrix(t)
            }, class {
                constructor(t = new Ao, e = new Ao) {
                    this.start = t, this.end = e
                }
                set(t, e) {
                    return this.start.copy(t), this.end.copy(e), this
                }
                copy(t) {
                    return this.start.copy(t.start), this.end.copy(t.end), this
                }
                getCenter(t) {
                    return void 0 === t && (console.warn("THREE.Line3: .getCenter() target is now required"), t = new Ao), t.addVectors(this.start, this.end).multiplyScalar(.5)
                }
                delta(t) {
                    return void 0 === t && (console.warn("THREE.Line3: .delta() target is now required"), t = new Ao), t.subVectors(this.end, this.start)
                }
                distanceSq() {
                    return this.start.distanceToSquared(this.end)
                }
                distance() {
                    return this.start.distanceTo(this.end)
                }
                at(t, e) {
                    return void 0 === e && (console.warn("THREE.Line3: .at() target is now required"), e = new Ao), this.delta(e).multiplyScalar(t).add(this.start)
                }
                closestPointToPointParameter(t, e) {
                    Kf.subVectors(t, this.start), $f.subVectors(this.end, this.start);
                    const n = $f.dot($f);
                    let i = $f.dot(Kf) / n;
                    return e && (i = vo.clamp(i, 0, 1)), i
                }
                closestPointToPoint(t, e, n) {
                    const i = this.closestPointToPointParameter(t, e);
                    return void 0 === n && (console.warn("THREE.Line3: .closestPointToPoint() target is now required"), n = new Ao), this.delta(n).multiplyScalar(i).add(this.start)
                }
                applyMatrix4(t) {
                    return this.start.applyMatrix4(t), this.end.applyMatrix4(t), this
                }
                equals(t) {
                    return t.start.equals(this.start) && t.end.equals(this.end)
                }
                clone() {
                    return (new this.constructor).copy(this)
                }
            }.prototype.center = function(t) {
                return console.warn("THREE.Line3: .center() has been renamed to .getCenter()."), this.getCenter(t)
            }, vo.random16 = function() {
                return console.warn("THREE.Math: .random16() has been deprecated. Use Math.random() instead."), Math.random()
            }, vo.nearestPowerOfTwo = function(t) {
                return console.warn("THREE.Math: .nearestPowerOfTwo() has been renamed to .floorPowerOfTwo()."), vo.floorPowerOfTwo(t)
            }, vo.nextPowerOfTwo = function(t) {
                return console.warn("THREE.Math: .nextPowerOfTwo() has been renamed to .ceilPowerOfTwo()."), vo.ceilPowerOfTwo(t)
            }, xo.prototype.flattenToArrayOffset = function(t, e) {
                return console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."), this.toArray(t, e)
            }, xo.prototype.multiplyVector3 = function(t) {
                return console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."), t.applyMatrix3(this)
            }, xo.prototype.multiplyVector3Array = function() {
                console.error("THREE.Matrix3: .multiplyVector3Array() has been removed.")
            }, xo.prototype.applyToBufferAttribute = function(t) {
                return console.warn("THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead."), t.applyMatrix3(this)
            }, xo.prototype.applyToVector3Array = function() {
                console.error("THREE.Matrix3: .applyToVector3Array() has been removed.")
            }, xo.prototype.getInverse = function(t) {
                return console.warn("THREE.Matrix3: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."), this.copy(t).invert()
            }, na.prototype.extractPosition = function(t) {
                return console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."), this.copyPosition(t)
            }, na.prototype.flattenToArrayOffset = function(t, e) {
                return console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."), this.toArray(t, e)
            }, na.prototype.getPosition = function() {
                return console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead."), (new Ao).setFromMatrixColumn(this, 3)
            }, na.prototype.setRotationFromQuaternion = function(t) {
                return console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."), this.makeRotationFromQuaternion(t)
            }, na.prototype.multiplyToArray = function() {
                console.warn("THREE.Matrix4: .multiplyToArray() has been removed.")
            }, na.prototype.multiplyVector3 = function(t) {
                return console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead."), t.applyMatrix4(this)
            }, na.prototype.multiplyVector4 = function(t) {
                return console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."), t.applyMatrix4(this)
            }, na.prototype.multiplyVector3Array = function() {
                console.error("THREE.Matrix4: .multiplyVector3Array() has been removed.")
            }, na.prototype.rotateAxis = function(t) {
                console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."), t.transformDirection(this)
            }, na.prototype.crossVector = function(t) {
                return console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."), t.applyMatrix4(this)
            }, na.prototype.translate = function() {
                console.error("THREE.Matrix4: .translate() has been removed.")
            }, na.prototype.rotateX = function() {
                console.error("THREE.Matrix4: .rotateX() has been removed.")
            }, na.prototype.rotateY = function() {
                console.error("THREE.Matrix4: .rotateY() has been removed.")
            }, na.prototype.rotateZ = function() {
                console.error("THREE.Matrix4: .rotateZ() has been removed.")
            }, na.prototype.rotateByAxis = function() {
                console.error("THREE.Matrix4: .rotateByAxis() has been removed.")
            }, na.prototype.applyToBufferAttribute = function(t) {
                return console.warn("THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead."), t.applyMatrix4(this)
            }, na.prototype.applyToVector3Array = function() {
                console.error("THREE.Matrix4: .applyToVector3Array() has been removed.")
            }, na.prototype.makeFrustum = function(t, e, n, i, r, s) {
                return console.warn("THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead."), this.makePerspective(t, e, i, n, r, s)
            }, na.prototype.getInverse = function(t) {
                return console.warn("THREE.Matrix4: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."), this.copy(t).invert()
            }, Ra.prototype.isIntersectionLine = function(t) {
                return console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine()."), this.intersectsLine(t)
            }, To.prototype.multiplyVector3 = function(t) {
                return console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."), t.applyQuaternion(this)
            }, To.prototype.inverse = function() {
                return console.warn("THREE.Quaternion: .inverse() has been renamed to invert()."), this.invert()
            }, ea.prototype.isIntersectionBox = function(t) {
                return console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(t)
            }, ea.prototype.isIntersectionPlane = function(t) {
                return console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane()."), this.intersectsPlane(t)
            }, ea.prototype.isIntersectionSphere = function(t) {
                return console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere()."), this.intersectsSphere(t)
            }, Ga.prototype.area = function() {
                return console.warn("THREE.Triangle: .area() has been renamed to .getArea()."), this.getArea()
            }, Ga.prototype.barycoordFromPoint = function(t, e) {
                return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."), this.getBarycoord(t, e)
            }, Ga.prototype.midpoint = function(t) {
                return console.warn("THREE.Triangle: .midpoint() has been renamed to .getMidpoint()."), this.getMidpoint(t)
            }, Ga.prototypenormal = function(t) {
                return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."), this.getNormal(t)
            }, Ga.prototype.plane = function(t) {
                return console.warn("THREE.Triangle: .plane() has been renamed to .getPlane()."), this.getPlane(t)
            }, Ga.barycoordFromPoint = function(t, e, n, i, r) {
                return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."), Ga.getBarycoord(t, e, n, i, r)
            }, Ga.normal = function(t, e, n, i) {
                return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."), Ga.getNormal(t, e, n, i)
            }, Zp.prototype.extractAllPoints = function(t) {
                return console.warn("THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead."), this.extractPoints(t)
            }, Zp.prototype.extrude = function(t) {
                return console.warn("THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead."), new Gd(this, t)
            }, Zp.prototype.makeGeometry = function(t) {
                return console.warn("THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead."), new jd(this, t)
            }, yo.prototype.fromAttribute = function(t, e, n) {
                return console.warn("THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(t, e, n)
            }, yo.prototype.distanceToManhattan = function(t) {
                return console.warn("THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."), this.manhattanDistanceTo(t)
            }, yo.prototype.lengthManhattan = function() {
                return console.warn("THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength()
            }, Ao.prototype.setEulerFromRotationMatrix = function() {
                console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.")
            }, Ao.prototype.setEulerFromQuaternion = function() {
                console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.")
            }, Ao.prototype.getPositionFromMatrix = function(t) {
                return console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."), this.setFromMatrixPosition(t)
            }, Ao.prototype.getScaleFromMatrix = function(t) {
                return console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."), this.setFromMatrixScale(t)
            }, Ao.prototype.getColumnFromMatrix = function(t, e) {
                return console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."), this.setFromMatrixColumn(e, t)
            }, Ao.prototype.applyProjection = function(t) {
                return console.warn("THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead."), this.applyMatrix4(t)
            }, Ao.prototype.fromAttribute = function(t, e, n) {
                return console.warn("THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(t, e, n)
            }, Ao.prototype.distanceToManhattan = function(t) {
                return console.warn("THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."), this.manhattanDistanceTo(t)
            }, Ao.prototype.lengthManhattan = function() {
                return console.warn("THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength()
            }, Eo.prototype.fromAttribute = function(t, e, n) {
                return console.warn("THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(t, e, n)
            }, Eo.prototype.lengthManhattan = function() {
                return console.warn("THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength()
            }, Ta.prototype.getChildByName = function(t) {
                return console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."), this.getObjectByName(t)
            }, Ta.prototype.renderDepth = function() {
                console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.")
            }, Ta.prototype.translate = function(t, e) {
                return console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."), this.translateOnAxis(e, t)
            }, Ta.prototype.getWorldRotation = function() {
                console.error("THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.")
            }, Ta.prototype.applyMatrix = function(t) {
                return console.warn("THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4()."), this.applyMatrix4(t)
            }, Object.defineProperties(Ta.prototype, {
                eulerOrder: {
                    get: function() {
                        return console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order
                    },
                    set: function(t) {
                        console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order = t
                    }
                },
                useQuaternion: {
                    get: function() {
                        console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")
                    },
                    set: function() {
                        console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")
                    }
                }
            }), zl.prototype.setDrawMode = function() {
                console.error("THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.")
            }, Object.defineProperties(zl.prototype, {
                drawMode: {
                    get: function() {
                        return console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode."), 0
                    },
                    set: function() {
                        console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.")
                    }
                }
            }), Object.defineProperties(Ph.prototype, {
                objects: {
                    get: function() {
                        return console.warn("THREE.LOD: .objects has been renamed to .levels."), this.levels
                    }
                }
            }), Object.defineProperty(Gh.prototype, "useVertexTexture", {
                get: function() {
                    console.warn("THREE.Skeleton: useVertexTexture has been removed.")
                },
                set: function() {
                    console.warn("THREE.Skeleton: useVertexTexture has been removed.")
                }
            }), zh.prototype.initBones = function() {
                console.error("THREE.SkinnedMesh: initBones() has been removed.")
            }, Object.defineProperty(Ap.prototype, "__arcLengthDivisions", {
                get: function() {
                    return console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."), this.arcLengthDivisions
                },
                set: function(t) {
                    console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."), this.arcLengthDivisions = t
                }
            }), ql.prototype.setLens = function(t, e) {
                console.warn("THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup."), void 0 !== e && (this.filmGauge = e), this.setFocalLength(t)
            }, Object.defineProperties(Jp.prototype, {
                onlyShadow: {
                    set: function() {
                        console.warn("THREE.Light: .onlyShadow has been removed.")
                    }
                },
                shadowCameraFov: {
                    set: function(t) {
                        console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov."), this.shadow.camera.fov = t
                    }
                },
                shadowCameraLeft: {
                    set: function(t) {
                        console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left."), this.shadow.camera.left = t
                    }
                },
                shadowCameraRight: {
                    set: function(t) {
                        console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right."), this.shadow.camera.right = t
                    }
                },
                shadowCameraTop: {
                    set: function(t) {
                        console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top."), this.shadow.camera.top = t
                    }
                },
                shadowCameraBottom: {
                    set: function(t) {
                        console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom."), this.shadow.camera.bottom = t
                    }
                },
                shadowCameraNear: {
                    set: function(t) {
                        console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near."), this.shadow.camera.near = t
                    }
                },
                shadowCameraFar: {
                    set: function(t) {
                        console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far."), this.shadow.camera.far = t
                    }
                },
                shadowCameraVisible: {
                    set: function() {
                        console.warn("THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.")
                    }
                },
                shadowBias: {
                    set: function(t) {
                        console.warn("THREE.Light: .shadowBias is now .shadow.bias."), this.shadow.bias = t
                    }
                },
                shadowDarkness: {
                    set: function() {
                        console.warn("THREE.Light: .shadowDarkness has been removed.")
                    }
                },
                shadowMapWidth: {
                    set: function(t) {
                        console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width."), this.shadow.mapSize.width = t
                    }
                },
                shadowMapHeight: {
                    set: function(t) {
                        console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height."), this.shadow.mapSize.height = t
                    }
                }
            }), Object.defineProperties(el.prototype, {
                length: {
                    get: function() {
                        return console.warn("THREE.BufferAttribute: .length has been deprecated. Use .count instead."), this.array.length
                    }
                },
                dynamic: {
                    get: function() {
                        return console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."), this.usage === ho
                    },
                    set: function() {
                        console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."), this.setUsage(ho)
                    }
                }
            }), el.prototype.setDynamic = function(t) {
                return console.warn("THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead."), this.setUsage(!0 === t ? ho : uo), this
            }, el.prototype.copyIndicesArray = function() {
                console.error("THREE.BufferAttribute: .copyIndicesArray() has been removed.")
            }, el.prototype.setArray = function() {
                console.error("THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers")
            }, _l.prototype.addIndex = function(t) {
                console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex()."), this.setIndex(t)
            }, _l.prototype.addAttribute = function(t, e) {
                return console.warn("THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute()."), e && e.isBufferAttribute || e && e.isInterleavedBufferAttribute ? "index" === t ? (console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."), this.setIndex(e), this) : this.setAttribute(t, e) : (console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."), this.setAttribute(t, new el(arguments[1], arguments[2])))
            }, _l.prototype.addDrawCall = function(t, e, n) {
                void 0 !== n && console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset."), console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup()."), this.addGroup(t, e)
            }, _l.prototype.clearDrawCalls = function() {
                console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups()."), this.clearGroups()
            }, _l.prototype.computeOffsets = function() {
                console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.")
            }, _l.prototype.removeAttribute = function(t) {
                return console.warn("THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute()."), this.deleteAttribute(t)
            }, _l.prototype.applyMatrix = function(t) {
                return console.warn("THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4()."), this.applyMatrix4(t)
            }, Object.defineProperties(_l.prototype, {
                drawcalls: {
                    get: function() {
                        return console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups."), this.groups
                    }
                },
                offsets: {
                    get: function() {
                        return console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups."), this.groups
                    }
                }
            }), Object.defineProperties(yf.prototype, {
                maxInstancedCount: {
                    get: function() {
                        return console.warn("THREE.InstancedBufferGeometry: .maxInstancedCount has been renamed to .instanceCount."), this.instanceCount
                    },
                    set: function(t) {
                        console.warn("THREE.InstancedBufferGeometry: .maxInstancedCount has been renamed to .instanceCount."), this.instanceCount = t
                    }
                }
            }), Object.defineProperties(Xf.prototype, {
                linePrecision: {
                    get: function() {
                        return console.warn("THREE.Raycaster: .linePrecision has been deprecated. Use .params.Line.threshold instead."), this.params.Line.threshold
                    },
                    set: function(t) {
                        console.warn("THREE.Raycaster: .linePrecision has been deprecated. Use .params.Line.threshold instead."), this.params.Line.threshold = t
                    }
                }
            }), Object.defineProperties(hh.prototype, {
                dynamic: {
                    get: function() {
                        return console.warn("THREE.InterleavedBuffer: .length has been deprecated. Use .usage instead."), this.usage === ho
                    },
                    set: function(t) {
                        console.warn("THREE.InterleavedBuffer: .length has been deprecated. Use .usage instead."), this.setUsage(t)
                    }
                }
            }), hh.prototype.setDynamic = function(t) {
                return console.warn("THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead."), this.setUsage(!0 === t ? ho : uo), this
            }, hh.prototype.setArray = function() {
                console.error("THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers")
            }, Gd.prototype.getArrays = function() {
                console.error("THREE.ExtrudeGeometry: .getArrays() has been removed.")
            }, Gd.prototype.addShapeList = function() {
                console.error("THREE.ExtrudeGeometry: .addShapeList() has been removed.")
            }, Gd.prototype.addShape = function() {
                console.error("THREE.ExtrudeGeometry: .addShape() has been removed.")
            }, uh.prototype.dispose = function() {
                console.error("THREE.Scene: .dispose() has been removed.")
            }, Object.defineProperties(Vf.prototype, {
                dynamic: {
                    set: function() {
                        console.warn("THREE.Uniform: .dynamic has been removed. Use object.onBeforeRender() instead.")
                    }
                },
                onUpdate: {
                    value: function() {
                        return console.warn("THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead."), this
                    }
                }
            }), Object.defineProperties(Va.prototype, {
                wrapAround: {
                    get: function() {
                        console.warn("THREE.Material: .wrapAround has been removed.")
                    },
                    set: function() {
                        console.warn("THREE.Material: .wrapAround has been removed.")
                    }
                },
                overdraw: {
                    get: function() {
                        console.warn("THREE.Material: .overdraw has been removed.")
                    },
                    set: function() {
                        console.warn("THREE.Material: .overdraw has been removed.")
                    }
                },
                wrapRGB: {
                    get: function() {
                        return console.warn("THREE.Material: .wrapRGB has been removed."), new Qa
                    }
                },
                shading: {
                    get: function() {
                        console.error("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.")
                    },
                    set: function(t) {
                        console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."), this.flatShading = 1 === t
                    }
                },
                stencilMask: {
                    get: function() {
                        return console.warn("THREE." + this.type + ": .stencilMask has been removed. Use .stencilFuncMask instead."), this.stencilFuncMask
                    },
                    set: function(t) {
                        console.warn("THREE." + this.type + ": .stencilMask has been removed. Use .stencilFuncMask instead."), this.stencilFuncMask = t
                    }
                }
            }), Object.defineProperties(Jd.prototype, {
                metal: {
                    get: function() {
                        return console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead."), !1
                    },
                    set: function() {
                        console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead")
                    }
                }
            }), Object.defineProperties(Zd.prototype, {
                transparency: {
                    get: function() {
                        return console.warn("THREE.MeshPhysicalMaterial: .transparency has been renamed to .transmission."), this.transmission
                    },
                    set: function(t) {
                        console.warn("THREE.MeshPhysicalMaterial: .transparency has been renamed to .transmission."), this.transmission = t
                    }
                }
            }), Object.defineProperties(Vl.prototype, {
                derivatives: {
                    get: function() {
                        return console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives."), this.extensions.derivatives
                    },
                    set: function(t) {
                        console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives."), this.extensions.derivatives = t
                    }
                }
            }), ah.prototype.clearTarget = function(t, e, n, i) {
                console.warn("THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead."), this.setRenderTarget(t), this.clear(e, n, i)
            }, ah.prototype.animate = function(t) {
                console.warn("THREE.WebGLRenderer: .animate() is now .setAnimationLoop()."), this.setAnimationLoop(t)
            }, ah.prototype.getCurrentRenderTarget = function() {
                return console.warn("THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget()."), this.getRenderTarget()
            }, ah.prototype.getMaxAnisotropy = function() {
                return console.warn("THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy()."), this.capabilities.getMaxAnisotropy()
            }, ah.prototype.getPrecision = function() {
                return console.warn("THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision."), this.capabilities.precision
            }, ah.prototype.resetGLState = function() {
                return console.warn("THREE.WebGLRenderer: .resetGLState() is now .state.reset()."), this.state.reset()
            }, ah.prototype.supportsFloatTextures = function() {
                return console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."), this.extensions.get("OES_texture_float")
            }, ah.prototype.supportsHalfFloatTextures = function() {
                return console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."), this.extensions.get("OES_texture_half_float")
            }, ah.prototype.supportsStandardDerivatives = function() {
                return console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."), this.extensions.get("OES_standard_derivatives")
            }, ah.prototype.supportsCompressedTextureS3TC = function() {
                return console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."), this.extensions.get("WEBGL_compressed_texture_s3tc")
            }, ah.prototype.supportsCompressedTexturePVRTC = function() {
                return console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."), this.extensions.get("WEBGL_compressed_texture_pvrtc")
            }, ah.prototype.supportsBlendMinMax = function() {
                return console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."), this.extensions.get("EXT_blend_minmax")
            }, ah.prototype.supportsVertexTextures = function() {
                return console.warn("THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures."), this.capabilities.vertexTextures
            }, ah.prototype.supportsInstancedArrays = function() {
                return console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."), this.extensions.get("ANGLE_instanced_arrays")
            }, ah.prototype.enableScissorTest = function(t) {
                console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest()."), this.setScissorTest(t)
            }, ah.prototype.initMaterial = function() {
                console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.")
            }, ah.prototype.addPrePlugin = function() {
                console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.")
            }, ah.prototype.addPostPlugin = function() {
                console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.")
            }, ah.prototype.updateShadowMap = function() {
                console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.")
            }, ah.prototype.setFaceCulling = function() {
                console.warn("THREE.WebGLRenderer: .setFaceCulling() has been removed.")
            }, ah.prototype.allocTextureUnit = function() {
                console.warn("THREE.WebGLRenderer: .allocTextureUnit() has been removed.")
            }, ah.prototype.setTexture = function() {
                console.warn("THREE.WebGLRenderer: .setTexture() has been removed.")
            }, ah.prototype.setTexture2D = function() {
                console.warn("THREE.WebGLRenderer: .setTexture2D() has been removed.")
            }, ah.prototype.setTextureCube = function() {
                console.warn("THREE.WebGLRenderer: .setTextureCube() has been removed.")
            }, ah.prototype.getActiveMipMapLevel = function() {
                return console.warn("THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel()."), this.getActiveMipmapLevel()
            }, Object.defineProperties(ah.prototype, {
                shadowMapEnabled: {
                    get: function() {
                        return this.shadowMap.enabled
                    },
                    set: function(t) {
                        console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."), this.shadowMap.enabled = t
                    }
                },
                shadowMapType: {
                    get: function() {
                        return this.shadowMap.type
                    },
                    set: function(t) {
                        console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type."), this.shadowMap.type = t
                    }
                },
                shadowMapCullFace: {
                    get: function() {
                        console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")
                    },
                    set: function() {
                        console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")
                    }
                },
                context: {
                    get: function() {
                        return console.warn("THREE.WebGLRenderer: .context has been removed. Use .getContext() instead."), this.getContext()
                    }
                },
                vr: {
                    get: function() {
                        return console.warn("THREE.WebGLRenderer: .vr has been renamed to .xr"), this.xr
                    }
                },
                gammaInput: {
                    get: function() {
                        return console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead."), !1
                    },
                    set: function() {
                        console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.")
                    }
                },
                gammaOutput: {
                    get: function() {
                        return console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."), !1
                    },
                    set: function(t) {
                        console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."), this.outputEncoding = !0 === t ? oo : so
                    }
                },
                toneMappingWhitePoint: {
                    get: function() {
                        return console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed."), 1
                    },
                    set: function() {
                        console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.")
                    }
                }
            }), Object.defineProperties(Ku.prototype, {
                cullFace: {
                    get: function() {
                        console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")
                    },
                    set: function() {
                        console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")
                    }
                },
                renderReverseSided: {
                    get: function() {
                        console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")
                    },
                    set: function() {
                        console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")
                    }
                },
                renderSingleSided: {
                    get: function() {
                        console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")
                    },
                    set: function() {
                        console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")
                    }
                }
            }), Object.defineProperties(Do.prototype, {
                wrapS: {
                    get: function() {
                        return console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS
                    },
                    set: function(t) {
                        console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS = t
                    }
                },
                wrapT: {
                    get: function() {
                        return console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this.texture.wrapT
                    },
                    set: function(t) {
                        console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this.texture.wrapT = t
                    }
                },
                magFilter: {
                    get: function() {
                        return console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."), this.texture.magFilter
                    },
                    set: function(t) {
                        console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."), this.texture.magFilter = t
                    }
                },
                minFilter: {
                    get: function() {
                        return console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."), this.texture.minFilter
                    },
                    set: function(t) {
                        console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."), this.texture.minFilter = t
                    }
                },
                anisotropy: {
                    get: function() {
                        return console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."), this.texture.anisotropy
                    },
                    set: function(t) {
                        console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."), this.texture.anisotropy = t
                    }
                },
                offset: {
                    get: function() {
                        return console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."), this.texture.offset
                    },
                    set: function(t) {
                        console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."), this.texture.offset = t
                    }
                },
                repeat: {
                    get: function() {
                        return console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."), this.texture.repeat
                    },
                    set: function(t) {
                        console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."), this.texture.repeat = t
                    }
                },
                format: {
                    get: function() {
                        return console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."), this.texture.format
                    },
                    set: function(t) {
                        console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."), this.texture.format = t
                    }
                },
                type: {
                    get: function() {
                        return console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."), this.texture.type
                    },
                    set: function(t) {
                        console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."), this.texture.type = t
                    }
                },
                generateMipmaps: {
                    get: function() {
                        return console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."), this.texture.generateMipmaps
                    },
                    set: function(t) {
                        console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."), this.texture.generateMipmaps = t
                    }
                }
            }), Object.defineProperties(Cf.prototype, {
                load: {
                    value: function(t) {
                        console.warn("THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.");
                        const e = this;
                        return (new Df).load(t, (function(t) {
                            e.setBuffer(t)
                        })), this
                    }
                },
                startTime: {
                    set: function() {
                        console.warn("THREE.Audio: .startTime is now .play( delay ).")
                    }
                }
            }), class {
                constructor(t, e = 2048) {
                    this.analyser = t.context.createAnalyser(), this.analyser.fftSize = e, this.data = new Uint8Array(this.analyser.frequencyBinCount), t.getOutput().connect(this.analyser)
                }
                getFrequencyData() {
                    return this.analyser.getByteFrequencyData(this.data), this.data
                }
                getAverageFrequency() {
                    let t = 0;
                    const e = this.getFrequencyData();
                    for (let n = 0; n < e.length; n++) t += e[n];
                    return t / e.length
                }
            }.prototype.getData = function() {
                return console.warn("THREE.AudioAnalyser: .getData() is now .getFrequencyData()."), this.getFrequencyData()
            }, Yl.prototype.updateCubeMap = function(t, e) {
                return console.warn("THREE.CubeCamera: .updateCubeMap() is now .update()."), this.update(t, e)
            }, Yl.prototype.clear = function(t, e, n, i) {
                return console.warn("THREE.CubeCamera: .clear() is now .renderTarget.clear()."), this.renderTarget.clear(t, e, n, i)
            }, bo.crossOrigin = void 0, bo.loadTexture = function(t, e, n, i) {
                console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.");
                const r = new Tp;
                r.setCrossOrigin(this.crossOrigin);
                const s = r.load(t, n, void 0, i);
                return e && (s.mapping = e), s
            }, bo.loadTextureCube = function(t, e, n, i) {
                console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.");
                const r = new Ep;
                r.setCrossOrigin(this.crossOrigin);
                const s = r.load(t, n, void 0, i);
                return e && (s.mapping = e), s
            }, bo.loadCompressedTexture = function() {
                console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.")
            }, bo.loadCompressedTextureCube = function() {
                console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.")
            };
            "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", {
                detail: {
                    revision: "126"
                }
            })), "undefined" != typeof window && (window.__THREE__ ? console.warn("WARNING: Multiple instances of Three.js being imported.") : window.__THREE__ = "126");
            var pm = n(157),
                fm = {
                    uniforms: {
                        tDiffuse: {
                            value: null
                        },
                        opacity: {
                            value: 1
                        }
                    },
                    vertexShader: ["varying vec2 vUv;", "void main() {", "\tvUv = uv;", "\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
                    fragmentShader: ["uniform float opacity;", "uniform sampler2D tDiffuse;", "varying vec2 vUv;", "void main() {", "\tvec4 texel = texture2D( tDiffuse, vUv );", "\tgl_FragColor = opacity * texel;", "}"].join("\n")
                };

            function mm() {
                this.enabled = !0, this.needsSwap = !0, this.clear = !1, this.renderToScreen = !1
            }
            Object.assign(mm.prototype, {
                setSize: function() {},
                render: function() {
                    console.error("THREE.Pass: .render() must be implemented in derived pass.")
                }
            }), mm.FullScreenQuad = function() {
                var t = new uf(-1, 1, 1, -1, 0, 1),
                    e = new ic(2, 2),
                    n = function(t) {
                        this._mesh = new zl(e, t)
                    };
                return Object.defineProperty(n.prototype, "material", {
                    get: function() {
                        return this._mesh.material
                    },
                    set: function(t) {
                        this._mesh.material = t
                    }
                }), Object.assign(n.prototype, {
                    dispose: function() {
                        this._mesh.geometry.dispose()
                    },
                    render: function(e) {
                        e.render(this._mesh, t)
                    }
                }), n
            }();
            var gm = function(t, e) {
                mm.call(this), this.textureID = void 0 !== e ? e : "tDiffuse", t instanceof Vl ? (this.uniforms = t.uniforms, this.material = t) : t && (this.uniforms = Wl.clone(t.uniforms), this.material = new Vl({
                    defines: Object.assign({}, t.defines),
                    uniforms: this.uniforms,
                    vertexShader: t.vertexShader,
                    fragmentShader: t.fragmentShader
                })), this.fsQuad = new mm.FullScreenQuad(this.material)
            };
            gm.prototype = Object.assign(Object.create(mm.prototype), {
                constructor: gm,
                render: function(t, e, n) {
                    this.uniforms[this.textureID] && (this.uniforms[this.textureID].value = n.texture), this.fsQuad.material = this.material, this.renderToScreen ? (t.setRenderTarget(null), this.fsQuad.render(t)) : (t.setRenderTarget(e), this.clear && t.clear(t.autoClearColor, t.autoClearDepth, t.autoClearStencil), this.fsQuad.render(t))
                }
            });
            var vm = function(t, e) {
                mm.call(this), this.scene = t, this.camera = e, this.clear = !0, this.needsSwap = !1, this.inverse = !1
            };
            vm.prototype = Object.assign(Object.create(mm.prototype), {
                constructor: vm,
                render: function(t, e, n) {
                    var i, r, s = t.getContext(),
                        o = t.state;
                    o.buffers.color.setMask(!1), o.buffers.depth.setMask(!1), o.buffers.color.setLocked(!0), o.buffers.depth.setLocked(!0), this.inverse ? (i = 0, r = 1) : (i = 1, r = 0), o.buffers.stencil.setTest(!0), o.buffers.stencil.setOp(s.REPLACE, s.REPLACE, s.REPLACE), o.buffers.stencil.setFunc(s.ALWAYS, i, 4294967295), o.buffers.stencil.setClear(r), o.buffers.stencil.setLocked(!0), t.setRenderTarget(n), this.clear && t.clear(), t.render(this.scene, this.camera), t.setRenderTarget(e), this.clear && t.clear(), t.render(this.scene, this.camera), o.buffers.color.setLocked(!1), o.buffers.depth.setLocked(!1), o.buffers.stencil.setLocked(!1), o.buffers.stencil.setFunc(s.EQUAL, 1, 4294967295), o.buffers.stencil.setOp(s.KEEP, s.KEEP, s.KEEP), o.buffers.stencil.setLocked(!0)
                }
            });
            var ym = function() {
                mm.call(this), this.needsSwap = !1
            };
            ym.prototype = Object.create(mm.prototype), Object.assign(ym.prototype, {
                render: function(t) {
                    t.state.buffers.stencil.setLocked(!1), t.state.buffers.stencil.setTest(!1)
                }
            });
            var xm = function(t, e) {
                if (this.renderer = t, void 0 === e) {
                    var n = {
                            minFilter: Hs,
                            magFilter: Hs,
                            format: Zs
                        },
                        i = t.getSize(new yo);
                    this._pixelRatio = t.getPixelRatio(), this._width = i.width, this._height = i.height, (e = new Do(this._width * this._pixelRatio, this._height * this._pixelRatio, n)).texture.name = "EffectComposer.rt1"
                } else this._pixelRatio = 1, this._width = e.width, this._height = e.height;
                this.renderTarget1 = e, this.renderTarget2 = e.clone(), this.renderTarget2.texture.name = "EffectComposer.rt2", this.writeBuffer = this.renderTarget1, this.readBuffer = this.renderTarget2, this.renderToScreen = !0, this.passes = [], void 0 === fm && console.error("THREE.EffectComposer relies on CopyShader"), void 0 === gm && console.error("THREE.EffectComposer relies on ShaderPass"), this.copyPass = new gm(fm), this.clock = new Tf
            };
            Object.assign(xm.prototype, {
                swapBuffers: function() {
                    var t = this.readBuffer;
                    this.readBuffer = this.writeBuffer, this.writeBuffer = t
                },
                addPass: function(t) {
                    this.passes.push(t), t.setSize(this._width * this._pixelRatio, this._height * this._pixelRatio)
                },
                insertPass: function(t, e) {
                    this.passes.splice(e, 0, t), t.setSize(this._width * this._pixelRatio, this._height * this._pixelRatio)
                },
                removePass: function(t) {
                    const e = this.passes.indexOf(t); - 1 !== e && this.passes.splice(e, 1)
                },
                isLastEnabledPass: function(t) {
                    for (var e = t + 1; e < this.passes.length; e++)
                        if (this.passes[e].enabled) return !1;
                    return !0
                },
                render: function(t) {
                    void 0 === t && (t = this.clock.getDelta());
                    var e, n, i = this.renderer.getRenderTarget(),
                        r = !1,
                        s = this.passes.length;
                    for (n = 0; n < s; n++)
                        if (!1 !== (e = this.passes[n]).enabled) {
                            if (e.renderToScreen = this.renderToScreen && this.isLastEnabledPass(n), e.render(this.renderer, this.writeBuffer, this.readBuffer, t, r), e.needsSwap) {
                                if (r) {
                                    var o = this.renderer.getContext(),
                                        a = this.renderer.state.buffers.stencil;
                                    a.setFunc(o.NOTEQUAL, 1, 4294967295), this.copyPass.render(this.renderer, this.writeBuffer, this.readBuffer, t), a.setFunc(o.EQUAL, 1, 4294967295)
                                }
                                this.swapBuffers()
                            }
                            void 0 !== vm && (e instanceof vm ? r = !0 : e instanceof ym && (r = !1))
                        }
                    this.renderer.setRenderTarget(i)
                },
                reset: function(t) {
                    if (void 0 === t) {
                        var e = this.renderer.getSize(new yo);
                        this._pixelRatio = this.renderer.getPixelRatio(), this._width = e.width, this._height = e.height, (t = this.renderTarget1.clone()).setSize(this._width * this._pixelRatio, this._height * this._pixelRatio)
                    }
                    this.renderTarget1.dispose(), this.renderTarget2.dispose(), this.renderTarget1 = t, this.renderTarget2 = t.clone(), this.writeBuffer = this.renderTarget1, this.readBuffer = this.renderTarget2
                },
                setSize: function(t, e) {
                    this._width = t, this._height = e;
                    var n = this._width * this._pixelRatio,
                        i = this._height * this._pixelRatio;
                    this.renderTarget1.setSize(n, i), this.renderTarget2.setSize(n, i);
                    for (var r = 0; r < this.passes.length; r++) this.passes[r].setSize(n, i)
                },
                setPixelRatio: function(t) {
                    this._pixelRatio = t, this.setSize(this._width, this._height)
                }
            });
            var _m = function() {
                this.enabled = !0, this.needsSwap = !0, this.clear = !1, this.renderToScreen = !1
            };
            Object.assign(_m.prototype, {
                setSize: function() {},
                render: function() {
                    console.error("THREE.Pass: .render() must be implemented in derived pass.")
                }
            }), _m.FullScreenQuad = function() {
                var t = new uf(-1, 1, 1, -1, 0, 1),
                    e = new ic(2, 2),
                    n = function(t) {
                        this._mesh = new zl(e, t)
                    };
                return Object.defineProperty(n.prototype, "material", {
                    get: function() {
                        return this._mesh.material
                    },
                    set: function(t) {
                        this._mesh.material = t
                    }
                }), Object.assign(n.prototype, {
                    dispose: function() {
                        this._mesh.geometry.dispose()
                    },
                    render: function(e) {
                        e.render(this._mesh, t)
                    }
                }), n
            }();
            var bm = function(t, e, n, i, r) {
                mm.call(this), this.scene = t, this.camera = e, this.overrideMaterial = n, this.clearColor = i, this.clearAlpha = void 0 !== r ? r : 0, this.clear = !0, this.clearDepth = !1, this.needsSwap = !1, this._oldClearColor = new Qa
            };
            bm.prototype = Object.assign(Object.create(mm.prototype), {
                constructor: bm,
                render: function(t, e, n) {
                    var i, r, s = t.autoClear;
                    t.autoClear = !1, void 0 !== this.overrideMaterial && (r = this.scene.overrideMaterial, this.scene.overrideMaterial = this.overrideMaterial), this.clearColor && (t.getClearColor(this._oldClearColor), i = t.getClearAlpha(), t.setClearColor(this.clearColor, this.clearAlpha)), this.clearDepth && t.clearDepth(), t.setRenderTarget(this.renderToScreen ? null : n), this.clear && t.clear(t.autoClearColor, t.autoClearDepth, t.autoClearStencil), t.render(this.scene, this.camera), this.clearColor && t.setClearColor(this._oldClearColor, i), void 0 !== this.overrideMaterial && (this.scene.overrideMaterial = r), t.autoClear = s
                }
            });
            var wm = {
                    uniforms: {
                        damp: {
                            value: .96
                        },
                        tOld: {
                            value: null
                        },
                        tNew: {
                            value: null
                        }
                    },
                    vertexShader: ["varying vec2 vUv;", "void main() {", "\tvUv = uv;", "\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
                    fragmentShader: ["uniform float damp;", "uniform sampler2D tOld;", "uniform sampler2D tNew;", "varying vec2 vUv;", "vec4 when_gt( vec4 x, float y ) {", "\treturn max( sign( x - y ), 0.0 );", "}", "void main() {", "\tvec4 texelOld = texture2D( tOld, vUv );", "\tvec4 texelNew = texture2D( tNew, vUv );", "\ttexelOld *= damp * when_gt( texelOld, 0.1 );", "\tgl_FragColor = max(texelNew, texelOld);", "}"].join("\n")
                },
                Mm = function(t) {
                    mm.call(this), void 0 === wm && console.error("THREE.AfterimagePass relies on AfterimageShader"), this.shader = wm, this.uniforms = Wl.clone(this.shader.uniforms), this.uniforms.damp.value = void 0 !== t ? t : .96, this.textureComp = new Do(window.innerWidth, window.innerHeight, {
                        minFilter: Hs,
                        magFilter: Bs,
                        format: Zs
                    }), this.textureOld = new Do(window.innerWidth, window.innerHeight, {
                        minFilter: Hs,
                        magFilter: Bs,
                        format: Zs
                    }), this.shaderMaterial = new Vl({
                        uniforms: this.uniforms,
                        vertexShader: this.shader.vertexShader,
                        fragmentShader: this.shader.fragmentShader
                    }), this.compFsQuad = new mm.FullScreenQuad(this.shaderMaterial);
                    var e = new Ka;
                    this.copyFsQuad = new mm.FullScreenQuad(e)
                };
            Mm.prototype = Object.assign(Object.create(mm.prototype), {
                constructor: Mm,
                render: function(t, e, n) {
                    this.uniforms.tOld.value = this.textureOld.texture, this.uniforms.tNew.value = n.texture, t.setRenderTarget(this.textureComp), this.compFsQuad.render(t), this.copyFsQuad.material.map = this.textureComp.texture, this.renderToScreen ? (t.setRenderTarget(null), this.copyFsQuad.render(t)) : (t.setRenderTarget(e), this.clear && t.clear(), this.copyFsQuad.render(t));
                    var i = this.textureOld;
                    this.textureOld = this.textureComp, this.textureComp = i
                },
                setSize: function(t, e) {
                    this.textureComp.setSize(t, e), this.textureOld.setSize(t, e)
                }
            });
            let Sm = document.getElementById("intro-cylinder");
            const Em = new uh,
                Dm = new uf(-hr / 2, hr / 2, dr / 2, -dr / 2, 5, 2e3),
                Tm = new ah({
                    alpha: !0,
                    antialias: !0
                }),
                Am = (new Tp).load(pm),
                Cm = new Ka({
                    map: Am,
                    side: 2,
                    transparent: !0
                }),
                Lm = new xm(Tm),
                Rm = new bm(Em, Dm);
            Lm.addPass(Rm);
            const Pm = new Mm(.7);
            Lm.addPass(Pm);
            const Fm = {
                    r: yr(350 * pr, 320, 190),
                    h: yr(300 * pr, 270, 160),
                    rs: 32
                },
                Om = {
                    x: yr(30 * pr, 30, 30),
                    y: yr(-320 * fr, -170, -70),
                    z: -1e3,
                    rx: -20 * Math.PI / 180,
                    ry: 0,
                    rz: 0
                },
                Im = {
                    x: 0,
                    y: 0,
                    z: 0,
                    rx: 0,
                    ry: 0,
                    rz: -20 * Math.PI / 180
                },
                Nm = new zl(new pd(Fm.r, Fm.r, Fm.h, Fm.rs, Fm.h, !0), Cm);
            let Bm = null;
            const zm = () => {
                    Dm.rotation.set(Im.rx, Im.ry, Im.rz), Nm.position.set(Om.x, Om.y, Om.z), Nm.rotation.set(Om.rx, Om.ry, Om.rz), Lm.render()
                },
                km = () => {
                    Bm && (Bm.kill(), Bm = null)
                },
                Hm = () => {
                    if (Sm = document.getElementById("intro-cylinder"), Sm) {
                        Sm.appendChild(Tm.domElement);
                        const t = mr ? 1 : window.devicePixelRatio,
                            e = hr * t | 0,
                            n = dr * t | 0;
                        Tm.setSize(e, n, !1), Lm.setSize(e, n), Em.add(Nm)
                    }
                };
            let Um = document.querySelector(".intro"),
                Gm = null;
            const Wm = () => {
                    if (!Gm) {
                        const t = Um.querySelector(".sun"),
                            e = Um.querySelectorAll("h2"),
                            n = Um.querySelector("#intro-cylinder"),
                            i = Um.querySelector("p"),
                            r = new ur(e[0], {
                                type: "chars"
                            }),
                            s = new ur(e[1], {
                                type: "chars"
                            }),
                            o = new ur(e[2], {
                                type: "chars"
                            }),
                            a = new ur(i, {
                                type: "lines"
                            });
                        Gm = xi.timeline({
                            paused: 1,
                            onStart: () => {
                                Bm && Bm.play()
                            },
                            onReverseComplete: () => {
                                Bm && Bm.pause()
                            }
                        }).from(n, {
                            autoAlpha: 0,
                            duration: 1.4,
                            ease: "app.ease"
                        }, "<").from(t, {
                            autoAlpha: 0,
                            scale: 0,
                            duration: 1.2,
                            ease: "app.ease"
                        }, "<").from(e[0], {
                            x: -150,
                            duration: 1,
                            ease: "app.out"
                        }, "<.1").add(Sr(r), "<").from(e[1], {
                            x: 120,
                            duration: .9,
                            ease: "app.out"
                        }, "<.1").add(Sr(s), "<").from(e[2], {
                            x: -120,
                            duration: .8,
                            ease: "app.out"
                        }, "<.1").add(Sr(o), "<").add(Er(a), "<.5")
                    }
                },
                Vm = () => {
                    Um = document.querySelector(".intro"), Um && (Bm || (Bm = xi.timeline({
                        paused: 1
                    }).fromTo(Om, {
                        ry: 0
                    }, {
                        ry: 2 * -Math.PI,
                        duration: 20,
                        repeat: -1,
                        ease: "none",
                        onUpdate: () => {
                            zm()
                        }
                    })), Wm())
                };
            let jm = document.querySelector(".chapter-01"),
                qm = null;
            const Xm = () => {
                jm = document.querySelector(".chapter-01"), jm && (qm || (qm = xi.timeline({
                    paused: 1
                }).set(jm, {
                    visibility: "visible"
                }).add(Ar(jm))))
            };
            let Ym = document.querySelector(".chapter-02"),
                Zm = null;
            const Jm = () => {
                Ym = document.querySelector(".chapter-02"), Ym && (Zm || (Ym.querySelector(".c-md"), Ym.querySelector("img"), Zm = xi.timeline({
                    paused: 1
                }).set(Ym, {
                    visibility: "visible"
                }).add(Ar(Ym))))
            };
            let Qm = document.querySelector(".chapter-03"),
                Km = null;
            const $m = () => {
                Qm = document.querySelector(".chapter-03"), Qm && (Km || (Km = xi.timeline({
                    paused: 1
                }).set(Qm, {
                    visibility: "visible"
                }).add(Ar(Qm))))
            };
            let tg = document.querySelector(".chapter-04"),
                eg = null;
            const ng = () => {
                tg = document.querySelector(".chapter-04"), tg && (eg || (eg = xi.timeline({
                    paused: 1
                }).set(tg, {
                    visibility: "visible"
                }).add(Ar(tg))))
            };
            let ig = document.querySelector(".slider > div"),
                rg = ig ? ig.querySelectorAll("div") : [],
                sg = 870,
                og = 280,
                ag = 30 + sg + 0 + og - og - 0,
                lg = (rg.length - 2) * sg,
                cg = new vr(.16, 0, .84, 1),
                ug = new vr(.34, 0, 0, 1),
                hg = {
                    x: 0
                };
            const dg = (t, e) => {
                    xi.set(ig, {
                        x: -t
                    }), rg.forEach(((e, n) => {
                        const i = sg * n - ag,
                            r = t - i,
                            s = i + 30,
                            o = t - s,
                            a = t - (s + sg);
                        if (r < 0 || a > og) xi.set(e, {
                            autoAlpha: 0
                        });
                        else if (a > 0) {
                            const t = a / og,
                                n = cg.get(t);
                            xi.set(e, {
                                autoAlpha: .8 * (1 - n),
                                scale: 1 + .3 * n,
                                x: 0 * t,
                                transformOrigin: "0% 20%"
                            })
                        } else if (o >= 0) {
                            const t = o / sg,
                                n = ug.get(t);
                            xi.set(e, {
                                autoAlpha: .4 * n + .4,
                                scale: .76 * t + .24,
                                x: 0 * n,
                                transformOrigin: "0% 0%"
                            })
                        } else {
                            const t = r / 30,
                                n = ug.get(t);
                            xi.set(e, {
                                autoAlpha: .4 * n,
                                scale: .14 * t + .1,
                                transformOrigin: "0% 0%"
                            })
                        }
                    })), e && (hg.x = t)
                },
                pg = t => {
                    return e = sg * t, xi.to(hg, {
                        x: e,
                        duration: 1.4,
                        ease: "app.out",
                        onUpdate: () => {
                            dg(e > lg ? hg.x % lg : hg.x)
                        }
                    });
                    var e
                },
                fg = () => {
                    ig = document.querySelector(".slider > div"), rg = ig ? ig.querySelectorAll("div") : [], ig && (sg = rg[1].getBoundingClientRect().left - ig.getBoundingClientRect().left, ag = 30 + sg, lg = (rg.length - 2) * sg, dg(hg.x))
                };
            let mg = document.querySelector(".slider"),
                gg = null;
            const vg = () => {
                mg = document.querySelector(".slider"), mg && (gg || (gg = xi.timeline({
                    paused: 1
                }).to(".intro", {
                    autoAlpha: 0,
                    scale: 1.4,
                    duration: .8,
                    ease: "app.out"
                }, "<").from(mg, {
                    autoAlpha: 0,
                    duration: .8,
                    ease: "app.out"
                }, "<.1").from(mg, {
                    scale: .74,
                    duration: .4,
                    ease: "app.out"
                }, "<")))
            };
            let yg = -1,
                xg = !1,
                _g = [];
            const bg = t => {
                    if (!(Gr && 0 !== Gr.progress() || xg)) {
                        const n = yg;
                        Math.abs(t - n) > 4 && 0 !== t && (t = 4 * Math.floor(n / 4) + t);
                        const i = t > 4 ? t % 4 == 0 ? 4 : t % 4 : t,
                            r = _g[n > 4 ? n % 4 == 0 ? 4 : n % 4 : n],
                            s = _g[i],
                            o = t - 1,
                            a = i - 1;
                        if (t >= 0 && s !== r) {
                            xg = !0;
                            Mr(0 === t ? 1 : 600 / 1100), e = i, Ts.forEach(((t, n) => {
                                t.classList.toggle("-a", n === e)
                            })), -1 === n ? s.play() : (t > 0 && (0 === n ? ((t, e) => {
                                dg(sg * t, e)
                            })(o, !0) : setTimeout((() => {
                                pg(o)
                            }), 300)), setTimeout((() => {
                                s.play();
                                const e = document.querySelectorAll(".slider img");
                                0 === t ? gg.reverse() : (gg.play(), 0 === n && xi.timeline().from(e[a], {
                                    autoAlpha: 0,
                                    duration: .8,
                                    ease: "app.out"
                                }, "<").from(e[a + 1], {
                                    autoAlpha: 0,
                                    duration: .8,
                                    ease: "app.out"
                                }, "<.4"))
                            }), 800), r.reverse()), yg = t
                        }
                    }
                    var e
                },
                wg = t => {
                    if (!t.ctrlKey) {
                        t.preventDefault();
                        const e = yg + Math.sign(t.deltaY);
                        bg(e)
                    }
                },
                Mg = t => {
                    const e = document.querySelector(".chapter-01").getBoundingClientRect().top,
                        n = document.querySelector(".chapter-02").getBoundingClientRect().top,
                        i = document.querySelector(".chapter-03").getBoundingClientRect().top,
                        r = document.querySelector(".chapter-04").getBoundingClientRect().top;
                    qm.paused() && e < .7 * dr ? qm.play() : Zm.paused() && n < .7 * dr ? Zm.play() : Km.paused() && i < .7 * dr ? Km.play() : eg.paused() && r < .7 * dr && eg.play()
                },
                Sg = () => {
                    _g && (Gm && (km(), Gm.kill(), Gm = null), qm && (qm.kill(), qm = null), Zm && (Zm.kill(), Zm = null), Km && (Km.kill(), Km = null), eg && (eg.kill(), eg = null), mr ? (gg && (gg.kill(), gg = null), window.removeEventListener("wheel", wg)) : window.removeEventListener("scroll", Mg), yg = -1, xg = !1, _g = [])
                };

            function Eg(t, e) {
                if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
            }

            function Dg(t, e) {
                for (var n = 0; n < e.length; n++) {
                    var i = e[n];
                    i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i)
                }
            }

            function Tg(t, e, n) {
                return e && Dg(t.prototype, e), n && Dg(t, n), t
            }

            function Ag(t, e, n) {
                return e in t ? Object.defineProperty(t, e, {
                    value: n,
                    enumerable: !0,
                    configurable: !0,
                    writable: !0
                }) : t[e] = n, t
            }

            function Cg(t, e) {
                var n = Object.keys(t);
                if (Object.getOwnPropertySymbols) {
                    var i = Object.getOwnPropertySymbols(t);
                    e && (i = i.filter((function(e) {
                        return Object.getOwnPropertyDescriptor(t, e).enumerable
                    }))), n.push.apply(n, i)
                }
                return n
            }

            function Lg(t) {
                for (var e = 1; e < arguments.length; e++) {
                    var n = null != arguments[e] ? arguments[e] : {};
                    e % 2 ? Cg(Object(n), !0).forEach((function(e) {
                        Ag(t, e, n[e])
                    })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : Cg(Object(n)).forEach((function(e) {
                        Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(n, e))
                    }))
                }
                return t
            }

            function Rg(t, e) {
                if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
                t.prototype = Object.create(e && e.prototype, {
                    constructor: {
                        value: t,
                        writable: !0,
                        configurable: !0
                    }
                }), e && Fg(t, e)
            }

            function Pg(t) {
                return (Pg = Object.setPrototypeOf ? Object.getPrototypeOf : function(t) {
                    return t.__proto__ || Object.getPrototypeOf(t)
                })(t)
            }

            function Fg(t, e) {
                return (Fg = Object.setPrototypeOf || function(t, e) {
                    return t.__proto__ = e, t
                })(t, e)
            }

            function Og(t) {
                if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                return t
            }

            function Ig(t, e) {
                return !e || "object" != typeof e && "function" != typeof e ? Og(t) : e
            }

            function Ng(t) {
                var e = function() {
                    if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
                    if (Reflect.construct.sham) return !1;
                    if ("function" == typeof Proxy) return !0;
                    try {
                        return Date.prototype.toString.call(Reflect.construct(Date, [], (function() {}))), !0
                    } catch (t) {
                        return !1
                    }
                }();
                return function() {
                    var n, i = Pg(t);
                    if (e) {
                        var r = Pg(this).constructor;
                        n = Reflect.construct(i, arguments, r)
                    } else n = i.apply(this, arguments);
                    return Ig(this, n)
                }
            }

            function Bg(t, e, n) {
                return (Bg = "undefined" != typeof Reflect && Reflect.get ? Reflect.get : function(t, e, n) {
                    var i = function(t, e) {
                        for (; !Object.prototype.hasOwnProperty.call(t, e) && null !== (t = Pg(t)););
                        return t
                    }(t, e);
                    if (i) {
                        var r = Object.getOwnPropertyDescriptor(i, e);
                        return r.get ? r.get.call(n) : r.value
                    }
                })(t, e, n || t)
            }

            function zg(t, e) {
                return function(t) {
                    if (Array.isArray(t)) return t
                }(t) || function(t, e) {
                    if ("undefined" == typeof Symbol || !(Symbol.iterator in Object(t))) return;
                    var n = [],
                        i = !0,
                        r = !1,
                        s = void 0;
                    try {
                        for (var o, a = t[Symbol.iterator](); !(i = (o = a.next()).done) && (n.push(o.value), !e || n.length !== e); i = !0);
                    } catch (t) {
                        r = !0, s = t
                    } finally {
                        try {
                            i || null == a.return || a.return()
                        } finally {
                            if (r) throw s
                        }
                    }
                    return n
                }(t, e) || Hg(t, e) || function() {
                    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
                }()
            }

            function kg(t) {
                return function(t) {
                    if (Array.isArray(t)) return Ug(t)
                }(t) || function(t) {
                    if ("undefined" != typeof Symbol && Symbol.iterator in Object(t)) return Array.from(t)
                }(t) || Hg(t) || function() {
                    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
                }()
            }

            function Hg(t, e) {
                if (t) {
                    if ("string" == typeof t) return Ug(t, e);
                    var n = Object.prototype.toString.call(t).slice(8, -1);
                    return "Object" === n && t.constructor && (n = t.constructor.name), "Map" === n || "Set" === n ? Array.from(t) : "Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? Ug(t, e) : void 0
                }
            }

            function Ug(t, e) {
                (null == e || e > t.length) && (e = t.length);
                for (var n = 0, i = new Array(e); n < e; n++) i[n] = t[n];
                return i
            }
            var Gg = {
                    el: document,
                    name: "scroll",
                    offset: [0, 0],
                    repeat: !1,
                    smooth: !1,
                    initPosition: {
                        x: 0,
                        y: 0
                    },
                    direction: "vertical",
                    gestureDirection: "vertical",
                    reloadOnContextChange: !1,
                    lerp: .1,
                    class: "is-inview",
                    scrollbarContainer: !1,
                    scrollbarClass: "c-scrollbar",
                    scrollingClass: "has-scroll-scrolling",
                    draggingClass: "has-scroll-dragging",
                    smoothClass: "has-scroll-smooth",
                    initClass: "has-scroll-init",
                    getSpeed: !1,
                    getDirection: !1,
                    scrollFromAnywhere: !1,
                    multiplier: 1,
                    firefoxMultiplier: 50,
                    touchMultiplier: 2,
                    resetNativeScroll: !0,
                    tablet: {
                        smooth: !1,
                        direction: "vertical",
                        gestureDirection: "vertical",
                        breakpoint: 1024
                    },
                    smartphone: {
                        smooth: !1,
                        direction: "vertical",
                        gestureDirection: "vertical"
                    }
                },
                Wg = function() {
                    function t() {
                        var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                        Eg(this, t), Object.assign(this, Gg, e), this.smartphone = Gg.smartphone, e.smartphone && Object.assign(this.smartphone, e.smartphone), this.tablet = Gg.tablet, e.tablet && Object.assign(this.tablet, e.tablet), this.namespace = "locomotive", this.html = document.documentElement, this.windowHeight = window.innerHeight, this.windowWidth = window.innerWidth, this.windowMiddle = {
                            x: this.windowWidth / 2,
                            y: this.windowHeight / 2
                        }, this.els = {}, this.currentElements = {}, this.listeners = {}, this.hasScrollTicking = !1, this.hasCallEventSet = !1, this.checkScroll = this.checkScroll.bind(this), this.checkResize = this.checkResize.bind(this), this.checkEvent = this.checkEvent.bind(this), this.instance = {
                            scroll: {
                                x: 0,
                                y: 0
                            },
                            limit: {
                                x: this.html.offsetWidth,
                                y: this.html.offsetHeight
                            },
                            currentElements: this.currentElements
                        }, this.isMobile ? this.isTablet ? this.context = "tablet" : this.context = "smartphone" : this.context = "desktop", this.isMobile && (this.direction = this[this.context].direction), "horizontal" === this.direction ? this.directionAxis = "x" : this.directionAxis = "y", this.getDirection && (this.instance.direction = null), this.getDirection && (this.instance.speed = 0), this.html.classList.add(this.initClass), window.addEventListener("resize", this.checkResize, !1)
                    }
                    return Tg(t, [{
                        key: "init",
                        value: function() {
                            this.initEvents()
                        }
                    }, {
                        key: "checkScroll",
                        value: function() {
                            this.dispatchScroll()
                        }
                    }, {
                        key: "checkResize",
                        value: function() {
                            var t = this;
                            this.resizeTick || (this.resizeTick = !0, requestAnimationFrame((function() {
                                t.resize(), t.resizeTick = !1
                            })))
                        }
                    }, {
                        key: "resize",
                        value: function() {}
                    }, {
                        key: "checkContext",
                        value: function() {
                            if (this.reloadOnContextChange) {
                                this.isMobile = /Android|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || "MacIntel" === navigator.platform && navigator.maxTouchPoints > 1 || this.windowWidth < this.tablet.breakpoint, this.isTablet = this.isMobile && this.windowWidth >= this.tablet.breakpoint;
                                var t = this.context;
                                if (this.isMobile ? this.isTablet ? this.context = "tablet" : this.context = "smartphone" : this.context = "desktop", t != this.context)("desktop" == t ? this.smooth : this[t].smooth) != ("desktop" == this.context ? this.smooth : this[this.context].smooth) && window.location.reload()
                            }
                        }
                    }, {
                        key: "initEvents",
                        value: function() {
                            var t = this;
                            this.scrollToEls = this.el.querySelectorAll("[data-".concat(this.name, "-to]")), this.setScrollTo = this.setScrollTo.bind(this), this.scrollToEls.forEach((function(e) {
                                e.addEventListener("click", t.setScrollTo, !1)
                            }))
                        }
                    }, {
                        key: "setScrollTo",
                        value: function(t) {
                            t.preventDefault(), this.scrollTo(t.currentTarget.getAttribute("data-".concat(this.name, "-href")) || t.currentTarget.getAttribute("href"), {
                                offset: t.currentTarget.getAttribute("data-".concat(this.name, "-offset"))
                            })
                        }
                    }, {
                        key: "addElements",
                        value: function() {}
                    }, {
                        key: "detectElements",
                        value: function(t) {
                            var e = this,
                                n = this.instance.scroll.y,
                                i = n + this.windowHeight,
                                r = this.instance.scroll.x,
                                s = r + this.windowWidth;
                            Object.entries(this.els).forEach((function(o) {
                                var a = zg(o, 2),
                                    l = a[0],
                                    c = a[1];
                                if (!c || c.inView && !t || ("horizontal" === e.direction ? s >= c.left && r < c.right && e.setInView(c, l) : i >= c.top && n < c.bottom && e.setInView(c, l)), c && c.inView)
                                    if ("horizontal" === e.direction) {
                                        var u = c.right - c.left;
                                        c.progress = (e.instance.scroll.x - (c.left - e.windowWidth)) / (u + e.windowWidth), (s < c.left || r > c.right) && e.setOutOfView(c, l)
                                    } else {
                                        var h = c.bottom - c.top;
                                        c.progress = (e.instance.scroll.y - (c.top - e.windowHeight)) / (h + e.windowHeight), (i < c.top || n > c.bottom) && e.setOutOfView(c, l)
                                    }
                            })), this.hasScrollTicking = !1
                        }
                    }, {
                        key: "setInView",
                        value: function(t, e) {
                            this.els[e].inView = !0, t.el.classList.add(t.class), this.currentElements[e] = t, t.call && this.hasCallEventSet && (this.dispatchCall(t, "enter"), t.repeat || (this.els[e].call = !1))
                        }
                    }, {
                        key: "setOutOfView",
                        value: function(t, e) {
                            var n = this;
                            this.els[e].inView = !1, Object.keys(this.currentElements).forEach((function(t) {
                                t === e && delete n.currentElements[t]
                            })), t.call && this.hasCallEventSet && this.dispatchCall(t, "exit"), t.repeat && t.el.classList.remove(t.class)
                        }
                    }, {
                        key: "dispatchCall",
                        value: function(t, e) {
                            this.callWay = e, this.callValue = t.call.split(",").map((function(t) {
                                return t.trim()
                            })), this.callObj = t, 1 == this.callValue.length && (this.callValue = this.callValue[0]);
                            var n = new Event(this.namespace + "call");
                            this.el.dispatchEvent(n)
                        }
                    }, {
                        key: "dispatchScroll",
                        value: function() {
                            var t = new Event(this.namespace + "scroll");
                            this.el.dispatchEvent(t)
                        }
                    }, {
                        key: "setEvents",
                        value: function(t, e) {
                            this.listeners[t] || (this.listeners[t] = []);
                            var n = this.listeners[t];
                            n.push(e), 1 === n.length && this.el.addEventListener(this.namespace + t, this.checkEvent, !1), "call" === t && (this.hasCallEventSet = !0, this.detectElements(!0))
                        }
                    }, {
                        key: "unsetEvents",
                        value: function(t, e) {
                            if (this.listeners[t]) {
                                var n = this.listeners[t],
                                    i = n.indexOf(e);
                                i < 0 || (n.splice(i, 1), 0 === n.index && this.el.removeEventListener(this.namespace + t, this.checkEvent, !1))
                            }
                        }
                    }, {
                        key: "checkEvent",
                        value: function(t) {
                            var e = this,
                                n = t.type.replace(this.namespace, ""),
                                i = this.listeners[n];
                            i && 0 !== i.length && i.forEach((function(t) {
                                switch (n) {
                                    case "scroll":
                                        return t(e.instance);
                                    case "call":
                                        return t(e.callValue, e.callWay, e.callObj);
                                    default:
                                        return t()
                                }
                            }))
                        }
                    }, {
                        key: "startScroll",
                        value: function() {}
                    }, {
                        key: "stopScroll",
                        value: function() {}
                    }, {
                        key: "setScroll",
                        value: function(t, e) {
                            this.instance.scroll = {
                                x: 0,
                                y: 0
                            }
                        }
                    }, {
                        key: "destroy",
                        value: function() {
                            var t = this;
                            window.removeEventListener("resize", this.checkResize, !1), Object.keys(this.listeners).forEach((function(e) {
                                t.el.removeEventListener(t.namespace + e, t.checkEvent, !1)
                            })), this.listeners = {}, this.scrollToEls.forEach((function(e) {
                                e.removeEventListener("click", t.setScrollTo, !1)
                            })), this.html.classList.remove(this.initClass)
                        }
                    }]), t
                }(),
                Vg = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof window ? window : void 0 !== n.g ? n.g : "undefined" != typeof self ? self : {};

            function jg(t, e) {
                return t(e = {
                    exports: {}
                }, e.exports), e.exports
            }
            var qg = jg((function(t, e) {
                    t.exports = {
                        polyfill: function() {
                            var t = window,
                                e = document;
                            if (!("scrollBehavior" in e.documentElement.style) || !0 === t.__forceSmoothScrollPolyfill__) {
                                var n, i = t.HTMLElement || t.Element,
                                    r = {
                                        scroll: t.scroll || t.scrollTo,
                                        scrollBy: t.scrollBy,
                                        elementScroll: i.prototype.scroll || a,
                                        scrollIntoView: i.prototype.scrollIntoView
                                    },
                                    s = t.performance && t.performance.now ? t.performance.now.bind(t.performance) : Date.now,
                                    o = (n = t.navigator.userAgent, new RegExp(["MSIE ", "Trident/", "Edge/"].join("|")).test(n) ? 1 : 0);
                                t.scroll = t.scrollTo = function() {
                                    void 0 !== arguments[0] && (!0 !== l(arguments[0]) ? f.call(t, e.body, void 0 !== arguments[0].left ? ~~arguments[0].left : t.scrollX || t.pageXOffset, void 0 !== arguments[0].top ? ~~arguments[0].top : t.scrollY || t.pageYOffset) : r.scroll.call(t, void 0 !== arguments[0].left ? arguments[0].left : "object" != typeof arguments[0] ? arguments[0] : t.scrollX || t.pageXOffset, void 0 !== arguments[0].top ? arguments[0].top : void 0 !== arguments[1] ? arguments[1] : t.scrollY || t.pageYOffset))
                                }, t.scrollBy = function() {
                                    void 0 !== arguments[0] && (l(arguments[0]) ? r.scrollBy.call(t, void 0 !== arguments[0].left ? arguments[0].left : "object" != typeof arguments[0] ? arguments[0] : 0, void 0 !== arguments[0].top ? arguments[0].top : void 0 !== arguments[1] ? arguments[1] : 0) : f.call(t, e.body, ~~arguments[0].left + (t.scrollX || t.pageXOffset), ~~arguments[0].top + (t.scrollY || t.pageYOffset)))
                                }, i.prototype.scroll = i.prototype.scrollTo = function() {
                                    if (void 0 !== arguments[0])
                                        if (!0 !== l(arguments[0])) {
                                            var t = arguments[0].left,
                                                e = arguments[0].top;
                                            f.call(this, this, void 0 === t ? this.scrollLeft : ~~t, void 0 === e ? this.scrollTop : ~~e)
                                        } else {
                                            if ("number" == typeof arguments[0] && void 0 === arguments[1]) throw new SyntaxError("Value could not be converted");
                                            r.elementScroll.call(this, void 0 !== arguments[0].left ? ~~arguments[0].left : "object" != typeof arguments[0] ? ~~arguments[0] : this.scrollLeft, void 0 !== arguments[0].top ? ~~arguments[0].top : void 0 !== arguments[1] ? ~~arguments[1] : this.scrollTop)
                                        }
                                }, i.prototype.scrollBy = function() {
                                    void 0 !== arguments[0] && (!0 !== l(arguments[0]) ? this.scroll({
                                        left: ~~arguments[0].left + this.scrollLeft,
                                        top: ~~arguments[0].top + this.scrollTop,
                                        behavior: arguments[0].behavior
                                    }) : r.elementScroll.call(this, void 0 !== arguments[0].left ? ~~arguments[0].left + this.scrollLeft : ~~arguments[0] + this.scrollLeft, void 0 !== arguments[0].top ? ~~arguments[0].top + this.scrollTop : ~~arguments[1] + this.scrollTop))
                                }, i.prototype.scrollIntoView = function() {
                                    if (!0 !== l(arguments[0])) {
                                        var n = d(this),
                                            i = n.getBoundingClientRect(),
                                            s = this.getBoundingClientRect();
                                        n !== e.body ? (f.call(this, n, n.scrollLeft + s.left - i.left, n.scrollTop + s.top - i.top), "fixed" !== t.getComputedStyle(n).position && t.scrollBy({
                                            left: i.left,
                                            top: i.top,
                                            behavior: "smooth"
                                        })) : t.scrollBy({
                                            left: s.left,
                                            top: s.top,
                                            behavior: "smooth"
                                        })
                                    } else r.scrollIntoView.call(this, void 0 === arguments[0] || arguments[0])
                                }
                            }

                            function a(t, e) {
                                this.scrollLeft = t, this.scrollTop = e
                            }

                            function l(t) {
                                if (null === t || "object" != typeof t || void 0 === t.behavior || "auto" === t.behavior || "instant" === t.behavior) return !0;
                                if ("object" == typeof t && "smooth" === t.behavior) return !1;
                                throw new TypeError("behavior member of ScrollOptions " + t.behavior + " is not a valid value for enumeration ScrollBehavior.")
                            }

                            function c(t, e) {
                                return "Y" === e ? t.clientHeight + o < t.scrollHeight : "X" === e ? t.clientWidth + o < t.scrollWidth : void 0
                            }

                            function u(e, n) {
                                var i = t.getComputedStyle(e, null)["overflow" + n];
                                return "auto" === i || "scroll" === i
                            }

                            function h(t) {
                                var e = c(t, "Y") && u(t, "Y"),
                                    n = c(t, "X") && u(t, "X");
                                return e || n
                            }

                            function d(t) {
                                for (; t !== e.body && !1 === h(t);) t = t.parentNode || t.host;
                                return t
                            }

                            function p(e) {
                                var n, i, r, o, a = (s() - e.startTime) / 468;
                                o = a = a > 1 ? 1 : a, n = .5 * (1 - Math.cos(Math.PI * o)), i = e.startX + (e.x - e.startX) * n, r = e.startY + (e.y - e.startY) * n, e.method.call(e.scrollable, i, r), i === e.x && r === e.y || t.requestAnimationFrame(p.bind(t, e))
                            }

                            function f(n, i, o) {
                                var l, c, u, h, d = s();
                                n === e.body ? (l = t, c = t.scrollX || t.pageXOffset, u = t.scrollY || t.pageYOffset, h = r.scroll) : (l = n, c = n.scrollLeft, u = n.scrollTop, h = a), p({
                                    scrollable: l,
                                    method: h,
                                    startTime: d,
                                    startX: c,
                                    startY: u,
                                    x: i,
                                    y: o
                                })
                            }
                        }
                    }
                })),
                Xg = (qg.polyfill, function(t) {
                    Rg(n, t);
                    var e = Ng(n);

                    function n() {
                        var t, i = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                        return Eg(this, n), (t = e.call(this, i)).resetNativeScroll && (history.scrollRestoration && (history.scrollRestoration = "manual"), window.scrollTo(0, 0)), window.addEventListener("scroll", t.checkScroll, !1), void 0 === window.smoothscrollPolyfill && (window.smoothscrollPolyfill = qg, window.smoothscrollPolyfill.polyfill()), t
                    }
                    return Tg(n, [{
                        key: "init",
                        value: function() {
                            this.instance.scroll.y = window.pageYOffset, this.addElements(), this.detectElements(), Bg(Pg(n.prototype), "init", this).call(this)
                        }
                    }, {
                        key: "checkScroll",
                        value: function() {
                            var t = this;
                            Bg(Pg(n.prototype), "checkScroll", this).call(this), this.getDirection && this.addDirection(), this.getSpeed && (this.addSpeed(), this.speedTs = Date.now()), this.instance.scroll.y = window.pageYOffset, Object.entries(this.els).length && (this.hasScrollTicking || (requestAnimationFrame((function() {
                                t.detectElements()
                            })), this.hasScrollTicking = !0))
                        }
                    }, {
                        key: "addDirection",
                        value: function() {
                            window.pageYOffset > this.instance.scroll.y ? "down" !== this.instance.direction && (this.instance.direction = "down") : window.pageYOffset < this.instance.scroll.y && "up" !== this.instance.direction && (this.instance.direction = "up")
                        }
                    }, {
                        key: "addSpeed",
                        value: function() {
                            window.pageYOffset != this.instance.scroll.y ? this.instance.speed = (window.pageYOffset - this.instance.scroll.y) / Math.max(1, Date.now() - this.speedTs) : this.instance.speed = 0
                        }
                    }, {
                        key: "resize",
                        value: function() {
                            Object.entries(this.els).length && (this.windowHeight = window.innerHeight, this.updateElements())
                        }
                    }, {
                        key: "addElements",
                        value: function() {
                            var t = this;
                            this.els = {}, this.el.querySelectorAll("[data-" + this.name + "]").forEach((function(e, n) {
                                e.getBoundingClientRect();
                                var i, r, s, o = e.dataset[t.name + "Class"] || t.class,
                                    a = "string" == typeof e.dataset[t.name + "Id"] ? e.dataset[t.name + "Id"] : n,
                                    l = "string" == typeof e.dataset[t.name + "Offset"] ? e.dataset[t.name + "Offset"].split(",") : t.offset,
                                    c = e.dataset[t.name + "Repeat"],
                                    u = e.dataset[t.name + "Call"],
                                    h = e.dataset[t.name + "Target"],
                                    d = (s = void 0 !== h ? document.querySelector("".concat(h)) : e).getBoundingClientRect();
                                i = d.top + t.instance.scroll.y, r = d.left + t.instance.scroll.x;
                                var p = i + s.offsetHeight,
                                    f = r + s.offsetWidth;
                                c = "false" != c && (null != c || t.repeat);
                                var m = t.getRelativeOffset(l),
                                    g = {
                                        el: e,
                                        targetEl: s,
                                        id: a,
                                        class: o,
                                        top: i += m[0],
                                        bottom: p -= m[1],
                                        left: r,
                                        right: f,
                                        offset: l,
                                        progress: 0,
                                        repeat: c,
                                        inView: !1,
                                        call: u
                                    };
                                t.els[a] = g, e.classList.contains(o) && t.setInView(t.els[a], a)
                            }))
                        }
                    }, {
                        key: "updateElements",
                        value: function() {
                            var t = this;
                            Object.entries(this.els).forEach((function(e) {
                                var n = zg(e, 2),
                                    i = n[0],
                                    r = n[1],
                                    s = r.targetEl.getBoundingClientRect().top + t.instance.scroll.y,
                                    o = s + r.targetEl.offsetHeight,
                                    a = t.getRelativeOffset(r.offset);
                                t.els[i].top = s + a[0], t.els[i].bottom = o - a[1]
                            })), this.hasScrollTicking = !1
                        }
                    }, {
                        key: "getRelativeOffset",
                        value: function(t) {
                            var e = [0, 0];
                            if (t)
                                for (var n = 0; n < t.length; n++) "string" == typeof t[n] ? t[n].includes("%") ? e[n] = parseInt(t[n].replace("%", "") * this.windowHeight / 100) : e[n] = parseInt(t[n]) : e[n] = t[n];
                            return e
                        }
                    }, {
                        key: "scrollTo",
                        value: function(t) {
                            var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},
                                n = parseInt(e.offset) || 0,
                                i = !!e.callback && e.callback;
                            if ("string" == typeof t) {
                                if ("top" === t) t = this.html;
                                else if ("bottom" === t) t = this.html.offsetHeight - window.innerHeight;
                                else if (!(t = document.querySelector(t))) return
                            } else if ("number" == typeof t) t = parseInt(t);
                            else if (!t || !t.tagName) return void console.warn("`target` parameter is not valid");
                            n = "number" != typeof t ? t.getBoundingClientRect().top + n + this.instance.scroll.y : t + n;
                            var r = function() {
                                return parseInt(window.pageYOffset) === parseInt(n)
                            };
                            if (i) {
                                if (r()) return void i();
                                var s = function t() {
                                    r() && (window.removeEventListener("scroll", t), i())
                                };
                                window.addEventListener("scroll", s)
                            }
                            window.scrollTo({
                                top: n,
                                behavior: "smooth"
                            })
                        }
                    }, {
                        key: "update",
                        value: function() {
                            this.addElements(), this.detectElements()
                        }
                    }, {
                        key: "destroy",
                        value: function() {
                            Bg(Pg(n.prototype), "destroy", this).call(this), window.removeEventListener("scroll", this.checkScroll, !1)
                        }
                    }]), n
                }(Wg)),
                Yg = Object.getOwnPropertySymbols,
                Zg = Object.prototype.hasOwnProperty,
                Jg = Object.prototype.propertyIsEnumerable;

            function Qg(t) {
                if (null == t) throw new TypeError("Object.assign cannot be called with null or undefined");
                return Object(t)
            }
            var Kg = function() {
                try {
                    if (!Object.assign) return !1;
                    var t = new String("abc");
                    if (t[5] = "de", "5" === Object.getOwnPropertyNames(t)[0]) return !1;
                    for (var e = {}, n = 0; n < 10; n++) e["_" + String.fromCharCode(n)] = n;
                    if ("0123456789" !== Object.getOwnPropertyNames(e).map((function(t) {
                            return e[t]
                        })).join("")) return !1;
                    var i = {};
                    return "abcdefghijklmnopqrst".split("").forEach((function(t) {
                        i[t] = t
                    })), "abcdefghijklmnopqrst" === Object.keys(Object.assign({}, i)).join("")
                } catch (t) {
                    return !1
                }
            }() ? Object.assign : function(t, e) {
                for (var n, i, r = Qg(t), s = 1; s < arguments.length; s++) {
                    for (var o in n = Object(arguments[s])) Zg.call(n, o) && (r[o] = n[o]);
                    if (Yg) {
                        i = Yg(n);
                        for (var a = 0; a < i.length; a++) Jg.call(n, i[a]) && (r[i[a]] = n[i[a]])
                    }
                }
                return r
            };

            function $g() {}
            $g.prototype = {
                on: function(t, e, n) {
                    var i = this.e || (this.e = {});
                    return (i[t] || (i[t] = [])).push({
                        fn: e,
                        ctx: n
                    }), this
                },
                once: function(t, e, n) {
                    var i = this;

                    function r() {
                        i.off(t, r), e.apply(n, arguments)
                    }
                    return r._ = e, this.on(t, r, n)
                },
                emit: function(t) {
                    for (var e = [].slice.call(arguments, 1), n = ((this.e || (this.e = {}))[t] || []).slice(), i = 0, r = n.length; i < r; i++) n[i].fn.apply(n[i].ctx, e);
                    return this
                },
                off: function(t, e) {
                    var n = this.e || (this.e = {}),
                        i = n[t],
                        r = [];
                    if (i && e)
                        for (var s = 0, o = i.length; s < o; s++) i[s].fn !== e && i[s].fn._ !== e && r.push(i[s]);
                    return r.length ? n[t] = r : delete n[t], this
                }
            };
            var tv = $g,
                ev = jg((function(t, e) {
                    (function() {
                        (null !== e ? e : this).Lethargy = function() {
                            function t(t, e, n, i) {
                                this.stability = null != t ? Math.abs(t) : 8, this.sensitivity = null != e ? 1 + Math.abs(e) : 100, this.tolerance = null != n ? 1 + Math.abs(n) : 1.1, this.delay = null != i ? i : 150, this.lastUpDeltas = function() {
                                    var t, e, n;
                                    for (n = [], t = 1, e = 2 * this.stability; 1 <= e ? t <= e : t >= e; 1 <= e ? t++ : t--) n.push(null);
                                    return n
                                }.call(this), this.lastDownDeltas = function() {
                                    var t, e, n;
                                    for (n = [], t = 1, e = 2 * this.stability; 1 <= e ? t <= e : t >= e; 1 <= e ? t++ : t--) n.push(null);
                                    return n
                                }.call(this), this.deltasTimestamp = function() {
                                    var t, e, n;
                                    for (n = [], t = 1, e = 2 * this.stability; 1 <= e ? t <= e : t >= e; 1 <= e ? t++ : t--) n.push(null);
                                    return n
                                }.call(this)
                            }
                            return t.prototype.check = function(t) {
                                var e;
                                return null != (t = t.originalEvent || t).wheelDelta ? e = t.wheelDelta : null != t.deltaY ? e = -40 * t.deltaY : null == t.detail && 0 !== t.detail || (e = -40 * t.detail), this.deltasTimestamp.push(Date.now()), this.deltasTimestamp.shift(), e > 0 ? (this.lastUpDeltas.push(e), this.lastUpDeltas.shift(), this.isInertia(1)) : (this.lastDownDeltas.push(e), this.lastDownDeltas.shift(), this.isInertia(-1))
                            }, t.prototype.isInertia = function(t) {
                                var e, n, i, r, s, o, a;
                                return null === (e = -1 === t ? this.lastDownDeltas : this.lastUpDeltas)[0] ? t : !(this.deltasTimestamp[2 * this.stability - 2] + this.delay > Date.now() && e[0] === e[2 * this.stability - 1]) && (i = e.slice(0, this.stability), n = e.slice(this.stability, 2 * this.stability), a = i.reduce((function(t, e) {
                                    return t + e
                                })), s = n.reduce((function(t, e) {
                                    return t + e
                                })), o = a / i.length, r = s / n.length, Math.abs(o) < Math.abs(r * this.tolerance) && this.sensitivity < Math.abs(r) && t)
                            }, t.prototype.showLastUpDeltas = function() {
                                return this.lastUpDeltas
                            }, t.prototype.showLastDownDeltas = function() {
                                return this.lastDownDeltas
                            }, t
                        }()
                    }).call(Vg)
                })),
                nv = {
                    hasWheelEvent: "onwheel" in document,
                    hasMouseWheelEvent: "onmousewheel" in document,
                    hasTouch: "ontouchstart" in window || window.TouchEvent || window.DocumentTouch && document instanceof DocumentTouch,
                    hasTouchWin: navigator.msMaxTouchPoints && navigator.msMaxTouchPoints > 1,
                    hasPointer: !!window.navigator.msPointerEnabled,
                    hasKeyDown: "onkeydown" in document,
                    isFirefox: navigator.userAgent.indexOf("Firefox") > -1
                },
                iv = Object.prototype.toString,
                rv = Object.prototype.hasOwnProperty;

            function sv(t, e) {
                return function() {
                    return t.apply(e, arguments)
                }
            }
            var ov = ev.Lethargy,
                av = "virtualscroll",
                lv = fv,
                cv = 37,
                uv = 38,
                hv = 39,
                dv = 40,
                pv = 32;

            function fv(t) {
                ! function(t) {
                    if (!t) return console.warn("bindAll requires at least one argument.");
                    var e = Array.prototype.slice.call(arguments, 1);
                    if (0 === e.length)
                        for (var n in t) rv.call(t, n) && "function" == typeof t[n] && "[object Function]" == iv.call(t[n]) && e.push(n);
                    for (var i = 0; i < e.length; i++) {
                        var r = e[i];
                        t[r] = sv(t[r], t)
                    }
                }(this, "_onWheel", "_onMouseWheel", "_onTouchStart", "_onTouchMove", "_onKeyDown"), this.el = window, t && t.el && (this.el = t.el, delete t.el), this.options = Kg({
                    mouseMultiplier: 1,
                    touchMultiplier: 2,
                    firefoxMultiplier: 15,
                    keyStep: 120,
                    preventTouch: !1,
                    unpreventTouchClass: "vs-touchmove-allowed",
                    limitInertia: !1,
                    useKeyboard: !0,
                    useTouch: !0
                }, t), this.options.limitInertia && (this._lethargy = new ov), this._emitter = new tv, this._event = {
                    y: 0,
                    x: 0,
                    deltaX: 0,
                    deltaY: 0
                }, this.touchStartX = null, this.touchStartY = null, this.bodyTouchAction = null, void 0 !== this.options.passive && (this.listenerOptions = {
                    passive: this.options.passive
                })
            }

            function mv(t, e, n) {
                return (1 - n) * t + n * e
            }

            function gv(t) {
                var e = {};
                if (window.getComputedStyle) {
                    var n = getComputedStyle(t),
                        i = n.transform || n.webkitTransform || n.mozTransform,
                        r = i.match(/^matrix3d\((.+)\)$/);
                    return r ? (e.x = r ? parseFloat(r[1].split(", ")[12]) : 0, e.y = r ? parseFloat(r[1].split(", ")[13]) : 0) : (r = i.match(/^matrix\((.+)\)$/), e.x = r ? parseFloat(r[1].split(", ")[4]) : 0, e.y = r ? parseFloat(r[1].split(", ")[5]) : 0), e
                }
            }

            function vv(t) {
                for (var e = []; t && t !== document; t = t.parentNode) e.push(t);
                return e
            }
            fv.prototype._notify = function(t) {
                var e = this._event;
                e.x += e.deltaX, e.y += e.deltaY, this._emitter.emit(av, {
                    x: e.x,
                    y: e.y,
                    deltaX: e.deltaX,
                    deltaY: e.deltaY,
                    originalEvent: t
                })
            }, fv.prototype._onWheel = function(t) {
                var e = this.options;
                if (!this._lethargy || !1 !== this._lethargy.check(t)) {
                    var n = this._event;
                    n.deltaX = t.wheelDeltaX || -1 * t.deltaX, n.deltaY = t.wheelDeltaY || -1 * t.deltaY, nv.isFirefox && 1 == t.deltaMode && (n.deltaX *= e.firefoxMultiplier, n.deltaY *= e.firefoxMultiplier), n.deltaX *= e.mouseMultiplier, n.deltaY *= e.mouseMultiplier, this._notify(t)
                }
            }, fv.prototype._onMouseWheel = function(t) {
                if (!this.options.limitInertia || !1 !== this._lethargy.check(t)) {
                    var e = this._event;
                    e.deltaX = t.wheelDeltaX ? t.wheelDeltaX : 0, e.deltaY = t.wheelDeltaY ? t.wheelDeltaY : t.wheelDelta, this._notify(t)
                }
            }, fv.prototype._onTouchStart = function(t) {
                var e = t.targetTouches ? t.targetTouches[0] : t;
                this.touchStartX = e.pageX, this.touchStartY = e.pageY
            }, fv.prototype._onTouchMove = function(t) {
                var e = this.options;
                e.preventTouch && !t.target.classList.contains(e.unpreventTouchClass) && t.preventDefault();
                var n = this._event,
                    i = t.targetTouches ? t.targetTouches[0] : t;
                n.deltaX = (i.pageX - this.touchStartX) * e.touchMultiplier, n.deltaY = (i.pageY - this.touchStartY) * e.touchMultiplier, this.touchStartX = i.pageX, this.touchStartY = i.pageY, this._notify(t)
            }, fv.prototype._onKeyDown = function(t) {
                var e = this._event;
                e.deltaX = e.deltaY = 0;
                var n = window.innerHeight - 40;
                switch (t.keyCode) {
                    case cv:
                    case uv:
                        e.deltaY = this.options.keyStep;
                        break;
                    case hv:
                    case dv:
                        e.deltaY = -this.options.keyStep;
                        break;
                    case t.shiftKey:
                        e.deltaY = n;
                        break;
                    case pv:
                        e.deltaY = -n;
                        break;
                    default:
                        return
                }
                this._notify(t)
            }, fv.prototype._bind = function() {
                nv.hasWheelEvent && this.el.addEventListener("wheel", this._onWheel, this.listenerOptions), nv.hasMouseWheelEvent && this.el.addEventListener("mousewheel", this._onMouseWheel, this.listenerOptions), nv.hasTouch && this.options.useTouch && (this.el.addEventListener("touchstart", this._onTouchStart, this.listenerOptions), this.el.addEventListener("touchmove", this._onTouchMove, this.listenerOptions)), nv.hasPointer && nv.hasTouchWin && (this.bodyTouchAction = document.body.style.msTouchAction, document.body.style.msTouchAction = "none", this.el.addEventListener("MSPointerDown", this._onTouchStart, !0), this.el.addEventListener("MSPointerMove", this._onTouchMove, !0)), nv.hasKeyDown && this.options.useKeyboard && document.addEventListener("keydown", this._onKeyDown)
            }, fv.prototype._unbind = function() {
                nv.hasWheelEvent && this.el.removeEventListener("wheel", this._onWheel), nv.hasMouseWheelEvent && this.el.removeEventListener("mousewheel", this._onMouseWheel), nv.hasTouch && (this.el.removeEventListener("touchstart", this._onTouchStart), this.el.removeEventListener("touchmove", this._onTouchMove)), nv.hasPointer && nv.hasTouchWin && (document.body.style.msTouchAction = this.bodyTouchAction, this.el.removeEventListener("MSPointerDown", this._onTouchStart, !0), this.el.removeEventListener("MSPointerMove", this._onTouchMove, !0)), nv.hasKeyDown && this.options.useKeyboard && document.removeEventListener("keydown", this._onKeyDown)
            }, fv.prototype.on = function(t, e) {
                this._emitter.on(av, t, e);
                var n = this._emitter.e;
                n && n[av] && 1 === n[av].length && this._bind()
            }, fv.prototype.off = function(t, e) {
                this._emitter.off(av, t, e);
                var n = this._emitter.e;
                (!n[av] || n[av].length <= 0) && this._unbind()
            }, fv.prototype.reset = function() {
                var t = this._event;
                t.x = 0, t.y = 0
            }, fv.prototype.destroy = function() {
                this._emitter.off(), this._unbind()
            };
            var yv = .1,
                xv = "function" == typeof Float32Array;

            function _v(t, e) {
                return 1 - 3 * e + 3 * t
            }

            function bv(t, e) {
                return 3 * e - 6 * t
            }

            function wv(t) {
                return 3 * t
            }

            function Mv(t, e, n) {
                return ((_v(e, n) * t + bv(e, n)) * t + wv(e)) * t
            }

            function Sv(t, e, n) {
                return 3 * _v(e, n) * t * t + 2 * bv(e, n) * t + wv(e)
            }

            function Ev(t) {
                return t
            }
            var Dv = function(t, e, n, i) {
                    if (!(0 <= t && t <= 1 && 0 <= n && n <= 1)) throw new Error("bezier x values must be in [0, 1] range");
                    if (t === e && n === i) return Ev;
                    for (var r = xv ? new Float32Array(11) : new Array(11), s = 0; s < 11; ++s) r[s] = Mv(s * yv, t, n);

                    function o(e) {
                        for (var i = 0, s = 1; 10 !== s && r[s] <= e; ++s) i += yv;
                        --s;
                        var o = i + (e - r[s]) / (r[s + 1] - r[s]) * yv,
                            a = Sv(o, t, n);
                        return a >= .001 ? function(t, e, n, i) {
                            for (var r = 0; r < 4; ++r) {
                                var s = Sv(e, n, i);
                                if (0 === s) return e;
                                e -= (Mv(e, n, i) - t) / s
                            }
                            return e
                        }(e, o, t, n) : 0 === a ? o : function(t, e, n, i, r) {
                            var s, o, a = 0;
                            do {
                                (s = Mv(o = e + (n - e) / 2, i, r) - t) > 0 ? n = o : e = o
                            } while (Math.abs(s) > 1e-7 && ++a < 10);
                            return o
                        }(e, i, i + yv, t, n)
                    }
                    return function(t) {
                        return 0 === t ? 0 : 1 === t ? 1 : Mv(o(t), e, i)
                    }
                },
                Tv = 38,
                Av = 40,
                Cv = 32,
                Lv = 9,
                Rv = 33,
                Pv = 34,
                Fv = 36,
                Ov = 35,
                Iv = function(t) {
                    Rg(n, t);
                    var e = Ng(n);

                    function n() {
                        var t, i = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                        return Eg(this, n), history.scrollRestoration && (history.scrollRestoration = "manual"), window.scrollTo(0, 0), (t = e.call(this, i)).inertia && (t.lerp = .1 * t.inertia), t.isScrolling = !1, t.isDraggingScrollbar = !1, t.isTicking = !1, t.hasScrollTicking = !1, t.parallaxElements = {}, t.stop = !1, t.scrollbarContainer = i.scrollbarContainer, t.checkKey = t.checkKey.bind(Og(t)), window.addEventListener("keydown", t.checkKey, !1), t
                    }
                    return Tg(n, [{
                        key: "init",
                        value: function() {
                            var t = this;
                            this.html.classList.add(this.smoothClass), this.html.setAttribute("data-".concat(this.name, "-direction"), this.direction), this.instance = Lg({
                                delta: {
                                    x: this.initPosition.x,
                                    y: this.initPosition.y
                                },
                                scroll: {
                                    x: this.initPosition.x,
                                    y: this.initPosition.y
                                }
                            }, this.instance), this.vs = new lv({
                                el: this.scrollFromAnywhere ? document : this.el,
                                mouseMultiplier: navigator.platform.indexOf("Win") > -1 ? 1 : .4,
                                firefoxMultiplier: this.firefoxMultiplier,
                                touchMultiplier: this.touchMultiplier,
                                useKeyboard: !1,
                                passive: !0
                            }), this.vs.on((function(e) {
                                t.stop || t.isDraggingScrollbar || requestAnimationFrame((function() {
                                    t.updateDelta(e), t.isScrolling || t.startScrolling()
                                }))
                            })), this.setScrollLimit(), this.initScrollBar(), this.addSections(), this.addElements(), this.checkScroll(!0), this.transformElements(!0, !0), Bg(Pg(n.prototype), "init", this).call(this)
                        }
                    }, {
                        key: "setScrollLimit",
                        value: function() {
                            if (this.instance.limit.y = this.el.offsetHeight - this.windowHeight, "horizontal" === this.direction) {
                                for (var t = 0, e = this.el.children, n = 0; n < e.length; n++) t += e[n].offsetWidth;
                                this.instance.limit.x = t - this.windowWidth
                            }
                        }
                    }, {
                        key: "startScrolling",
                        value: function() {
                            this.startScrollTs = Date.now(), this.isScrolling = !0, this.checkScroll(), this.html.classList.add(this.scrollingClass)
                        }
                    }, {
                        key: "stopScrolling",
                        value: function() {
                            cancelAnimationFrame(this.checkScrollRaf), this.scrollToRaf && (cancelAnimationFrame(this.scrollToRaf), this.scrollToRaf = null), this.isScrolling = !1, this.instance.scroll.y = Math.round(this.instance.scroll.y), this.html.classList.remove(this.scrollingClass)
                        }
                    }, {
                        key: "checkKey",
                        value: function(t) {
                            var e = this;
                            if (this.stop) t.keyCode == Lv && requestAnimationFrame((function() {
                                e.html.scrollTop = 0, document.body.scrollTop = 0, e.html.scrollLeft = 0, document.body.scrollLeft = 0
                            }));
                            else {
                                switch (t.keyCode) {
                                    case Lv:
                                        requestAnimationFrame((function() {
                                            e.html.scrollTop = 0, document.body.scrollTop = 0, e.html.scrollLeft = 0, document.body.scrollLeft = 0, e.scrollTo(document.activeElement, {
                                                offset: -window.innerHeight / 2
                                            })
                                        }));
                                        break;
                                    case Tv:
                                        this.instance.delta[this.directionAxis] -= 240;
                                        break;
                                    case Av:
                                        this.instance.delta[this.directionAxis] += 240;
                                        break;
                                    case Rv:
                                        this.instance.delta[this.directionAxis] -= window.innerHeight;
                                        break;
                                    case Pv:
                                        this.instance.delta[this.directionAxis] += window.innerHeight;
                                        break;
                                    case Fv:
                                        this.instance.delta[this.directionAxis] -= this.instance.limit[this.directionAxis];
                                        break;
                                    case Ov:
                                        this.instance.delta[this.directionAxis] += this.instance.limit[this.directionAxis];
                                        break;
                                    case Cv:
                                        document.activeElement instanceof HTMLInputElement || document.activeElement instanceof HTMLTextAreaElement || (t.shiftKey ? this.instance.delta[this.directionAxis] -= window.innerHeight : this.instance.delta[this.directionAxis] += window.innerHeight);
                                        break;
                                    default:
                                        return
                                }
                                this.instance.delta[this.directionAxis] < 0 && (this.instance.delta[this.directionAxis] = 0), this.instance.delta[this.directionAxis] > this.instance.limit[this.directionAxis] && (this.instance.delta[this.directionAxis] = this.instance.limit[this.directionAxis]), this.stopScrolling(), this.isScrolling = !0, this.checkScroll(), this.html.classList.add(this.scrollingClass)
                            }
                        }
                    }, {
                        key: "checkScroll",
                        value: function() {
                            var t = this,
                                e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
                            if (e || this.isScrolling || this.isDraggingScrollbar) {
                                this.hasScrollTicking || (this.checkScrollRaf = requestAnimationFrame((function() {
                                    return t.checkScroll()
                                })), this.hasScrollTicking = !0), this.updateScroll();
                                var i = Math.abs(this.instance.delta[this.directionAxis] - this.instance.scroll[this.directionAxis]),
                                    r = Date.now() - this.startScrollTs;
                                if (!this.animatingScroll && r > 100 && (i < .5 && 0 != this.instance.delta[this.directionAxis] || i < .5 && 0 == this.instance.delta[this.directionAxis]) && this.stopScrolling(), Object.entries(this.sections).forEach((function(n) {
                                        var i = zg(n, 2),
                                            r = (i[0], i[1]);
                                        r.persistent || t.instance.scroll[t.directionAxis] > r.offset[t.directionAxis] && t.instance.scroll[t.directionAxis] < r.limit[t.directionAxis] ? ("horizontal" === t.direction ? t.transform(r.el, -t.instance.scroll[t.directionAxis], 0) : t.transform(r.el, 0, -t.instance.scroll[t.directionAxis]), r.inView || (r.inView = !0, r.el.style.opacity = 1, r.el.style.pointerEvents = "all", r.el.setAttribute("data-".concat(t.name, "-section-inview"), ""))) : ((r.inView || e) && (r.inView = !1, r.el.style.opacity = 0, r.el.style.pointerEvents = "none", r.el.removeAttribute("data-".concat(t.name, "-section-inview"))), t.transform(r.el, 0, 0))
                                    })), this.getDirection && this.addDirection(), this.getSpeed && (this.addSpeed(), this.speedTs = Date.now()), this.detectElements(), this.transformElements(), this.hasScrollbar) {
                                    var s = this.instance.scroll[this.directionAxis] / this.instance.limit[this.directionAxis] * this.scrollBarLimit[this.directionAxis];
                                    "horizontal" === this.direction ? this.transform(this.scrollbarThumb, s, 0) : this.transform(this.scrollbarThumb, 0, s)
                                }
                                Bg(Pg(n.prototype), "checkScroll", this).call(this), this.hasScrollTicking = !1
                            }
                        }
                    }, {
                        key: "resize",
                        value: function() {
                            this.windowHeight = window.innerHeight, this.windowWidth = window.innerWidth, this.checkContext(), this.windowMiddle = {
                                x: this.windowWidth / 2,
                                y: this.windowHeight / 2
                            }, this.update()
                        }
                    }, {
                        key: "updateDelta",
                        value: function(t) {
                            var e, n = this[this.context] && this[this.context].gestureDirection ? this[this.context].gestureDirection : this.gestureDirection;
                            e = "both" === n ? t.deltaX + t.deltaY : "vertical" === n ? t.deltaY : "horizontal" === n ? t.deltaX : t.deltaY, this.instance.delta[this.directionAxis] -= e * this.multiplier, this.instance.delta[this.directionAxis] < 0 && (this.instance.delta[this.directionAxis] = 0), this.instance.delta[this.directionAxis] > this.instance.limit[this.directionAxis] && (this.instance.delta[this.directionAxis] = this.instance.limit[this.directionAxis])
                        }
                    }, {
                        key: "updateScroll",
                        value: function(t) {
                            this.isScrolling || this.isDraggingScrollbar ? this.instance.scroll[this.directionAxis] = mv(this.instance.scroll[this.directionAxis], this.instance.delta[this.directionAxis], this.lerp) : this.instance.scroll[this.directionAxis] > this.instance.limit[this.directionAxis] ? this.setScroll(this.instance.scroll[this.directionAxis], this.instance.limit[this.directionAxis]) : this.instance.scroll.y < 0 ? this.setScroll(this.instance.scroll[this.directionAxis], 0) : this.setScroll(this.instance.scroll[this.directionAxis], this.instance.delta[this.directionAxis])
                        }
                    }, {
                        key: "addDirection",
                        value: function() {
                            this.instance.delta.y > this.instance.scroll.y ? "down" !== this.instance.direction && (this.instance.direction = "down") : this.instance.delta.y < this.instance.scroll.y && "up" !== this.instance.direction && (this.instance.direction = "up"), this.instance.delta.x > this.instance.scroll.x ? "right" !== this.instance.direction && (this.instance.direction = "right") : this.instance.delta.x < this.instance.scroll.x && "left" !== this.instance.direction && (this.instance.direction = "left")
                        }
                    }, {
                        key: "addSpeed",
                        value: function() {
                            this.instance.delta[this.directionAxis] != this.instance.scroll[this.directionAxis] ? this.instance.speed = (this.instance.delta[this.directionAxis] - this.instance.scroll[this.directionAxis]) / Math.max(1, Date.now() - this.speedTs) : this.instance.speed = 0
                        }
                    }, {
                        key: "initScrollBar",
                        value: function() {
                            if (this.scrollbar = document.createElement("span"), this.scrollbarThumb = document.createElement("span"), this.scrollbar.classList.add("".concat(this.scrollbarClass)), this.scrollbarThumb.classList.add("".concat(this.scrollbarClass, "_thumb")), this.scrollbar.append(this.scrollbarThumb), this.scrollbarContainer ? this.scrollbarContainer.append(this.scrollbar) : document.body.append(this.scrollbar), this.getScrollBar = this.getScrollBar.bind(this), this.releaseScrollBar = this.releaseScrollBar.bind(this), this.moveScrollBar = this.moveScrollBar.bind(this), this.scrollbarThumb.addEventListener("mousedown", this.getScrollBar), window.addEventListener("mouseup", this.releaseScrollBar), window.addEventListener("mousemove", this.moveScrollBar), this.hasScrollbar = !1, "horizontal" == this.direction) {
                                if (this.instance.limit.x + this.windowWidth <= this.windowWidth) return
                            } else if (this.instance.limit.y + this.windowHeight <= this.windowHeight) return;
                            this.hasScrollbar = !0, this.scrollbarBCR = this.scrollbar.getBoundingClientRect(), this.scrollbarHeight = this.scrollbarBCR.height, this.scrollbarWidth = this.scrollbarBCR.width, "horizontal" === this.direction ? this.scrollbarThumb.style.width = "".concat(this.scrollbarWidth * this.scrollbarWidth / (this.instance.limit.x + this.scrollbarWidth), "px") : this.scrollbarThumb.style.height = "".concat(this.scrollbarHeight * this.scrollbarHeight / (this.instance.limit.y + this.scrollbarHeight), "px"), this.scrollbarThumbBCR = this.scrollbarThumb.getBoundingClientRect(), this.scrollBarLimit = {
                                x: this.scrollbarWidth - this.scrollbarThumbBCR.width,
                                y: this.scrollbarHeight - this.scrollbarThumbBCR.height
                            }
                        }
                    }, {
                        key: "reinitScrollBar",
                        value: function() {
                            if (this.hasScrollbar = !1, "horizontal" == this.direction) {
                                if (this.instance.limit.x + this.windowWidth <= this.windowWidth) return
                            } else if (this.instance.limit.y + this.windowHeight <= this.windowHeight) return;
                            this.hasScrollbar = !0, this.scrollbarBCR = this.scrollbar.getBoundingClientRect(), this.scrollbarHeight = this.scrollbarBCR.height, this.scrollbarWidth = this.scrollbarBCR.width, "horizontal" === this.direction ? this.scrollbarThumb.style.width = "".concat(this.scrollbarWidth * this.scrollbarWidth / (this.instance.limit.x + this.scrollbarWidth), "px") : this.scrollbarThumb.style.height = "".concat(this.scrollbarHeight * this.scrollbarHeight / (this.instance.limit.y + this.scrollbarHeight), "px"), this.scrollbarThumbBCR = this.scrollbarThumb.getBoundingClientRect(), this.scrollBarLimit = {
                                x: this.scrollbarWidth - this.scrollbarThumbBCR.width,
                                y: this.scrollbarHeight - this.scrollbarThumbBCR.height
                            }
                        }
                    }, {
                        key: "destroyScrollBar",
                        value: function() {
                            this.scrollbarThumb.removeEventListener("mousedown", this.getScrollBar), window.removeEventListener("mouseup", this.releaseScrollBar), window.removeEventListener("mousemove", this.moveScrollBar), this.scrollbar.remove()
                        }
                    }, {
                        key: "getScrollBar",
                        value: function(t) {
                            this.isDraggingScrollbar = !0, this.checkScroll(), this.html.classList.remove(this.scrollingClass), this.html.classList.add(this.draggingClass)
                        }
                    }, {
                        key: "releaseScrollBar",
                        value: function(t) {
                            this.isDraggingScrollbar = !1, this.html.classList.add(this.scrollingClass), this.html.classList.remove(this.draggingClass)
                        }
                    }, {
                        key: "moveScrollBar",
                        value: function(t) {
                            var e = this;
                            this.isDraggingScrollbar && requestAnimationFrame((function() {
                                var n = 100 * (t.clientX - e.scrollbarBCR.left) / e.scrollbarWidth * e.instance.limit.x / 100,
                                    i = 100 * (t.clientY - e.scrollbarBCR.top) / e.scrollbarHeight * e.instance.limit.y / 100;
                                i > 0 && i < e.instance.limit.y && (e.instance.delta.y = i), n > 0 && n < e.instance.limit.x && (e.instance.delta.x = n)
                            }))
                        }
                    }, {
                        key: "addElements",
                        value: function() {
                            var t = this;
                            this.els = {}, this.parallaxElements = {}, this.el.querySelectorAll("[data-".concat(this.name, "]")).forEach((function(e, n) {
                                var i, r, s, o = vv(e),
                                    a = Object.entries(t.sections).map((function(t) {
                                        var e = zg(t, 2);
                                        e[0];
                                        return e[1]
                                    })).find((function(t) {
                                        return o.includes(t.el)
                                    })),
                                    l = e.dataset[t.name + "Class"] || t.class,
                                    c = "string" == typeof e.dataset[t.name + "Id"] ? e.dataset[t.name + "Id"] : "el" + n,
                                    u = e.dataset[t.name + "Repeat"],
                                    h = e.dataset[t.name + "Call"],
                                    d = e.dataset[t.name + "Position"],
                                    p = e.dataset[t.name + "Delay"],
                                    f = e.dataset[t.name + "Direction"],
                                    m = "string" == typeof e.dataset[t.name + "Sticky"],
                                    g = !!e.dataset[t.name + "Speed"] && parseFloat(e.dataset[t.name + "Speed"]) / 10,
                                    v = "string" == typeof e.dataset[t.name + "Offset"] ? e.dataset[t.name + "Offset"].split(",") : t.offset,
                                    y = e.dataset[t.name + "Target"],
                                    x = (s = void 0 !== y ? document.querySelector("".concat(y)) : e).getBoundingClientRect();
                                null === a || a.inView ? (i = x.top + t.instance.scroll.y - gv(s).y, r = x.left + t.instance.scroll.x - gv(s).x) : (i = x.top - gv(a.el).y - gv(s).y, r = x.left - gv(a.el).x - gv(s).x);
                                var _ = i + s.offsetHeight,
                                    b = r + s.offsetWidth,
                                    w = {
                                        x: (b - r) / 2 + r,
                                        y: (_ - i) / 2 + i
                                    };
                                if (m) {
                                    var M = e.getBoundingClientRect(),
                                        S = M.top,
                                        E = M.left,
                                        D = {
                                            x: E - r,
                                            y: S - i
                                        };
                                    i += window.innerHeight, r += window.innerWidth, _ = S + s.offsetHeight - e.offsetHeight - D[t.directionAxis], w = {
                                        x: ((b = E + s.offsetWidth - e.offsetWidth - D[t.directionAxis]) - r) / 2 + r,
                                        y: (_ - i) / 2 + i
                                    }
                                }
                                u = "false" != u && (null != u || t.repeat);
                                var T = [0, 0];
                                if (v)
                                    if ("horizontal" === t.direction) {
                                        for (var A = 0; A < v.length; A++) "string" == typeof v[A] ? v[A].includes("%") ? T[A] = parseInt(v[A].replace("%", "") * t.windowWidth / 100) : T[A] = parseInt(v[A]) : T[A] = v[A];
                                        r += T[0], b -= T[1]
                                    } else {
                                        for (A = 0; A < v.length; A++) "string" == typeof v[A] ? v[A].includes("%") ? T[A] = parseInt(v[A].replace("%", "") * t.windowHeight / 100) : T[A] = parseInt(v[A]) : T[A] = v[A];
                                        i += T[0], _ -= T[1]
                                    }
                                var C = {
                                    el: e,
                                    id: c,
                                    class: l,
                                    section: a,
                                    top: i,
                                    middle: w,
                                    bottom: _,
                                    left: r,
                                    right: b,
                                    offset: v,
                                    progress: 0,
                                    repeat: u,
                                    inView: !1,
                                    call: h,
                                    speed: g,
                                    delay: p,
                                    position: d,
                                    target: s,
                                    direction: f,
                                    sticky: m
                                };
                                t.els[c] = C, e.classList.contains(l) && t.setInView(t.els[c], c), (!1 !== g || m) && (t.parallaxElements[c] = C)
                            }))
                        }
                    }, {
                        key: "addSections",
                        value: function() {
                            var t = this;
                            this.sections = {};
                            var e = this.el.querySelectorAll("[data-".concat(this.name, "-section]"));
                            0 === e.length && (e = [this.el]), e.forEach((function(e, n) {
                                var i = "string" == typeof e.dataset[t.name + "Id"] ? e.dataset[t.name + "Id"] : "section" + n,
                                    r = e.getBoundingClientRect(),
                                    s = {
                                        x: r.left - 1.5 * window.innerWidth - gv(e).x,
                                        y: r.top - 1.5 * window.innerHeight - gv(e).y
                                    },
                                    o = {
                                        x: s.x + r.width + 2 * window.innerWidth,
                                        y: s.y + r.height + 2 * window.innerHeight
                                    },
                                    a = "string" == typeof e.dataset[t.name + "Persistent"];
                                e.setAttribute("data-scroll-section-id", i);
                                var l = {
                                    el: e,
                                    offset: s,
                                    limit: o,
                                    inView: !1,
                                    persistent: a,
                                    id: i
                                };
                                t.sections[i] = l
                            }))
                        }
                    }, {
                        key: "transform",
                        value: function(t, e, n, i) {
                            var r;
                            if (i) {
                                var s = gv(t),
                                    o = mv(s.x, e, i),
                                    a = mv(s.y, n, i);
                                r = "matrix3d(1,0,0.00,0,0.00,1,0.00,0,0,0,1,0,".concat(o, ",").concat(a, ",0,1)")
                            } else r = "matrix3d(1,0,0.00,0,0.00,1,0.00,0,0,0,1,0,".concat(e, ",").concat(n, ",0,1)");
                            t.style.webkitTransform = r, t.style.msTransform = r, t.style.transform = r
                        }
                    }, {
                        key: "transformElements",
                        value: function(t) {
                            var e = this,
                                n = arguments.length > 1 && void 0 !== arguments[1] && arguments[1],
                                i = this.instance.scroll.x + this.windowWidth,
                                r = this.instance.scroll.y + this.windowHeight,
                                s = {
                                    x: this.instance.scroll.x + this.windowMiddle.x,
                                    y: this.instance.scroll.y + this.windowMiddle.y
                                };
                            Object.entries(this.parallaxElements).forEach((function(o) {
                                var a = zg(o, 2),
                                    l = (a[0], a[1]),
                                    c = !1;
                                if (t && (c = 0), l.inView || n) switch (l.position) {
                                    case "top":
                                        c = e.instance.scroll[e.directionAxis] * -l.speed;
                                        break;
                                    case "elementTop":
                                        c = (r - l.top) * -l.speed;
                                        break;
                                    case "bottom":
                                        c = (e.instance.limit[e.directionAxis] - r + e.windowHeight) * l.speed;
                                        break;
                                    case "left":
                                        c = e.instance.scroll[e.directionAxis] * -l.speed;
                                        break;
                                    case "elementLeft":
                                        c = (i - l.left) * -l.speed;
                                        break;
                                    case "right":
                                        c = (e.instance.limit[e.directionAxis] - i + e.windowHeight) * l.speed;
                                        break;
                                    default:
                                        c = (s[e.directionAxis] - l.middle[e.directionAxis]) * -l.speed
                                }
                                l.sticky && (c = l.inView ? "horizontal" === e.direction ? e.instance.scroll.x - l.left + window.innerWidth : e.instance.scroll.y - l.top + window.innerHeight : "horizontal" === e.direction ? e.instance.scroll.x < l.left - window.innerWidth && e.instance.scroll.x < l.left - window.innerWidth / 2 ? 0 : e.instance.scroll.x > l.right && e.instance.scroll.x > l.right + 100 && l.right - l.left + window.innerWidth : e.instance.scroll.y < l.top - window.innerHeight && e.instance.scroll.y < l.top - window.innerHeight / 2 ? 0 : e.instance.scroll.y > l.bottom && e.instance.scroll.y > l.bottom + 100 && l.bottom - l.top + window.innerHeight), !1 !== c && ("horizontal" === l.direction || "horizontal" === e.direction && "vertical" !== l.direction ? e.transform(l.el, c, 0, !t && l.delay) : e.transform(l.el, 0, c, !t && l.delay))
                            }))
                        }
                    }, {
                        key: "scrollTo",
                        value: function(t) {
                            var e = this,
                                n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},
                                i = parseInt(n.offset) || 0,
                                r = isNaN(parseInt(n.duration)) ? 1e3 : parseInt(n.duration),
                                s = n.easing || [.25, 0, .35, 1],
                                o = !!n.disableLerp,
                                a = !!n.callback && n.callback;
                            if (s = Dv.apply(void 0, kg(s)), "string" == typeof t) {
                                if ("top" === t) t = 0;
                                else if ("bottom" === t) t = this.instance.limit.y;
                                else if ("left" === t) t = 0;
                                else if ("right" === t) t = this.instance.limit.x;
                                else if (!(t = document.querySelector(t))) return
                            } else if ("number" == typeof t) t = parseInt(t);
                            else if (!t || !t.tagName) return void console.warn("`target` parameter is not valid");
                            if ("number" != typeof t) {
                                var l = vv(t).includes(this.el);
                                if (!l) return;
                                var c = t.getBoundingClientRect(),
                                    u = c.top,
                                    h = c.left,
                                    d = vv(t),
                                    p = d.find((function(t) {
                                        return Object.entries(e.sections).map((function(t) {
                                            var e = zg(t, 2);
                                            e[0];
                                            return e[1]
                                        })).find((function(e) {
                                            return e.el == t
                                        }))
                                    })),
                                    f = 0;
                                f = p ? gv(p)[this.directionAxis] : -this.instance.scroll[this.directionAxis], i = "horizontal" === this.direction ? h + i - f : u + i - f
                            } else i = t + i;
                            var m = parseFloat(this.instance.delta[this.directionAxis]),
                                g = Math.max(0, Math.min(i, this.instance.limit[this.directionAxis])),
                                v = g - m,
                                y = function(t) {
                                    o ? "horizontal" === e.direction ? e.setScroll(m + v * t, e.instance.delta.y) : e.setScroll(e.instance.delta.x, m + v * t) : e.instance.delta[e.directionAxis] = m + v * t
                                };
                            this.animatingScroll = !0, this.stopScrolling(), this.startScrolling();
                            var x = Date.now(),
                                _ = function t() {
                                    var n = (Date.now() - x) / r;
                                    n > 1 ? (y(1), e.animatingScroll = !1, 0 == r && e.update(), a && a()) : (e.scrollToRaf = requestAnimationFrame(t), y(s(n)))
                                };
                            _()
                        }
                    }, {
                        key: "update",
                        value: function() {
                            this.setScrollLimit(), this.addSections(), this.addElements(), this.detectElements(), this.updateScroll(), this.transformElements(!0), this.reinitScrollBar(), this.checkScroll(!0)
                        }
                    }, {
                        key: "startScroll",
                        value: function() {
                            this.stop = !1
                        }
                    }, {
                        key: "stopScroll",
                        value: function() {
                            this.stop = !0
                        }
                    }, {
                        key: "setScroll",
                        value: function(t, e) {
                            this.instance = Lg(Lg({}, this.instance), {}, {
                                scroll: {
                                    x: t,
                                    y: e
                                },
                                delta: {
                                    x: t,
                                    y: e
                                },
                                speed: 0
                            })
                        }
                    }, {
                        key: "destroy",
                        value: function() {
                            Bg(Pg(n.prototype), "destroy", this).call(this), this.stopScrolling(), this.html.classList.remove(this.smoothClass), this.vs.destroy(), this.destroyScrollBar(), window.removeEventListener("keydown", this.checkKey, !1)
                        }
                    }]), n
                }(Wg),
                Nv = function() {
                    function t() {
                        var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                        Eg(this, t), this.options = e, Object.assign(this, Gg, e), this.smartphone = Gg.smartphone, e.smartphone && Object.assign(this.smartphone, e.smartphone), this.tablet = Gg.tablet, e.tablet && Object.assign(this.tablet, e.tablet), this.smooth || "horizontal" != this.direction || console.warn(" `smooth:false` & `horizontal` direction are not yet compatible"), this.tablet.smooth || "horizontal" != this.tablet.direction || console.warn(" `smooth:false` & `horizontal` direction are not yet compatible (tablet)"), this.smartphone.smooth || "horizontal" != this.smartphone.direction || console.warn(" `smooth:false` & `horizontal` direction are not yet compatible (smartphone)"), this.init()
                    }
                    return Tg(t, [{
                        key: "init",
                        value: function() {
                            if (this.options.isMobile = /Android|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || "MacIntel" === navigator.platform && navigator.maxTouchPoints > 1 || window.innerWidth < this.tablet.breakpoint, this.options.isTablet = this.options.isMobile && window.innerWidth >= this.tablet.breakpoint, this.smooth && !this.options.isMobile || this.tablet.smooth && this.options.isTablet || this.smartphone.smooth && this.options.isMobile && !this.options.isTablet ? this.scroll = new Iv(this.options) : this.scroll = new Xg(this.options), this.scroll.init(), window.location.hash) {
                                var t = window.location.hash.slice(1, window.location.hash.length),
                                    e = document.getElementById(t);
                                e && this.scroll.scrollTo(e)
                            }
                        }
                    }, {
                        key: "update",
                        value: function() {
                            this.scroll.update()
                        }
                    }, {
                        key: "start",
                        value: function() {
                            this.scroll.startScroll()
                        }
                    }, {
                        key: "stop",
                        value: function() {
                            this.scroll.stopScroll()
                        }
                    }, {
                        key: "scrollTo",
                        value: function(t, e) {
                            this.scroll.scrollTo(t, e)
                        }
                    }, {
                        key: "setScroll",
                        value: function(t, e) {
                            this.scroll.setScroll(t, e)
                        }
                    }, {
                        key: "on",
                        value: function(t, e) {
                            this.scroll.setEvents(t, e)
                        }
                    }, {
                        key: "off",
                        value: function(t, e) {
                            this.scroll.unsetEvents(t, e)
                        }
                    }, {
                        key: "destroy",
                        value: function() {
                            this.scroll.destroy()
                        }
                    }]), t
                }();
            let Bv = document.querySelector(".active-container"),
                zv = null;
            const kv = () => zv,
                Hv = () => {
                    Bv = document.querySelector(".active-container"), Bv && (zv = new Nv({
                        el: Bv,
                        smooth: !0
                    }))
                },
                Uv = () => {
                    zv && (zv.destroy(), zv = null)
                };
            let Gv = document.querySelector(".active-container .article-intro"),
                Wv = null;
            const Vv = () => {
                Gv = document.querySelector(".active-container .article-intro"), Gv && (() => {
                    if (!Wv) {
                        const t = Gv.querySelector("h1"),
                            e = Gv.querySelector("p"),
                            n = Gv.querySelector(".film"),
                            i = Gv.querySelector(".media"),
                            r = n.querySelector(".watch-btn"),
                            s = new ur(t, {
                                type: "lines,chars"
                            }),
                            o = new ur(e, {
                                type: "lines"
                            });
                        Wv = xi.timeline({
                            paused: 1
                        }).add(Sr(s), "<").add(Er(o), "<.2").add(Lr(n, i), "<.2").add(Dr(r), "<.4")
                    }
                })()
            };
            let jv = document.querySelectorAll(".active-container .article-pagination button"),
                qv = [];
            const Xv = t => {
                    qv.forEach(((e, n) => {
                        const i = t.currentElements[e];
                        if ("object" == typeof i) {
                            const {
                                inView: t,
                                progress: e
                            } = i;
                            t && e > .5 && (r = n, jv.forEach(((t, e) => {
                                t.classList.toggle("-a", e === r)
                            })))
                        }
                        var r
                    }))
                },
                Yv = () => {
                    const t = kv();
                    jv = document.querySelectorAll(".active-container .article-pagination button"), jv.length && t && (qv = [], jv.forEach(((e, n) => {
                        const i = "chapter-" + ("0" + (n + 1)).slice(-2);
                        qv.push(i), e.addEventListener("click", (e => {
                            t.scrollTo(".article-" + i)
                        }))
                    })), t.on("scroll", Xv))
                };
            let Zv = document.querySelectorAll(".active-container [data-scroll-appear]"),
                Jv = [];
            const Qv = t => {
                    const e = t.scroll.y,
                        n = window.innerHeight,
                        i = document.body.scrollHeight - n - 100;
                    Zv.forEach(((t, r) => {
                        const s = Jv[r],
                            {
                                top: o
                            } = t.getBoundingClientRect();
                        s.paused() && (o <= .82 * n || e >= i) && s.play()
                    }))
                },
                Kv = () => {
                    const t = kv();
                    Zv = document.querySelectorAll(".active-container [data-scroll-appear]"), Zv.length && t && (Zv.forEach(((t, e) => {
                        Jv[e] = (t => {
                            const e = t.dataset.scrollAppear;
                            if ("lines" === e) {
                                const e = new ur(t, {
                                    type: "lines"
                                });
                                return xi.timeline({
                                    paused: 1
                                }).add(Er(e))
                            }
                            if ("chapter-chars" === e) {
                                const e = t.querySelectorAll("p"),
                                    n = xi.timeline({
                                        paused: 1
                                    });
                                return Array.from(e).reverse().forEach((t => {
                                    n.from(t, {
                                        x: -t.getBoundingClientRect().left - 10,
                                        duration: 1,
                                        ease: "app.out"
                                    }, "<")
                                })), n
                            }
                            if ("video" === e) {
                                const e = t.querySelector(".mask"),
                                    n = t.querySelector(".play-btn"),
                                    i = t.querySelector("video");
                                return xi.timeline({
                                    paused: 1,
                                    onComplete: () => {
                                        mr && i.play()
                                    }
                                }).add(Lr(t, e)).add(Dr(n), "<.4")
                            }
                            if ("banner" === e) {
                                const e = t.querySelector(".mask");
                                return xi.timeline({
                                    paused: 1
                                }).add(Lr(t, e))
                            }
                            if ("appear-bottom" === e) return xi.timeline({
                                paused: 1
                            }).add(Tr(t))
                        })(t)
                    })), t.on("scroll", Qv))
                },
                $v = () => {
                    Jv.length && (Jv.forEach((t => {
                        t.kill()
                    })), Jv = [])
                };
            let ty = document.querySelectorAll(".active-container .video-default");
            const ey = t => {
                    ty.forEach(((e, n) => {
                        const i = e.querySelector("video");
                        n !== t && i.pause()
                    }))
                },
                ny = () => {
                    ty = document.querySelectorAll(".active-container .video-default"), ty.length && ty.forEach(((t, e) => {
                        const n = t.querySelector("video"),
                            i = t.querySelector(".play-btn"),
                            r = t.querySelector(".ov");
                        i.addEventListener("click", (t => {
                            mr ? n.controls || (ry(-1), ey(e), n.muted = !1, n.controls = !0, n.currentTime = 0, n.play(), xi.timeline().to(r, {
                                autoAlpha: 0,
                                duration: .4,
                                ease: "app.ease"
                            }).to(i, {
                                autoAlpha: 0,
                                scale: 0,
                                duration: .4,
                                ease: "app.ease"
                            }, "<")) : (n.play(), n.requestFullscreen())
                        }))
                    }))
                };
            let iy = document.querySelectorAll(".active-container .film");
            const ry = t => {
                    iy.forEach(((e, n) => {
                        const i = e.querySelector("video");
                        n !== t && i.pause()
                    }))
                },
                sy = () => {
                    iy = document.querySelectorAll(".active-container .film"), iy.length && iy.forEach(((t, e) => {
                        const n = t.querySelector(".ov"),
                            i = t.querySelector("video"),
                            r = t.querySelector(".circle-btn");
                        mr ? (t.addEventListener("mouseenter", (e => {
                            if (!i.controls) {
                                const {
                                    clientX: n,
                                    clientY: i
                                } = e;
                                (t => {
                                    t.querySelector("video").play()
                                })(t), ps("Watch Film")
                            }
                        })), t.addEventListener("mouseleave", (e => {
                            i.controls || ((t => {
                                t.querySelector("video").pause()
                            })(t), fs())
                        })), n.addEventListener("click", (t => {
                            fs(), ry(e), ey(-1), i.muted = !1, i.controls = !0, xi.to(n, {
                                autoAlpha: 0,
                                duration: .4,
                                ease: "app.ease"
                            })
                        }))) : r.addEventListener("click", (() => {
                            i.play(), i.requestFullscreen()
                        }))
                    }))
                };
            let oy = document.querySelectorAll(".explore"),
                ay = Array.from(document.querySelectorAll(".slider img"));
            const ly = window.innerWidth / 2,
                cy = window.innerHeight / 2;
            let uy = !1,
                hy = [];
            const dy = (t, e, n) => {
                    const i = ay.filter(((e, n) => -1 !== t.indexOf(n)));
                    xi.timeline().to(i, {
                        scale: uy ? 1.06 : 1,
                        duration: 1
                    }).to(i, {
                        rotationX: 7 * e,
                        rotationY: 7 * n,
                        duration: .8,
                        ease: "sine.out"
                    }, "<")
                },
                py = (t, e, n) => {
                    dy(t, 1 - n / cy, e / ly - 1)
                },
                fy = t => {
                    const {
                        clientX: e,
                        clientY: n
                    } = t;
                    uy && py(hy, e, n)
                },
                my = () => {
                    oy = document.querySelectorAll(".explore"), ay = Array.from(document.querySelectorAll(".slider img")), mr && oy.length && (oy.forEach(((t, e) => {
                        const n = !!t.href;
                        t.addEventListener("mouseenter", (t => {
                            ps(n ? "Explore" : "Coming Soon"), uy = !0, hy.push(e), hy.push(e + 4), py(hy, t.clientX, t.clientY)
                        })), t.addEventListener("mouseleave", (() => {
                            fs(), uy = !1, hy = [], dy([0, 1, 2, 3, 4, 5], 0, 0)
                        }))
                    })), window.addEventListener("mousemove", fy))
                };
            let gy = document.querySelector(".active-container .next"),
                vy = document.querySelector(".active-container .poster"),
                yy = null;
            const xy = t => {
                    var e, n;
                    e = t.clientX, n = t.clientY, xi.to(vy, {
                        x: e,
                        y: n,
                        duration: .2,
                        ease: "sine.out"
                    })
                },
                _y = () => {
                    gy = document.querySelector(".active-container .next"), vy = document.querySelector(".active-container .poster"), mr && gy && (yy || (yy = xi.timeline({
                        paused: 1
                    }).from(vy, {
                        autoAlpha: 0,
                        duration: .4,
                        ease: "app.ease"
                    })), gy.addEventListener("mouseenter", (() => {
                        yy.play()
                    })), gy.addEventListener("mouseleave", (() => {
                        yy.reverse()
                    })), window.addEventListener("mousemove", xy))
                },
                by = () => {
                    yy && (yy.kill(), yy = null, window.removeEventListener("mousemove", xy))
                };
            let wy = document.querySelector(".active-container .marquee"),
                My = null;
            const Sy = () => {
                wy = document.querySelector(".active-container .marquee"), wy && ((() => {
                    if (!My) {
                        const t = wy.querySelector(".tracker"),
                            e = -wy.querySelectorAll("p")[1].getBoundingClientRect().left;
                        My = xi.timeline({
                            repeat: -1
                        }).to(t, {
                            x: e,
                            duration: 10,
                            ease: "none"
                        })
                    }
                })(), My.play())
            };
            let Ey = document.querySelector(".active-container .about-intro"),
                Dy = null;
            const Ty = () => {
                Ey = document.querySelector(".active-container .about-intro"), Ey && (() => {
                    if (!Dy) {
                        const t = Ey.querySelector("h1"),
                            e = Ey.querySelector("h2"),
                            n = Ey.querySelector("h3"),
                            i = Ey.querySelector(".content-01 p"),
                            r = Ey.querySelector(".content-02 p"),
                            s = Ey.querySelectorAll(".social a"),
                            o = Ey.querySelector(".visit-btn"),
                            a = Ey.querySelector(".img-01"),
                            l = a.querySelector("img"),
                            c = Ey.querySelector(".img-02"),
                            u = c.querySelector("img"),
                            h = Ey.querySelector(".img-03"),
                            d = h.querySelector("img"),
                            p = new ur(t, {
                                type: "chars"
                            }),
                            f = new ur(i, {
                                type: "lines"
                            }),
                            m = new ur(r, {
                                type: "lines"
                            });
                        Dy = xi.timeline({
                            paused: 1
                        }).add(Sr(p), "<").add(Tr(e), "<.3").add(Er(f), "<.1").add(Tr(n), "<.2").add(Er(m), "<.1").add(Lr(a, l), "<.2").add(Lr(c, u), "<").add(Lr(h, d), "<").from(s, {
                            autoAlpha: 0,
                            duration: .4,
                            stagger: .1,
                            ease: "app.ease"
                        }, "<.2").add(Dr(o), "<.2")
                    }
                })()
            };
            let Ay = document.querySelector(".active-container .back-btn");
            const Cy = () => {
                Ay = document.querySelector(".active-container .back-btn"), Ay && Ay.addEventListener("click", (t => {
                    cs().history.previous ? window.history.back() : cs().go("/")
                }))
            };
            let Ly = document.querySelector(".active-container .info"),
                Ry = null;
            const Py = () => {
                Ly = document.querySelector(".active-container .info"), Ly && (() => {
                    if (!Ry) {
                        const t = Ly.querySelector("h1"),
                            e = Ly.querySelector(".raw-html"),
                            n = new ur(t, {
                                type: "chars, lines"
                            });
                        Ry = xi.timeline({
                            paused: 1
                        }).add(Sr(n), "<").add(Tr(e), "<.4")
                    }
                })()
            };
            let Fy = document.querySelectorAll('.active-container [href="#california_info"]');
            const Oy = () => {
                    const t = kv();
                    Fy = document.querySelectorAll('.active-container [href^="#"]'), Fy.length && t && Fy.forEach((e => {
                        const n = e.href.split("#")[1],
                            i = document.getElementById(n);
                        i && e.addEventListener("click", (e => {
                            e.preventDefault(), t.scrollTo(i)
                        }))
                    }))
                },
                Iy = document.querySelectorAll(".menu nav a"),
                Ny = t => {
                    Iy.forEach(((e, n) => {
                        e.classList.toggle("-a", n === t)
                    }))
                };
            let By = null,
                zy = null;
            const ky = () => By,
                Hy = () => {
                    As(), Ds(), Hm(), "index" === ky() && (Vm(), Xm(), Jm(), $m(), ng(), mr ? (fg(), vg(), _g = [Gm, qm, Zm, Km, eg], window.addEventListener("wheel", wg, {
                        passive: !1
                    })) : (_g = [Gm], window.addEventListener("scroll", Mg, {
                        passive: !1
                    })), _g.forEach((t => {
                        t.vars.onComplete = () => {
                            xg = !1
                        }
                    }))), my(), nx(), os()
                },
                Uy = () => {
                    Es(), km(), Sg(), uy = !1, hy = [], window.removeEventListener("mousemove", fy), ix(), as()
                },
                Gy = () => {
                    Uv(), Wv && (Wv.kill(), Wv = null), $v(), by(), My && (My.kill(), My = null)
                },
                Wy = () => {
                    Uv(), $v(), ix(), as(), Dy && (Dy.kill(), Dy = null), by(), ts.length && (ts.forEach((t => t.kill())), ts = [])
                },
                Vy = () => {
                    Ry && (Ry.kill(), Ry = null)
                },
                jy = () => {
                    "index" === By ? (Ss.play(), bg(0), Ny(-1)) : "article" === By ? (Hv(), Kv(), Yv(), Wv.play(), Mr(1), "/the-unknown/" === zy ? Ny(0) : "/cosmic-link/" === zy ? Ny(1) : "/return-to-earth/" === zy ? Ny(2) : "/the-way-forward/" === zy && Ny(3)) : "about" === By ? (Hv(), Kv(), Dy.play(), Mr(.54), Ny(-1)) : "info" === By && (Hv(), Oy(), Ry.play(), Mr(1), Ny(-1))
                },
                qy = () => {
                    cs().hooks.beforeEnter((({
                        next: t
                    }) => {
                        By = t.namespace, zy = t.url.path, t.container.classList.add("active-container")
                    })), cs().hooks.beforeLeave((({
                        current: t
                    }) => {
                        t.container.classList.remove("active-container")
                    })), cs().init({
                        transitions: [{
                            leave() {
                                const t = this.async();
                                new Promise(((t, e) => {
                                    xi.fromTo(gs, {
                                        y: "100%"
                                    }, {
                                        y: "0%",
                                        duration: .8,
                                        ease: "app.inOut",
                                        onComplete: () => {
                                            t()
                                        }
                                    })
                                })).then((() => {
                                    t()
                                }))
                            },
                            after() {
                                vs()
                            }
                        }],
                        views: [{
                            namespace: "index",
                            beforeEnter() {
                                Hy()
                            },
                            beforeLeave() {
                                Uy()
                            }
                        }, {
                            namespace: "article",
                            beforeEnter() {
                                Vv(), sy(), ny(), _y(), Sy()
                            },
                            beforeLeave() {
                                Gy()
                            }
                        }, {
                            namespace: "about",
                            beforeEnter() {
                                nx(), os(), Ty(), _y(), Cy(), es()
                            },
                            beforeLeave() {
                                Wy()
                            }
                        }, {
                            namespace: "info",
                            beforeEnter() {
                                Py(), Cy()
                            },
                            beforeLeave() {
                                Vy()
                            }
                        }]
                    })
                };
            let Xy = document.getElementById("sound"),
                Yy = document.querySelector(".active-container .sound-btn"),
                Zy = !1,
                Jy = {
                    v: 0
                },
                Qy = null;
            const Ky = () => {
                    const t = ky();
                    "index" !== t && "about" !== t || Zy || (Zy = !0, Xy.play(), xi.to(Jy, {
                        v: 1,
                        duration: 1,
                        ease: "none",
                        onUpdate: () => {
                            Xy.volume = Jy.v
                        }
                    }))
                },
                $y = () => {
                    Zy = !1, xi.to(Jy, {
                        v: 0,
                        duration: 1,
                        ease: "none",
                        onUpdate: () => {
                            Xy.volume = Jy.v
                        },
                        onComplete: () => {
                            Xy.pause()
                        }
                    })
                },
                tx = () => {
                    Zy && (mr ? Qy = setInterval((function() {
                        Jy.v > .02 ? (Jy.v -= .02, Xy.volume = Jy.v) : (Jy.v = 0, Xy.pause(), clearInterval(Qy))
                    }), 20) : Xy.pause())
                },
                ex = () => {
                    document.hidden ? tx() : Zy && (Qy && clearInterval(Qy), Ky())
                },
                nx = () => {
                    Yy = document.querySelector(".active-container .sound-btn"), Xy && (Yy && Yy.addEventListener("click", (() => {
                        Zy ? (is && (is.kill(), rs(2)), $y()) : (ss(), Ky())
                    })), document.addEventListener("visibilitychange", ex), window.addEventListener("pagehide", tx))
                },
                ix = () => {
                    $y(), document.removeEventListener("visibilitychange", ex), window.removeEventListener("pagehide", tx)
                },
                rx = document.querySelector(".preloader"),
                sx = rx.querySelector(".enter-btn");
            let ox = null;
            const ax = () => {
                    (() => {
                        if (!ox) {
                            const t = document.querySelector('[data-barba="container"]'),
                                e = rx.querySelector(".content");
                            ox = xi.timeline({
                                paused: 1,
                                onComplete: () => {
                                    jy()
                                }
                            }).set(t, {
                                visibility: "visible"
                            }), mr || ox.set(document.documentElement, {
                                overflow: "auto"
                            }), ox.to(rx, {
                                autoAlpha: 0,
                                duration: .6,
                                ease: "app.ease"
                            }).set(e, {
                                visibility: "hidden"
                            })
                        }
                    })(), sx.addEventListener("click", (() => {
                        ox.play()
                    }))
                },
                lx = document.querySelector(".preloader");
            let cx = null;
            var ux = function() {
                    window.addEventListener("mousemove", (t => {
                        wr(t.clientX, t.clientY)
                    })), document.body.addEventListener("mouseenter", (t => {
                        Mr(br), wr(t.clientX, t.clientY), xi.to(_r, {
                            autoAlpha: 1,
                            duration: .8,
                            ease: "app.ease"
                        })
                    })), document.body.addEventListener("mouseleave", (t => {
                        Mr(0), xi.to(_r, {
                            autoAlpha: 0,
                            duration: .8,
                            ease: "app.ease"
                        })
                    })), Vr(), Zr(), ms(), Ky()
                },
                hx = function() {
                    qy(), Qr.forEach(((t, e) => {
                        $r[e] = Jr(t), t.addEventListener("mouseenter", (t => {
                            $r[e].play()
                        })), t.addEventListener("mouseleave", (t => {
                            $r[e].reverse()
                        }))
                    })), cx.play(), ax(), ox.vars.onStart = function() {
                        ux()
                    }
                };
            (() => {
                const t = lx.querySelector(".content"),
                    e = lx.querySelector(".logo"),
                    n = lx.querySelector(".enter-btn"),
                    i = n.querySelector("span"),
                    r = n.querySelector(".headphone"),
                    s = n.querySelector(".border path"),
                    o = lx.querySelector(".hint"),
                    a = lx.querySelector(".privacy-hint");
                cx = xi.timeline({
                    paused: 1
                }).set(t, {
                    visibility: "visible"
                }, "<").add(Tr(e), "<").add((t => {
                    const e = t.getTotalLength();
                    return xi.set(t, {
                        strokeDasharray: e,
                        strokeDashoffset: e
                    }), xi.to(t, {
                        strokeDashoffset: 0,
                        duration: 1.2,
                        ease: "app.out"
                    })
                })(s), "<.2").add(Tr(o), "<.4").add(Tr(a), "<.2").from(i, {
                    autoAlpha: 0,
                    duration: .4,
                    ease: "app.ease"
                }, "<.4").from(r, {
                    autoAlpha: 0,
                    duration: .4,
                    ease: "app.ease"
                }, "<.1")
            })(), document.fonts ? document.fonts.ready.then((function() {
                hx()
            })) : hx()
        }()
}();